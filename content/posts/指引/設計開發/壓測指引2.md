+++
date = '2025-10-31T00:00:00+08:00'
draft = false
title = '壓測指引2'
tags = ['指引', '設計開發']
categories = ['指引']
+++
# Gemini 回答


好的，作為一個資深的系統架構師與 AP 性能調校專家，我會為您提供一份在這次壓力測試中，從頭到尾、由外到內需要關注的參數設定與調校檢查清單。

我們的目標非常明確：**在 50 個併發用戶（Concurrent Users）持續加壓一小時的條件下，確保 95% 的請求（95th Percentile）回應時間在 3 秒以內。**

這是一個系統性的工程，我們需要從壓力來源、作業系統、應用伺服器、一直到資料庫，逐層分析與調校。

---

### **核心調校哲學**

1.  **建立基準 (Establish Baseline):** 在進行任何調校之前，先用預設設定跑一次縮短版的壓力測試（例如 10-15 分鐘）。這個數據是你的黃金標準，所有的後續調校都必須跟這個基準線做比較，才能判斷是改善還是惡化。
2.  **一次只改一個參數 (Change One Thing at a Time):** 這是最重要的原則。如果你一次改了三個參數，效能變好了，你不會知道是哪個參數起了作用。反之，如果效能變差，你也不知道是誰的錯。
3.  **監控是你的眼睛 (Monitoring is Key):** 如果沒有監控，調校就如同矇著眼睛開車。你必須能夠即時看到 CPU、記憶體、網路、I/O、GC、執行緒等關鍵指標的變化。

---

### **第一層：壓力來源 (JMeter)**

確保壓力測試工具本身不是瓶頸。

| 參數/項目 | 建議與說明 |
| :--- | :--- |
| **啟動模式** | **絕對要使用命令列模式 (CLI Mode)** 進行正式壓測，不要使用 GUI 模式。GUI 模式會消耗大量客戶端資源，影響測試準確性。指令範例：`jmeter -n -t your_test_plan.jmx -l results.jtl` |
| **JVM Heap Size** | 修改 `jmeter.bat` 或 `jmeter.sh`，調整 JMeter 的 JVM 堆疊大小。如果請求或回應的資料量大，預設的 1G 可能不夠。建議至少設為 `HEAP="-Xms2g -Xmx2g"` 或更高，避免 JMeter 本身 OutOfMemory。 |
| **監聽器 (Listeners)** | 在正式壓測時，**禁用或刪除所有 GUI 上的監聽器**，如 "View Results Tree"、"Summary Report" 等。它們非常消耗資源。測試結束後，再用 `results.jtl` 檔來產生報告。 |
| **思考時間 (Think Time)** | 在請求之間加入合理的思考時間 (e.g., `Uniform Random Timer`)，模擬真實用戶行為。完全沒有思考時間的壓測會對伺服器造成不切實際的瞬間衝擊，可能無法反映真實場景的效能瓶頸。 |
| **分散式壓測** | 如果單台 JMeter 機器無法產生足夠的壓力（CPU/網路滿載），應考慮使用主從式 (Master-Slave) 的分散式架構來發動壓測。 |

---

### **第二層：作業系統 (AIX)**

AIX 有其獨特的監控與調校工具，是穩定運行的基礎。

| 參數/項目 | 監控指令 | 調校重點與觀察指標 |
| :--- | :--- | :--- |
| **CPU 使用率** | `topas`, `vmstat` | 觀察 `%user`, `%sys`, `%wait`。如果 `%sys` 長期過高，可能是核心層資源競爭；`%wait` 過高，代表 CPU 在等待 I/O，瓶頸可能在磁碟或網路。`run queue` (topas 中的 `Run-queue`) 長度不應持續超過 CPU 核心數的 2-3 倍。 |
| **記憶體** | `vmstat`, `svmon` | 觀察 `pi` (page-in), `po` (page-out)。如果 `po` 數值持續很高，表示實體記憶體不足，系統正在大量使用虛擬記憶體 (Paging Space)，會嚴重拖慢效能。這是必須優先解決的問題。 |
| **檔案描述符 (File Descriptors)** | `ulimit -n` | Java 應用程式會開啟大量 Socket 連線和檔案。如果 `ulimit -n` 的值太小（例如預設的 2048），很快就會耗盡，導致 "Too many open files" 錯誤。應將其調高到一個較大的值，例如 `65536`。 |
| **網路** | `netstat -v` | 檢查是否有 `packet drops` 或 `collisions`。檢查 `TCP/IP` 相關參數，例如 `tcp_keepalive_interval`, `somaxconn` (TCP 連線佇列大小) 是否合理。在高併發下，預設的 `somaxconn` 可能太小，導致新的連線請求被拒絕。 |
| **I/O** | `iostat` | 觀察磁碟的 `%tm_act` (繁忙度) 和 `avg-serv` (平均服務時間)。如果磁碟長期處於 100% 繁忙，或服務時間過長，表示 I/O 已經是瓶頸，需要檢查是否為 Db2 的 Log 或 Tablespace 所在磁碟。 |

---

### **第三層：應用伺服器 (WebSphere Liberty / JVM)**

這是應用效能調校的核心區域。所有設定都在 Liberty 的 `server.xml` 中進行。

| 參數/項目 | `server.xml` 設定/JVM 參數 | 調校重點與觀察指標 |
| :--- | :--- | :--- |
| **JVM Heap Size** | 在 `jvm.options` 中設定: `-Xms` 和 `-Xmx` | `-Xms` (初始堆疊大小) 和 `-Xmx` (最大堆疊大小) 最好設成一樣的值，避免 JVM 動態擴展/縮小 Heap 造成的效能抖動。大小需要根據應用程式的記憶體使用情況來決定。**必須啟用 GC Log** (`-Xlog:gc*:file=gc.log:time,level,tags:filecount=5,filesize=20m`) 來分析 GC 行為。 |
| **垃圾回收 (GC) 策略** | 在 `jvm.options` 中設定 | IBM 的 JVM (OpenJ9) 預設的 GC 策略是 `gencon` (Generational Concurrent)，通常在回應時間敏感的應用中表現良好。你需要分析 GC Log，觀察 **GC 停頓時間 (Pause Time)**。如果停頓時間過長（例如超過 200ms），會直接影響到 3 秒的回應時間目標。 |
| **執行緒池 (Thread Pool)** | `<executor name="default" coreThreads="50" maxThreads="200" keepAlive="60s" />` | `coreThreads` 和 `maxThreads` 是關鍵。`maxThreads` 必須大於等於你的併發用戶數（50）。一個初始建議是 `coreThreads` 設為 50，`maxThreads` 設為 100-200。如果請求在佇列中等待，表示執行緒池已滿，需要調高 `maxThreads`。但執行緒不是越多越好，過多會導致 CPU context switch 成本增加。使用 `topas -P` 或 Liberty 的監控工具觀察執行緒狀態。 |
| **資料庫連線池** | `<dataSource ...> <connectionManager minPoolSize="10" maxPoolSize="50" ... /> </dataSource>` | **這是最常見的瓶頸之一**。`maxPoolSize` 決定了應用程式能同時向資料庫發出的請求數。它的大小應小於等於資料庫設定的最大連線數。在壓測期間，必須監控連線池的使用情況。如果連線池一直處於 `maxPoolSize`，並且有執行緒在等待連線，就必須調高它。`minPoolSize` 可以設為 `maxPoolSize` 的 20%-25% 左右。 |

---

### **第四層：資料庫 (Db2)**

應用程式最終的依賴。

| 參數/項目 | 監控/調校方式 | 調校重點與觀察指標 |
| :--- | :--- | :--- |
| **連線數** | `db2 get dbm cfg | grep MAXAGENTS` | Db2 的 `MAX_COORDAGENTS` 或 `MAXAGENTS` 必須大於 Liberty 的 `maxPoolSize` 總和。 |
| **緩衝池 (Buffer Pool)** | `db2pd -db <dbname> -bufferpools` | 這是 Db2 的記憶體快取。盡可能讓更多的資料和索引停留在記憶體中，以減少物理 I/O。觀察 **Hit Ratio (命中率)**，理想情況下應高於 95%。如果命中率過低，應考慮增加 `BUFFERPOOL` 的大小。 |
| **鎖定 (Locking)** | `db2pd -db <dbname> -locks wait` | 觀察是否有大量的 `Lock Wait`。這表示交易之間存在資源爭搶，併發性會急劇下降。分析造成鎖定的 SQL，考慮優化交易邏輯或調整隔離級別 (Isolation Level)。檢查 `LOCKLIST` 和 `MAXLOCKS` 參數是否足夠。 |
| **SQL 效能** | `db2expln`, `db2exfmt` | **80% 的資料庫效能問題都源自於糟糕的 SQL**。找出壓測期間執行最頻繁、最耗時的 SQL。對這些 SQL 進行 `Explain Plan` 分析，檢查它們是否使用了正確的索引，是否存在 `Table Scan` (全表掃描)。**為慢查詢加上適當的索引是提升效能最有效的方法。** |
| **日誌 (Logging)** | `db2 get db cfg for <dbname> | grep LOG` | 檢查 `LOGFILSIZ`, `LOGPRIMARY`, `LOGSECOND`。如果交易量大，日誌空間可能成為瓶頸。 |

---

### **第五層：應用程式碼 (Spring Boot)**

| 項目 | 調校重點與觀察指標 |
| :--- | :--- |
| **快取 (Caching)** | 對於不常變動但查詢頻繁的資料，應導入快取機制 (如 EhCache, Caffeine, Redis)。這能極大地降低資料庫負擔。 |
| **日誌級別 (Logging Level)** | 在壓測環境中，將日誌級別調整為 `INFO` 或 `WARN`。過多的 `DEBUG` 或 `TRACE` 日誌會產生大量 I/O，嚴重影響效能。 |
| **非同步處理** | 對於非核心、耗時的操作（如發送郵件、記錄日誌），可以考慮使用 `@Async` 將其轉換為非同步處理，讓主執行緒能更快返回，改善 API 回應時間。 |
| **效能剖析 (Profiling)** | 如果問題依然存在，需要使用 APM (Application Performance Management) 工具，如 Instana, Dynatrace，或 Java Profiler (如 JProfiler, YourKit) 來深入分析程式碼，找出 CPU 或記憶體熱點，例如低效率的迴圈、過多的物件建立等。 |

### **總結：壓測與調校流程**

1.  **準備:** 設定好所有監控工具（`topas`, `vmstat`, `iostat`, GC Log, Liberty 監控, Db2 snapshot）。
2.  **基準測試:** 在預設設定下跑 15 分鐘，記錄 95% 回應時間、TPS (Transactions Per Second)、CPU/Memory 使用率。
3.  **分析瓶頸:**
    * 回應時間超時嗎？
    * 是 CPU 滿了？（檢查 Liberty Thread Pool, GC, 慢 SQL）
    * 是 Memory 不足導致 Paging？（檢查 AIX, JVM Heap）
    * 是 I/O Wait 過高？（檢查 Db2 Buffer Pool, 慢 SQL, 磁碟）
    * 是應用程式在等待資源？（檢查 DB Connection Pool, Lock Wait）
4.  **調校:** 根據分析，**選擇一個最可疑的參數** 進行調整。
5.  **再測試:** 重跑一次 15 分鐘的測試。
6.  **比較:** 將新結果與基準線比較。如果改善了，將此設定作為新的基準。如果惡化了，恢復原設定，嘗試調整下一個可疑參數。
7.  **重複:** 不斷重複 3-6 步，直到效能指標接近或達到目標。
8.  **完整驗證:** 當短時間測試達標後，進行完整的一小時壓力測試，以確認系統在高壓下是否能穩定運行，沒有記憶體洩漏或其他資源耗盡問題。

遵循這個結構化的方法，您就能有條不紊地找出系統瓶頸，並有效地完成效能調校任務。祝您壓測順利！

# Claude 回答

作為資深系統架構師，我來為您詳細說明在這個環境下進行壓測時需要關注的各個層面參數設定與調校重點。

## AIX 作業系統層面調校

**核心參數調整**
- `maxuproc`: 設定為 8192 或更高，確保有足夠的進程數
- `fsize`: 設為 unlimited，避免文件大小限制
- `data`: 增加到 unlimited，支援大記憶體使用
- `rss`: 實體記憶體限制調整為 unlimited
- `stack`: 堆疊大小設為 unlimited
- `core`: 核心轉儲文件大小設為 unlimited

**網路參數優化**
- `tcp_sendspace` 和 `tcp_recvspace`: 增加到 262144 或更高
- `udp_sendspace` 和 `udp_recvspace`: 調整為 65536
- `somaxconn`: 設定為 8192，增加連線佇列長度
- `tcp_timewait`: 減少到 15 秒，快速回收 TIME_WAIT 連線

**I/O 子系統調校**
- `minperm%` 和 `maxperm%`: 調整頁面快取記憶體比例
- `lru_file_repage`: 設為 0，優化檔案頁面重新分頁
- `strict_maxperm`: 設為 0，允許更靈活的記憶體使用

## IBM WebSphere Liberty 調校

**JVM 記憶體設定**
```xml
<jvm>
    <genericJvmArguments>-Xms4g -Xmx8g -Xmn2g</genericJvmArguments>
    <genericJvmArguments>-XX:+UseG1GC</genericJvmArguments>
    <genericJvmArguments>-XX:MaxGCPauseMillis=200</genericJvmArguments>
    <genericJvmArguments>-XX:G1HeapRegionSize=16m</genericJvmArguments>
</jvm>
```

**連線池設定**
```xml
<connectionManager id="DefaultConnectionManager" 
    maxPoolSize="100" 
    minPoolSize="10"
    connectionTimeout="30s"
    maxIdleTime="1800s"
    reapTime="180s"/>
```

**執行緒池調校**
```xml
<executor id="DefaultExecutor"
    name="DefaultExecutor"
    coreThreads="50"
    maxThreads="200"
    keepAlive="60s"
    stealPolicy="STRICT"/>
```

**HTTP 連線器優化**
```xml
<httpEndpoint id="defaultHttpEndpoint"
    host="*"
    httpPort="9080"
    httpsPort="9443">
    <httpOptions maxKeepAliveRequests="1000" 
                 persistTimeout="30s"/>
    <accessLogging enabled="false"/>
</httpEndpoint>
```

## DB2 資料庫調校

**連線參數**
- `max_connections`: 設為 500 或根據實際需求調整
- `max_coordagents`: 設為 200-300
- `max_poolsize`: 設為與應用連線池匹配的數值

**記憶體配置**
- `instance_memory`: 設為系統記憶體的 70-80%
- `database_memory`: 調整為 instance_memory 的適當比例
- `bufferpool`: 針對主要表格建立適當大小的緩衝池
- `sortheap`: 增加排序堆大小到 2048 或更高

**鎖定與並行控制**
- `locktimeout`: 設為 30-60 秒
- `dlchktime`: 死鎖檢查時間設為 10000
- `maxlocks`: 增加到 50-70

## Spring Boot 應用程式調校

**Tomcat 內嵌伺服器設定**
```yaml
server:
  tomcat:
    threads:
      max: 200
      min-spare: 50
    connection-timeout: 30s
    max-connections: 8192
    accept-count: 1000
```

**資料庫連線池 (HikariCP)**
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
```

**JPA/Hibernate 設定**
```yaml
spring:
  jpa:
    hibernate:
      jdbc:
        batch_size: 50
        fetch_size: 50
    properties:
      hibernate:
        cache.use_second_level_cache: true
        cache.use_query_cache: true
```

## JMeter 壓測參數設定

**執行緒群組設定**
- Number of Threads: 50
- Ramp-up Period: 300 秒 (5分鐘逐步增加負載)
- Loop Count: 根據一小時測試計算 (約 720 次)
- Duration: 3600 秒 (1小時)

**HTTP 請求預設值**
- Connect Timeout: 10000ms
- Response Timeout: 30000ms
- Follow Redirects: 勾選
- Keep-Alive: 勾選

**監控設定**
- 添加 Response Times Over Time 監聽器
- 設定 95th Percentile 監控
- 啟用 Transactions per Second 監控
- 配置系統資源監控 (CPU, Memory, Network)

## 關鍵效能指標監控

**應用層面**
- 回應時間分佈 (特別關注95百分位)
- 每秒交易數 (TPS)
- 錯誤率
- 記憶體使用率和 GC 頻率

**系統層面**
- CPU 使用率 (建議保持在80%以下)
- 記憶體使用率
- 磁碟 I/O 等待時間
- 網路頻寬使用情況

**資料庫層面**
- 連線使用率
- 鎖定等待時間
- 緩衝池命中率
- 慢查詢識別

在執行壓測前，建議先進行小規模測試驗證各項設定，然後逐步增加負載。同時準備好回滾計劃，以防調校參數造成系統不穩定。


# Gemini
## 請問jmeter 在一PC , 可以壓多thread
這是一個非常好的實務問題，也是所有性能測試工程師都會遇到的問題：「我這台機器到底能打出多少壓力？」

答案是：沒有一個固定的數字。 一台 PC 能壓的執行緒 (Thread) 數量，取決於多個因素，從數百到數千都有可能。

作為架構師，我們不能給一個模糊的答案，而是要提供一個分析框架和找出答案的方法。以下是決定這個上限的關鍵因素以及如何判斷您自己的極限。

決定 JMeter 執行緒上限的四大關鍵因素
1. PC 硬體規格 (你的武器有多強)
CPU: 這是最常見的瓶頸。 每個執行緒都需要 CPU 時間來建立請求、處理回應、執行斷言等。如果你的測試腳本很複雜（例如有大量的正規表示式或 Groovy 腳本），CPU 會很快被耗盡。

指標： 當壓測時，如果 JMeter 所在的 PC CPU 使用率持續高於 80-90%，那麼你很可能已經達到了 CPU 的極限。

記憶體 (RAM): 每個執行緒都會佔用一定的記憶體。如果你處理的回應內容很大，或者使用了大量的監聽器，記憶體消耗會非常快。

指標： 觀察 JMeter 的 JVM Heap 使用情況。如果 Heap 滿了並頻繁觸發 Full GC，或者系統本身開始使用虛擬記憶體 (Swap/Paging)，這就是記憶體瓶頸。

網路卡 (Network I/O): 一般的千兆網卡 (1 Gbps) 理論上有 125 MB/s 的傳輸上限。如果你的測試是下載大檔案或 API 回應的封包很大，可能會打滿網路帶寬。

指標： 監控網路傳輸速率。雖然這在一般的 API 測試中較少成為瓶頸，但仍需注意。

2. JMeter 的設定與使用方式 (你如何使用武器)
GUI 模式 vs. CLI 模式: 這是天與地的差別。 GUI 模式會消耗大量 CPU 和記憶體來繪製圖表和更新介面。任何正式的壓測都必須使用 CLI (命令列) 模式執行。 在 GUI 模式下，可能 100-200 個執行緒就會讓介面卡頓，但在 CLI 模式下，同樣的機器可能輕鬆跑到 500 個以上。

監聽器 (Listeners): 在測試計畫 (Test Plan) 中啟用太多監聽器，特別是 "View Results Tree" 或 "View Results in Table"，會吃掉巨量的記憶體和 CPU。正確的做法是在 CLI 模式下執行，將結果寫入 .jtl 檔案，測試結束後再用 GUI 開啟 .jtl 檔案來分析。

JMeter JVM Heap Size: JMeter 預設的 Heap Size (堆疊大小) 通常是 1GB。如果你的測試需要處理大量資料，這遠遠不夠。你必須在啟動 JMeter 前，修改 jmeter.bat 或 jmeter.sh，或透過環境變數來增加它。

例如，設定為 4GB：set HEAP=-Xms4g -Xmx4g (Windows) 或 export HEAP="-Xms4g -Xmx4g" (Linux/macOS)。

3. 測試腳本的複雜度 (你的招式有多複雜)
簡單的 HTTP 請求: 如果你的測試只是單純的發送 GET 請求並接收少量 JSON 回應，那麼單機可以模擬非常多的執行緒 (可能 1000+)。

複雜的腳本: 如果你的腳本包含以下元素，每個執行緒的資源消耗都會大增：

大量的後處理器 (Post-Processors): 如正規表示式提取器、JSON 提取器。

大量的斷言 (Assertions): 每個回應都做複雜的內容比對。

JSR223 或 BeanShell 腳本: 執行 Groovy 或 Java 程式碼非常消耗 CPU。

SSL/TLS 加密: HTTPS 連線的交握過程會比 HTTP 消耗更多的 CPU。

4. 思考時間 (Think Time)
在腳本中加入 "思考時間" (Timer) 會顯著影響單機的承載能力。500 個執行緒如果每個請求後都暫停 2 秒，那麼對 JMeter 機器產生的實際壓力，遠比 500 個執行緒毫不停歇地發送請求要小得多。

如何找出你 PC 的極限？(實戰方法)
準備監控: 在 JMeter 壓測機上打開你的系統監控工具（Windows 的 "工作管理員" 或 Linux 的 top/htop）。主要觀察 CPU 和記憶體使用率。

建立基準腳本: 使用你最終要執行的、已經優化過（移除監聽器、使用 CLI 模式）的測試腳本。

執行漸進式負載測試 (Ramp-up Test):

設定一個 逐步增加 的執行緒計畫。例如，在 10 分鐘內，從 0 個執行緒線性增加到 1000 個。

開始壓測，並持續觀察 JMeter 壓測機的 CPU 使用率。

你會看到，隨著執行緒數量增加，CPU 使用率也跟著線性上升。

在某個時間點，CPU 會達到 80-90% 並維持在這個水平，即使你設定的執行緒還在繼續增加，CPU 也上不去了。

這個點，就是這台 PC 在這個特定腳本下的極限。 如果你再增加執行緒，JMeter 本身會因為資源不足而變慢，導致它發送請求的速率下降，測出來的 TPS (每秒交易數) 不會再上升，甚至可能下降，回應時間也會變得不準確。

經驗法則與建議
對於中等複雜度的 API 測試： 一台配置正常 (例如 i5/i7 CPU, 8-16GB RAM) 的 PC，在 CLI 模式下，通常可以穩定地產生 300 到 800 個執行緒的壓力。

當需要的執行緒數超過單機極限時：

分散式壓測 (Distributed Testing): 這是 JMeter 的標準解決方案。使用一台 Controller (Master) 控制多台 Agent (Slave) 機器同時發動攻擊。例如，如果你需要 2000 個執行緒，而單機極限是 500，那你就可以用 1 台 Controller 控制 4 台 Agent 來達成目標。

雲端壓測平台: 使用像 BlazeMeter、OctoPerf 這樣的 SaaS 服務，或利用 JMeter 的雲端整合外掛，直接在 AWS/GCP/Azure 上啟動大量壓測實例。

總結來說，不要去猜測數字，要去實測。 透過一個簡單的漸進式負載測試，監控你自己的壓測機，你就能精準地知道它在你的測試場景下的真正能耐。

# Gemini
## JMeter 分散式壓測
好的，作為資深架構師，我為您整理一份從概念到實戰，涵蓋了建置 JMeter 分散式壓測環境的完整步驟、最佳實踐與常見問題排查。

### **一、基本概念與架構**

JMeter 分散式壓測採用的是 **控制器 (Controller / Master) - 代理 (Agent / Slave)** 的架構。

  * **控制器 (Controller):** 就是您操作 JMeter 圖形介面或命令列的主控電腦。它負責：
      * 編寫與管理測試腳本 (`.jmx` 檔案)。
      * 將測試腳本分發給所有代理機。
      * 命令所有代理機開始或停止測試。
      * 收集所有代理機的測試結果並匯總。
  * **代理 (Agent):** 也常被稱為負載機 (Load Generator)。它們是真正執行壓測、向目標伺服器發送請求的機器。它們只負責接收來自控制器的命令和腳本，並回傳測試結果。

**架構示意圖:**

```
              +----------------+
              |   控制器       |
              | (Controller)   |
              | (你的操作電腦)   |
              +----------------+
                   |
     (發送腳本與命令, 收集結果)
                   |
      +-----------------------------+
      |                             |
+----------------+          +----------------+
|    代理 1      |          |    代理 n      |
|   (Agent)      |          |   (Agent)      |
+----------------+          +----------------+
      |                             |
      (向目標伺- - - - - - - - - - - -> (向目標伺
      服器發送                      服器發送
      請求)                         請求)
      |                             |
      v                             v
+------------------------------------------+
|             待測系統 (Target System)      |
+------------------------------------------+
```

-----

### **二、環境準備 (Prerequisites) - 關鍵成功因素**

在開始設定前，請務必確保以下幾點，90% 的建置失敗都源自於此：

1.  **JMeter 版本一致:** 所有機器（控制器和所有代理）上安裝的 JMeter **版本必須完全相同**。
2.  **Java 版本一致:** 建議所有機器上安裝的 Java JDK 版本也保持一致，至少主版本號要相同 (e.g., 都是 Java 8 或都是 Java 11)。
3.  **網路連線:**
      * 所有機器必須在同一個子網路 (Subnet) 內，可以互相 `ping` 到對方。
      * **防火牆是最大的敵人！** 必須確保控制器和代理之間的特定連接埠 (Port) 是開放的。主要涉及 RMI (Remote Method Invocation) 通訊。
4.  **JMeter 外掛一致:** 如果你的測試腳本用到了任何外掛 (e.g., WebDriver Sampler, JSON Plugins)，那麼**每一台代理機**都必須安裝完全相同的外掛。

-----

### **三、建置步驟**

#### **步驟 1: 設定代理機 (Agent / Slave)**

在**每一台**要作為代理的機器上，執行以下操作：

1.  **進入 JMeter 的 bin 目錄:**
    ```bash
    cd /path/to/your/apache-jmeter/bin
    ```
2.  **啟動 Agent 服務:**
      * **Linux / macOS:**
        ```bash
        ./jmeter-server
        ```
      * **Windows:**
        ```batch
        jmeter-server.bat
        ```
3.  啟動成功後，你會看到類似以下的訊息，表示它正在預設的 RMI 埠 `1099` 上監聽來自控制器的命令。
    ```
    Creating RMI registry on port 1099...
    Server started and listening on port 1099
    ```

**【進階設定與最佳實踐 - 強烈建議】**

預設情況下，RMI 會使用一個動態埠來交換資料，這對防火牆設定非常不便。我們可以固定這個埠。

  * **編輯 `jmeter.properties` 檔案:**

      * 打開 `/path/to/your/apache-jmeter/bin/jmeter.properties`。
      * 找到並取消註解 (移除前面的 `#`) `server.rmi.localport` 這一行，並設定一個固定的埠號，例如 `50000`。
        ```properties
        # When running in server mode, RMI will use the port specified by the
        # server.rmi.port property (default 1099) to listen for incoming requests.
        # This property can be used to specify the port for the RMI server engine
        # to use for connecting back to the client.
        server.rmi.localport=50000
        ```

  * **防火牆設定:** 現在，你只需要在代理機的防火牆上，開啟兩個 Inbound TCP 埠：`1099` (RMI 註冊) 和 `50000` (RMI 通訊)。

  * **多網卡問題:** 如果代理機有多個 IP 位址，你可能需要明確指定 RMI 使用哪一個 IP。編輯 `jmeter-server` 腳本，在開頭加入：

    ```bash
    RMI_HOST_DEF=-Djava.rmi.server.hostname=your_agent_ip_address
    ```

#### **步驟 2: 設定控制器 (Controller / Master)**

在你的主控電腦上，執行以下操作：

1.  **進入 JMeter 的 bin 目錄。**
2.  **編輯 `jmeter.properties` 檔案。**
3.  **指定代理機列表:** 找到 `remote_hosts` 這一行，取消註解，並填入所有代理機的 IP 位址（以及可選的埠號，如果不是預設的 1099）。多個 IP 之間用逗號 `,` 隔開。
    ```properties
    # Remote Hosts - comma delimited
    remote_hosts=192.168.1.101:1099,192.168.1.102:1099
    ```
    *如果你按照上面的建議固定了 `localport`，這裡仍然是填寫 `1099`，`localport` 是 RMI 內部通訊用的。*

#### **步驟 3: 執行分散式壓測**

1.  **準備測試腳本:** 在**控制器**上，用 JMeter GUI 打開或建立你的 `.jmx` 測試腳本。你**不需要**將腳本複製到任何代理機上，控制器會自動分發。

2.  **執行測試 (強烈建議使用命令列):**

      * **方法一 (使用 `jmeter.properties` 中的設定):**
        打開命令列，執行以下指令。`-r` 參數會告訴 JMeter 啟動在 `remote_hosts` 中設定的所有代理。
        ```bash
        jmeter -n -t /path/to/your/test_plan.jmx -l /path/to/results.jtl -r
        ```
      * **方法二 (在命令列中直接指定):**
        如果你不想修改 `jmeter.properties`，可以使用 `-R` 參數在命令列中直接指定代理列表，這會覆蓋設定檔中的值，更具靈活性。
        ```bash
        jmeter -n -t /path/to/your/test_plan.jmx -l /path/to/results.jtl -R 192.168.1.101,192.168.1.102
        ```

3.  **結果分析:** 測試過程中，所有代理機的結果都會被即時傳回控制器，並寫入你在 `-l` 參數中指定的 `results.jtl` 檔案。測試結束後，你只需要在控制器上分析這個匯總後的結果檔案即可。

-----

### **四、重要注意事項與問題排查**

  * **CSV 檔案:** 如果你的測試腳本使用了 "CSV Data Set Config" 來讀取測試資料，那麼**這個 CSV 檔案必須手動複製到每一台代理機的相同相對路徑下**。控制器不會自動分發 CSV 檔案。
  * **連線失敗:**
      * **檢查防火牆:** 這是最常見的原因。確保控制器能存取代理機的 `1099` 和 `50000` (或你設定的 `localport`) 埠。可以在控制器上用 `telnet <agent_ip> 1099` 來測試連線。
      * **檢查 IP 位址:** 確保 `remote_hosts` 中填寫的 IP 是正確的，並且代理機上的 `jmeter-server` 服務已成功啟動。
  * **版本不匹配錯誤:** 如果啟動時報錯，提示版本相關問題，請務必回頭檢查所有機器的 JMeter 和 Java 版本是否完全一致。
  * **監控代理機:** 進行壓測時，**你必須監控所有代理機的 CPU、記憶體和網路使用情況**，而不僅僅是控制器。任何一台代理機達到資源瓶頸，都會影響整個測試結果的準確性。

按照以上步驟，您就可以成功建置一套穩定可靠的 JMeter 分散式壓力測試環境了。