+++
date = '2026-01-09T18:11:38+08:00'
draft = false
title = 'Anthropic Model Context Protocol (MCP) æ•™å­¸æ‰‹å†Š'
tags = ['æ•™å­¸', 'AIé–‹ç™¼']
categories = ['æ•™å­¸']

> **ç‰ˆæœ¬**: 1.0  
> **æœ€å¾Œæ›´æ–°**: 2026å¹´1æœˆ9æ—¥  
> **é©ç”¨æ–¼**: Claude Code 
> **Created by**: Eric Cheng
+++

# Anthropic Model Context Protocol (MCP) æ•™å­¸æ‰‹å†Š

> **ç‰ˆæœ¬è³‡è¨Š**ï¼šæœ¬æ‰‹å†ŠåŸºæ–¼ MCP è¦ç¯„ç‰ˆæœ¬ 2025-11-25  
> **æœ€å¾Œæ›´æ–°**ï¼š2026 å¹´ 1 æœˆ  
> **é©ç”¨å°è±¡**ï¼šè³‡æ·±è»Ÿé«”é–‹ç™¼å·¥ç¨‹å¸«ã€ç³»çµ±æ¶æ§‹å¸«

---

## ç›®éŒ„

- [ç¬¬ä¸€ç« ï¼šMCP æ¦‚è¿°èˆ‡æ ¸å¿ƒæ¦‚å¿µ](#ç¬¬ä¸€ç« mcp-æ¦‚è¿°èˆ‡æ ¸å¿ƒæ¦‚å¿µ)
  - [1.1 ä»€éº¼æ˜¯ MCPï¼Ÿ](#11-ä»€éº¼æ˜¯-mcp)
  - [1.2 ç‚ºä»€éº¼éœ€è¦ MCPï¼Ÿ](#12-ç‚ºä»€éº¼éœ€è¦-mcp)
  - [1.3 MCP æ¶æ§‹æ¦‚è¦½](#13-mcp-æ¶æ§‹æ¦‚è¦½)
- [ç¬¬äºŒç« ï¼šMCP æŠ€è¡“æ¶æ§‹æ·±åº¦è§£æ](#ç¬¬äºŒç« mcp-æŠ€è¡“æ¶æ§‹æ·±åº¦è§£æ)
  - [2.1 åˆ†å±¤æ¶æ§‹](#21-åˆ†å±¤æ¶æ§‹)
  - [2.2 è³‡æ–™å±¤å”è­°ï¼ˆData Layer Protocolï¼‰](#22-è³‡æ–™å±¤å”è­°data-layer-protocol)
  - [2.3 MCP æ ¸å¿ƒåŸèªï¼ˆPrimitivesï¼‰](#23-mcp-æ ¸å¿ƒåŸèªprimitives)
  - [2.4 é€šçŸ¥æ©Ÿåˆ¶ï¼ˆNotificationsï¼‰](#24-é€šçŸ¥æ©Ÿåˆ¶notifications)
- [ç¬¬ä¸‰ç« ï¼šå‚³è¼¸å±¤æ·±åº¦è§£æ](#ç¬¬ä¸‰ç« å‚³è¼¸å±¤æ·±åº¦è§£æ)
  - [3.1 STDIO Transport](#31-stdio-transport)
  - [3.2 Streamable HTTP Transport](#32-streamable-http-transport)
- [ç¬¬å››ç« ï¼šå¯¦æˆ°é–‹ç™¼æŒ‡å—](#ç¬¬å››ç« å¯¦æˆ°é–‹ç™¼æŒ‡å—)
  - [4.1 é–‹ç™¼ç’°å¢ƒè¨­ç½®](#41-é–‹ç™¼ç’°å¢ƒè¨­ç½®)
  - [4.2 é–‹ç™¼ MCP Server](#42-é–‹ç™¼-mcp-server)
  - [4.3 é–‹ç™¼ MCP Client](#43-é–‹ç™¼-mcp-client)
  - [4.4 æ•´åˆåˆ° AI æ‡‰ç”¨](#44-æ•´åˆåˆ°-ai-æ‡‰ç”¨)
- [ç¬¬äº”ç« ï¼šå®Œæ•´å¯¦æˆ°ç¯„ä¾‹](#ç¬¬äº”ç« å®Œæ•´å¯¦æˆ°ç¯„ä¾‹)
  - [5.1 ç¯„ä¾‹ä¸€ï¼šæª”æ¡ˆç³»çµ± MCP Server](#51-ç¯„ä¾‹ä¸€æª”æ¡ˆç³»çµ±-mcp-server)
  - [5.2 ç¯„ä¾‹äºŒï¼šè³‡æ–™åº«æŸ¥è©¢ MCP Server](#52-ç¯„ä¾‹äºŒè³‡æ–™åº«æŸ¥è©¢-mcp-server)
  - [5.3 ç¯„ä¾‹ä¸‰ï¼šAPI æ•´åˆ MCP Server](#53-ç¯„ä¾‹ä¸‰api-æ•´åˆ-mcp-server)
- [ç¬¬å…­ç« ï¼šæœ€ä½³å¯¦è¸èˆ‡è¨­è¨ˆæ¨¡å¼](#ç¬¬å…­ç« æœ€ä½³å¯¦è¸èˆ‡è¨­è¨ˆæ¨¡å¼)
  - [6.1 MCP Server è¨­è¨ˆåŸå‰‡](#61-mcp-server-è¨­è¨ˆåŸå‰‡)
  - [6.2 æ•ˆèƒ½å„ªåŒ–](#62-æ•ˆèƒ½å„ªåŒ–)
  - [6.3 å®‰å…¨æ€§è€ƒé‡](#63-å®‰å…¨æ€§è€ƒé‡)
  - [6.4 æ¸¬è©¦ç­–ç•¥](#64-æ¸¬è©¦ç­–ç•¥)
- [ç¬¬ä¸ƒç« ï¼šé€²éšä¸»é¡Œ](#ç¬¬ä¸ƒç« é€²éšä¸»é¡Œ)
  - [7.1 Tasks å¯¦é©—æ€§åŠŸèƒ½](#71-tasks-å¯¦é©—æ€§åŠŸèƒ½)
  - [7.2 è‡ªè¨‚å‚³è¼¸å±¤](#72-è‡ªè¨‚å‚³è¼¸å±¤)
  - [7.3 å¤šèªè¨€ SDK æ¯”è¼ƒ](#73-å¤šèªè¨€-sdk-æ¯”è¼ƒ)
  - [7.4 åµéŒ¯èˆ‡ç›£æ§](#74-åµéŒ¯èˆ‡ç›£æ§)
- [ç¬¬å…«ç« ï¼šç–‘é›£æ’è§£](#ç¬¬å…«ç« ç–‘é›£æ’è§£)
  - [8.1 å¸¸è¦‹éŒ¯èª¤èˆ‡è§£æ±ºæ–¹æ¡ˆ](#81-å¸¸è¦‹éŒ¯èª¤èˆ‡è§£æ±ºæ–¹æ¡ˆ)
  - [8.2 é™¤éŒ¯æŠ€å·§](#82-é™¤éŒ¯æŠ€å·§)
  - [8.3 éŒ¯èª¤è¨Šæ¯åƒè€ƒ](#83-éŒ¯èª¤è¨Šæ¯åƒè€ƒ)
- [ç¬¬ä¹ç« ï¼šå¯¦éš›æ¡ˆä¾‹ç ”ç©¶](#ç¬¬ä¹ç« å¯¦éš›æ¡ˆä¾‹ç ”ç©¶)
  - [9.1 æ¡ˆä¾‹ä¸€ï¼šä¼æ¥­çŸ¥è­˜åº« MCP Server](#91-æ¡ˆä¾‹ä¸€ä¼æ¥­çŸ¥è­˜åº«-mcp-server)
  - [9.2 æ¡ˆä¾‹äºŒï¼šDevOps æ•´åˆ MCP Server](#92-æ¡ˆä¾‹äºŒdevops-æ•´åˆ-mcp-server)
- [ç¬¬åç« ï¼šè³‡æºèˆ‡åƒè€ƒ](#ç¬¬åç« è³‡æºèˆ‡åƒè€ƒ)
  - [10.1 å®˜æ–¹è³‡æº](#101-å®˜æ–¹è³‡æº)
  - [10.2 ç¤¾ç¾¤è³‡æº](#102-ç¤¾ç¾¤è³‡æº)
  - [10.3 é–‹ç™¼ç’°å¢ƒå»ºè­°](#103-é–‹ç™¼ç’°å¢ƒå»ºè­°)
  - [10.4 ç‰ˆæœ¬ç›¸å®¹æ€§](#104-ç‰ˆæœ¬ç›¸å®¹æ€§)
  - [10.5 å¿«é€Ÿåƒè€ƒ](#105-å¿«é€Ÿåƒè€ƒ)
- [é™„éŒ„ï¼šæª¢æŸ¥æ¸…å–®ï¼ˆChecklistï¼‰](#é™„éŒ„æª¢æŸ¥æ¸…å–®checklist)
  - [A. Server é–‹ç™¼æª¢æŸ¥æ¸…å–®](#a-server-é–‹ç™¼æª¢æŸ¥æ¸…å–®)
  - [B. éƒ¨ç½²æª¢æŸ¥æ¸…å–®](#b-éƒ¨ç½²æª¢æŸ¥æ¸…å–®)
  - [C. ç¨‹å¼ç¢¼å¯©æŸ¥æª¢æŸ¥æ¸…å–®](#c-ç¨‹å¼ç¢¼å¯©æŸ¥æª¢æŸ¥æ¸…å–®)
  - [D. æ•…éšœæ’é™¤æª¢æŸ¥æ¸…å–®](#d-æ•…éšœæ’é™¤æª¢æŸ¥æ¸…å–®)

---

## ç¬¬ä¸€ç« ï¼šMCP æ¦‚è¿°èˆ‡æ ¸å¿ƒæ¦‚å¿µ

### 1.1 ä»€éº¼æ˜¯ MCPï¼Ÿ

#### 1.1.1 MCP çš„å®šç¾©èˆ‡æ ¸å¿ƒåƒ¹å€¼

**Model Context Protocolï¼ˆMCPï¼‰** æ˜¯ç”± Anthropic é–‹ç™¼çš„ä¸€å€‹é–‹æ”¾æ¨™æº–å”è­°ï¼Œæ—¨åœ¨ç‚º AI æ‡‰ç”¨ç¨‹å¼æä¾›ä¸€å€‹çµ±ä¸€çš„æ–¹å¼ä¾†é€£æ¥å„ç¨®è³‡æ–™ä¾†æºã€å·¥å…·å’Œæœå‹™ã€‚

> **æ ¸å¿ƒåƒ¹å€¼**ï¼šMCP å°±åƒæ˜¯ AI ä¸–ç•Œçš„ã€ŒUSB-Cã€â€”â€” ä¸€å€‹æ¨™æº–åŒ–çš„ä»‹é¢ï¼Œè®“ä»»ä½• AI æ‡‰ç”¨ç¨‹å¼éƒ½èƒ½è¼•é¬†é€£æ¥åˆ°ä»»ä½•ç›¸å®¹çš„è³‡æ–™ä¾†æºæˆ–å·¥å…·ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        MCP æ ¸å¿ƒåƒ¹å€¼                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ“ æ¨™æº–åŒ–ï¼šçµ±ä¸€çš„å”è­°è¦ç¯„ï¼Œé™ä½æ•´åˆæˆæœ¬                           â”‚
â”‚  âœ“ å¯é‡ç”¨ï¼šä¸€æ¬¡é–‹ç™¼ï¼Œå¤šè™•ä½¿ç”¨                                    â”‚
â”‚  âœ“ å®‰å…¨æ€§ï¼šå…§å»ºå®‰å…¨æ©Ÿåˆ¶ï¼Œä¿è­·æ•æ„Ÿè³‡æ–™                             â”‚
â”‚  âœ“ æ“´å±•æ€§ï¼šæ¨¡çµ„åŒ–è¨­è¨ˆï¼Œæ˜“æ–¼æ“´å±•åŠŸèƒ½                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 1.1.2 USB-C é¡æ¯”è§£é‡‹

æƒ³åƒåœ¨ USB-C å‡ºç¾ä¹‹å‰ï¼Œæ¯å€‹è¨­å‚™éƒ½æœ‰è‡ªå·±å°ˆå±¬çš„é€£æ¥ç·šï¼š

```mermaid
graph LR
    subgraph "æ²’æœ‰ MCP ä¹‹å‰"
        A1[AI æ‡‰ç”¨ 1] --> |å°ˆç”¨ API| D1[è³‡æ–™åº«]
        A1 --> |å°ˆç”¨é€£æ¥å™¨| F1[æª”æ¡ˆç³»çµ±]
        A2[AI æ‡‰ç”¨ 2] --> |å¦ä¸€å¥— API| D1
        A2 --> |å¦ä¸€å¥—é€£æ¥å™¨| F1
    end
```

```mermaid
graph LR
    subgraph "æœ‰ MCP ä¹‹å¾Œ"
        A1[AI æ‡‰ç”¨ 1] --> |MCP| M[MCP Server]
        A2[AI æ‡‰ç”¨ 2] --> |MCP| M
        M --> D1[è³‡æ–™åº«]
        M --> F1[æª”æ¡ˆç³»çµ±]
        M --> E1[å¤–éƒ¨ API]
    end
```

#### 1.1.3 MCP åœ¨ AI æ‡‰ç”¨ç”Ÿæ…‹ç³»çµ±ä¸­çš„å®šä½

| å±¤ç´š | èªªæ˜ | ç¯„ä¾‹ |
|------|------|------|
| **æ‡‰ç”¨å±¤** | AI æ‡‰ç”¨ç¨‹å¼ï¼ˆMCP Hostï¼‰ | Claude Desktopã€VS Codeã€è‡ªè¨‚ AI æ‡‰ç”¨ |
| **å”è­°å±¤** | MCP å”è­° | æ¨™æº–åŒ–çš„é€šè¨Šè¦ç¯„ |
| **æœå‹™å±¤** | MCP Server | è³‡æ–™åº«é€£æ¥å™¨ã€æª”æ¡ˆç³»çµ±æœå‹™ã€API æ•´åˆ |
| **è³‡æ–™å±¤** | åº•å±¤è³‡æº | è³‡æ–™åº«ã€æª”æ¡ˆã€å¤–éƒ¨æœå‹™ |

---

### 1.2 ç‚ºä»€éº¼éœ€è¦ MCPï¼Ÿ

#### 1.2.1 è§£æ±ºçš„æ ¸å¿ƒå•é¡Œ

**å•é¡Œä¸€ï¼šN Ã— M æ•´åˆå•é¡Œ**

æ²’æœ‰ MCP æ™‚ï¼Œå¦‚æœæœ‰ N å€‹ AI æ‡‰ç”¨å’Œ M å€‹è³‡æ–™ä¾†æºï¼Œéœ€è¦é–‹ç™¼ N Ã— M å€‹æ•´åˆã€‚

```
å‚³çµ±æ–¹å¼ï¼šN Ã— M = å¤§é‡é‡è¤‡å·¥ä½œ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AI App 1â”‚â”€â”€â”€â”€â†’â”‚ è³‡æ–™æº 1 â”‚
â”‚         â”‚â”€â”€â”€â”€â†’â”‚ è³‡æ–™æº 2 â”‚
â”‚         â”‚â”€â”€â”€â”€â†’â”‚ è³‡æ–™æº 3 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AI App 2â”‚â”€â”€â”€â”€â†’â”‚ è³‡æ–™æº 1 â”‚ ï¼ˆé‡è¤‡é–‹ç™¼ï¼‰
â”‚         â”‚â”€â”€â”€â”€â†’â”‚ è³‡æ–™æº 2 â”‚
â”‚         â”‚â”€â”€â”€â”€â†’â”‚ è³‡æ–™æº 3 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MCP æ–¹å¼ï¼šN + M = å¤§å¹…æ¸›å°‘å·¥ä½œé‡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AI App 1â”‚â”€â”€â”   â”Œâ”€â”€â†’â”‚ è³‡æ–™æº 1 â”‚
â”‚         â”‚  â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”œâ”€â”€MCPâ”€â”€â†’â”‚ è³‡æ–™æº 2 â”‚
â”‚ AI App 2â”‚  â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚         â”‚â”€â”€â”˜   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â†’â”‚ è³‡æ–™æº 3 â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å•é¡ŒäºŒï¼šå®‰å…¨æ€§èˆ‡æ¬Šé™ç®¡ç†åˆ†æ•£**

æ¯å€‹æ•´åˆéƒ½éœ€è¦ç¨ç«‹è™•ç†èªè­‰æˆæ¬Šï¼ŒMCP æä¾›çµ±ä¸€çš„å®‰å…¨æ¡†æ¶ã€‚

**å•é¡Œä¸‰ï¼šç¶­è­·æˆæœ¬é«˜æ˜‚**

API è®Šæ›´æ™‚éœ€è¦æ›´æ–°å¤šè™•ç¨‹å¼ç¢¼ï¼ŒMCP çš„æŠ½è±¡å±¤é™ä½äº†é€™ç¨®è€¦åˆã€‚

#### 1.2.2 å°ä¸åŒè§’è‰²çš„åƒ¹å€¼

| è§’è‰² | MCP å¸¶ä¾†çš„åƒ¹å€¼ |
|------|----------------|
| **é–‹ç™¼è€…** | â€¢ æ¸›å°‘é‡è¤‡é–‹ç™¼å·¥ä½œ<br>â€¢ æ¨™æº–åŒ–çš„é–‹ç™¼æ¨¡å¼<br>â€¢ è±å¯Œçš„ç¾æˆ Server å¯ç”¨ |
| **AI æ‡‰ç”¨** | â€¢ å¿«é€Ÿç²å–å¤–éƒ¨è³‡æ–™<br>â€¢ å‹•æ…‹ç™¼ç¾å¯ç”¨å·¥å…·<br>â€¢ çµ±ä¸€çš„éŒ¯èª¤è™•ç† |
| **çµ‚ç«¯ç”¨æˆ¶** | â€¢ æ›´å¼·å¤§çš„ AI èƒ½åŠ›<br>â€¢ æ›´å¥½çš„æ•´åˆé«”é©—<br>â€¢ è³‡æ–™å®‰å…¨æœ‰ä¿éšœ |
| **ä¼æ¥­** | â€¢ é™ä½æ•´åˆæˆæœ¬<br>â€¢ çµ±ä¸€çš„å®‰å…¨ç®¡ç†<br>â€¢ æ›´å¥½çš„å¯ç¶­è­·æ€§ |

#### 1.2.3 å¯¦éš›æ‡‰ç”¨å ´æ™¯ç¯„ä¾‹

```
å ´æ™¯ 1ï¼šä¼æ¥­çŸ¥è­˜åº«æ•´åˆ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Claude Desktop                                          â”‚
â”‚    â†“ MCP                                               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ Confluence   â”‚  â”‚ SharePoint   â”‚  â”‚ å…§éƒ¨ Wiki    â”‚   â”‚
â”‚ â”‚ MCP Server   â”‚  â”‚ MCP Server   â”‚  â”‚ MCP Server   â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å ´æ™¯ 2ï¼šé–‹ç™¼è€…å·¥å…·éˆæ•´åˆ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ VS Code + Claude                                        â”‚
â”‚    â†“ MCP                                               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚   GitHub     â”‚  â”‚    Jira      â”‚  â”‚  Database    â”‚   â”‚
â”‚ â”‚ MCP Server   â”‚  â”‚ MCP Server   â”‚  â”‚ MCP Server   â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.3 MCP æ¶æ§‹æ¦‚è¦½

#### 1.3.1 Client-Server æ¶æ§‹èªªæ˜

MCP æ¡ç”¨ç¶“å…¸çš„ Client-Server æ¶æ§‹ï¼Œä½†æœ‰å…¶ç¨ç‰¹çš„è§’è‰²å®šç¾©ï¼š

```mermaid
graph TB
    subgraph "MCP æ¶æ§‹"
        Host[MCP Host<br/>å¦‚ Claude Desktop]
        Client[MCP Client<br/>å”è­°å®¢æˆ¶ç«¯]
        Server[MCP Server<br/>åŠŸèƒ½æä¾›è€…]
        Resource[(è³‡æº<br/>è³‡æ–™åº«/æª”æ¡ˆ/API)]
        
        Host --> |åŒ…å«| Client
        Client <--> |MCP Protocol| Server
        Server --> |å­˜å–| Resource
    end
```

#### 1.3.2 MCP Hostã€Clientã€Server çš„è§’è‰²èˆ‡é—œä¿‚

| è§’è‰² | èªªæ˜ | è·è²¬ | ç¯„ä¾‹ |
|------|------|------|------|
| **Host** | å®¿ä¸»æ‡‰ç”¨ç¨‹å¼ | â€¢ æä¾›ä½¿ç”¨è€…ä»‹é¢<br>â€¢ ç®¡ç† Client ç”Ÿå‘½é€±æœŸ<br>â€¢ è™•ç†ä½¿ç”¨è€…æˆæ¬Š | Claude Desktopã€VS Codeã€è‡ªè¨‚æ‡‰ç”¨ |
| **Client** | å”è­°å®¢æˆ¶ç«¯ | â€¢ èˆ‡ Server å»ºç«‹é€£æ¥<br>â€¢ ç™¼é€è«‹æ±‚<br>â€¢ è™•ç†å›æ‡‰ | é€šå¸¸å…§åµŒæ–¼ Host |
| **Server** | åŠŸèƒ½æä¾›è€… | â€¢ æš´éœ² Tools/Resources/Prompts<br>â€¢ è™•ç†å®¢æˆ¶ç«¯è«‹æ±‚<br>â€¢ å­˜å–åº•å±¤è³‡æº | æª”æ¡ˆç³»çµ± Serverã€è³‡æ–™åº« Server |

**é—œä¿‚åœ–è§£**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         MCP Host                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                      MCP Client                          â”‚    â”‚
â”‚  â”‚  â€¢ é€£æ¥ç®¡ç†                                              â”‚    â”‚
â”‚  â”‚  â€¢ è«‹æ±‚/å›æ‡‰è™•ç†                                         â”‚    â”‚
â”‚  â”‚  â€¢ èƒ½åŠ›å”å•†                                              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚              â†‘                    â†‘                    â†‘         â”‚
â”‚              â”‚ MCP Protocol       â”‚                    â”‚         â”‚
â”‚              â†“                    â†“                    â†“         â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚     â”‚ Server A   â”‚      â”‚ Server B   â”‚      â”‚ Server C   â”‚      â”‚
â”‚     â”‚ (æª”æ¡ˆç³»çµ±) â”‚      â”‚ (è³‡æ–™åº«)   â”‚      â”‚ (GitHub)   â”‚      â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 1.3.3 æœ¬åœ°ä¼ºæœå™¨ vs é ç«¯ä¼ºæœå™¨çš„å·®ç•°

| ç‰¹æ€§ | æœ¬åœ°ä¼ºæœå™¨ï¼ˆLocal Serverï¼‰ | é ç«¯ä¼ºæœå™¨ï¼ˆRemote Serverï¼‰ |
|------|---------------------------|----------------------------|
| **éƒ¨ç½²ä½ç½®** | èˆ‡ Host åŒä¸€æ©Ÿå™¨ | ç¨ç«‹éƒ¨ç½²çš„ä¼ºæœå™¨ |
| **å‚³è¼¸æ–¹å¼** | STDIOï¼ˆæ¨™æº–è¼¸å…¥/è¼¸å‡ºï¼‰ | HTTP/SSE |
| **å•Ÿå‹•æ–¹å¼** | Host ç›´æ¥å•Ÿå‹•é€²ç¨‹ | ç¨ç«‹é‹è¡Œï¼Œé€éç¶²è·¯é€£æ¥ |
| **é©ç”¨å ´æ™¯** | å€‹äººå·¥å…·ã€æœ¬åœ°è³‡æºå­˜å– | åœ˜éšŠå…±äº«ã€é›²ç«¯æœå‹™ |
| **å®‰å…¨è€ƒé‡** | ç¹¼æ‰¿æœ¬åœ°æ¬Šé™ | éœ€è¦èªè­‰æˆæ¬Šæ©Ÿåˆ¶ |
| **æ•ˆèƒ½** | ä½å»¶é²ã€é«˜æ•ˆèƒ½ | ç¶²è·¯å»¶é²ã€éœ€è€ƒæ…®å¯ç”¨æ€§ |

**é¸æ“‡å»ºè­°**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    é¸æ“‡æœ¬åœ° vs é ç«¯ä¼ºæœå™¨                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  é¸æ“‡æœ¬åœ°ä¼ºæœå™¨ç•¶ï¼š                                               â”‚
â”‚  âœ“ å­˜å–æœ¬åœ°æª”æ¡ˆç³»çµ±                                              â”‚
â”‚  âœ“ éœ€è¦ä½å»¶é²å›æ‡‰                                                â”‚
â”‚  âœ“ å€‹äººä½¿ç”¨å ´æ™¯                                                  â”‚
â”‚  âœ“ é–‹ç™¼æ¸¬è©¦éšæ®µ                                                  â”‚
â”‚                                                                  â”‚
â”‚  é¸æ“‡é ç«¯ä¼ºæœå™¨ç•¶ï¼š                                               â”‚
â”‚  âœ“ å¤šäººå…±äº«æœå‹™                                                  â”‚
â”‚  âœ“ éœ€è¦é›†ä¸­ç®¡ç†                                                  â”‚
â”‚  âœ“ æ•´åˆé›²ç«¯æœå‹™                                                  â”‚
â”‚  âœ“ ç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²                                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> **ğŸ’¡ å¯¦å‹™å»ºè­°**ï¼šé–‹ç™¼éšæ®µå»ºè­°ä½¿ç”¨æœ¬åœ°ä¼ºæœå™¨é€²è¡Œå¿«é€Ÿè¿­ä»£ï¼Œç¢ºèªåŠŸèƒ½å¾Œå†éƒ¨ç½²ç‚ºé ç«¯ä¼ºæœå™¨ä¾›åœ˜éšŠä½¿ç”¨ã€‚

---

## ç¬¬äºŒç« ï¼šMCP æŠ€è¡“æ¶æ§‹æ·±åº¦è§£æ

### 2.1 åˆ†å±¤æ¶æ§‹

MCP æ¡ç”¨æ¸…æ™°çš„åˆ†å±¤æ¶æ§‹è¨­è¨ˆï¼Œå°‡é—œæ³¨é»åˆ†é›¢ï¼š

```mermaid
graph TB
    subgraph "MCP åˆ†å±¤æ¶æ§‹"
        App[æ‡‰ç”¨å±¤<br/>AI æ‡‰ç”¨ç¨‹å¼]
        Data[è³‡æ–™å±¤<br/>JSON-RPC 2.0 è¨Šæ¯]
        Transport[å‚³è¼¸å±¤<br/>STDIO / HTTP]
        Physical[å¯¦é«”å±¤<br/>é€²ç¨‹ / ç¶²è·¯]
        
        App --> Data
        Data --> Transport
        Transport --> Physical
    end
```

#### 2.1.1 è³‡æ–™å±¤ï¼ˆData Layerï¼‰è©³è§£

è³‡æ–™å±¤è² è²¬å®šç¾©è¨Šæ¯æ ¼å¼å’Œå”è­°èªç¾©ï¼š

| å…ƒç´  | èªªæ˜ | ç¯„ä¾‹ |
|------|------|------|
| **è¨Šæ¯æ ¼å¼** | JSON-RPC 2.0 | è«‹æ±‚ã€å›æ‡‰ã€é€šçŸ¥ |
| **ç”Ÿå‘½é€±æœŸ** | é€£æ¥ç‹€æ…‹ç®¡ç† | åˆå§‹åŒ–ã€å°±ç·’ã€é—œé–‰ |
| **èƒ½åŠ›å”å•†** | åŠŸèƒ½æ¢ç´¢ | æ”¯æ´çš„æ–¹æ³•ã€ç‰ˆæœ¬ |
| **åŸèªå®šç¾©** | æ ¸å¿ƒæŠ½è±¡ | Toolsã€Resourcesã€Prompts |

#### 2.1.2 å‚³è¼¸å±¤ï¼ˆTransport Layerï¼‰è©³è§£

å‚³è¼¸å±¤è² è²¬è¨Šæ¯çš„å¯¦éš›å‚³éï¼š

| å‚³è¼¸æ–¹å¼ | å”è­° | ç‰¹é» |
|----------|------|------|
| **STDIO** | æ¨™æº–è¼¸å…¥/è¼¸å‡º | æœ¬åœ°é€²ç¨‹é€šè¨Šã€ä½å»¶é² |
| **HTTP + SSE** | HTTP POST + Server-Sent Events | é ç«¯é€šè¨Šã€æ”¯æ´ä¸²æµ |

#### 2.1.3 å±¤èˆ‡å±¤ä¹‹é–“çš„äº’å‹•é—œä¿‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        è³‡æ–™å±¤ â†â†’ å‚³è¼¸å±¤ äº’å‹•                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  1. åºåˆ—åŒ–                                                       â”‚
â”‚     è³‡æ–™å±¤ç‰©ä»¶ â”€â”€JSON.stringifyâ”€â”€â†’ å‚³è¼¸å±¤å­—ä¸²                     â”‚
â”‚                                                                  â”‚
â”‚  2. å‚³è¼¸                                                         â”‚
â”‚     å‚³è¼¸å±¤å­—ä¸² â”€â”€STDIO/HTTPâ”€â”€â†’ å°ç«¯                               â”‚
â”‚                                                                  â”‚
â”‚  3. ååºåˆ—åŒ–                                                     â”‚
â”‚     å‚³è¼¸å±¤å­—ä¸² â”€â”€JSON.parseâ”€â”€â†’ è³‡æ–™å±¤ç‰©ä»¶                         â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2.2 è³‡æ–™å±¤å”è­°ï¼ˆData Layer Protocolï¼‰

#### 2.2.1 JSON-RPC 2.0 åŸºç¤

MCP ä½¿ç”¨ JSON-RPC 2.0 ä½œç‚ºè¨Šæ¯å”è­°ï¼ŒåŒ…å«ä¸‰ç¨®è¨Šæ¯é¡å‹ï¼š

**è«‹æ±‚ï¼ˆRequestï¼‰**ï¼š
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": {
      "path": "/path/to/file.txt"
    }
  }
}
```

**å›æ‡‰ï¼ˆResponseï¼‰**ï¼š
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "æª”æ¡ˆå…§å®¹..."
      }
    ]
  }
}
```

**é€šçŸ¥ï¼ˆNotificationï¼‰**ï¼š
```json
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}
```

#### 2.2.2 ç”Ÿå‘½é€±æœŸç®¡ç†ï¼ˆLifecycle Managementï¼‰

MCP é€£æ¥çš„ç”Ÿå‘½é€±æœŸåŒ…å«ä»¥ä¸‹éšæ®µï¼š

```mermaid
stateDiagram-v2
    [*] --> Initializing: é€£æ¥å»ºç«‹
    Initializing --> Initialized: initialize æˆåŠŸ
    Initialized --> Ready: initialized é€šçŸ¥
    Ready --> Ready: æ­£å¸¸æ“ä½œ
    Ready --> Closing: é—œé–‰è«‹æ±‚
    Closing --> [*]: é€£æ¥é—œé–‰
    
    Initializing --> [*]: åˆå§‹åŒ–å¤±æ•—
    Ready --> [*]: é€£æ¥éŒ¯èª¤
```

**åˆå§‹åŒ–æµç¨‹**ï¼š

```
Client                              Server
   â”‚                                   â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€ initialize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
   â”‚         {protocolVersion,         â”‚
   â”‚          capabilities,            â”‚
   â”‚          clientInfo}              â”‚
   â”‚                                   â”‚
   â”‚â†â”€â”€â”€â”€â”€â”€â”€ initialize result â”€â”€â”€â”€â”€â”€â”€â”€â”‚
   â”‚         {protocolVersion,         â”‚
   â”‚          capabilities,            â”‚
   â”‚          serverInfo}              â”‚
   â”‚                                   â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€ initialized â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
   â”‚         (notification)            â”‚
   â”‚                                   â”‚
   â”‚         === å°±ç·’ç‹€æ…‹ ===           â”‚
   â”‚                                   â”‚
```

**åˆå§‹åŒ–è«‹æ±‚ç¯„ä¾‹**ï¼š

```json
// Client â†’ Server
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-11-25",
    "capabilities": {
      "roots": {
        "listChanged": true
      },
      "sampling": {}
    },
    "clientInfo": {
      "name": "MyApp",
      "version": "1.0.0"
    }
  }
}

// Server â†’ Client
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-11-25",
    "capabilities": {
      "tools": {
        "listChanged": true
      },
      "resources": {
        "subscribe": true,
        "listChanged": true
      },
      "prompts": {
        "listChanged": true
      }
    },
    "serverInfo": {
      "name": "FileSystemServer",
      "version": "1.0.0"
    }
  }
}
```

#### 2.2.3 èƒ½åŠ›å”å•†æ©Ÿåˆ¶ï¼ˆCapability Negotiationï¼‰

èƒ½åŠ›å”å•†å…è¨± Client å’Œ Server å®£å‘Šå„è‡ªæ”¯æ´çš„åŠŸèƒ½ï¼š

**Client èƒ½åŠ›**ï¼š

| èƒ½åŠ› | èªªæ˜ |
|------|------|
| `roots` | æ”¯æ´å·¥ä½œå€æ ¹ç›®éŒ„åŠŸèƒ½ |
| `sampling` | æ”¯æ´ LLM å–æ¨£è«‹æ±‚ |
| `experimental` | å¯¦é©—æ€§åŠŸèƒ½æ”¯æ´ |

**Server èƒ½åŠ›**ï¼š

| èƒ½åŠ› | èªªæ˜ |
|------|------|
| `tools` | æä¾›å¯å‘¼å«çš„å·¥å…· |
| `resources` | æä¾›å¯è®€å–çš„è³‡æº |
| `prompts` | æä¾›å¯ç”¨çš„æç¤ºæ¨¡æ¿ |
| `logging` | æ”¯æ´æ—¥èªŒåŠŸèƒ½ |
| `experimental` | å¯¦é©—æ€§åŠŸèƒ½æ”¯æ´ |

---

### 2.3 MCP æ ¸å¿ƒåŸèªï¼ˆPrimitivesï¼‰

MCP å®šç¾©äº†å¤šç¨®åŸèªï¼ˆPrimitivesï¼‰ï¼Œä½œç‚º Client èˆ‡ Server ä¹‹é–“äº’å‹•çš„åŸºæœ¬å–®ä½ï¼š

```mermaid
graph TB
    subgraph "Server ç«¯åŸèª"
        Tools[Tools<br/>å¯åŸ·è¡Œå‡½æ•¸]
        Resources[Resources<br/>è³‡æ–™ä¾†æº]
        Prompts[Prompts<br/>æ¨¡æ¿]
    end
    
    subgraph "Client ç«¯åŸèª"
        Sampling[Sampling<br/>LLM è«‹æ±‚]
        Elicitation[Elicitation<br/>ç”¨æˆ¶äº’å‹•]
        Logging[Logging<br/>æ—¥èªŒ]
    end
    
    subgraph "é€šç”¨åŸèª"
        Tasks[Tasks<br/>æŒä¹…åŒ–ä»»å‹™]
    end
```

#### 2.3.1 Server ç«¯åŸèªï¼šTools

**Tools** æ˜¯ Server æš´éœ²çµ¦ Client çš„å¯åŸ·è¡Œå‡½æ•¸ï¼Œå…è¨± AI åŸ·è¡Œç‰¹å®šæ“ä½œã€‚

**Tool å®šç¾©çµæ§‹**ï¼š

```json
{
  "name": "read_file",
  "description": "è®€å–æŒ‡å®šè·¯å¾‘çš„æª”æ¡ˆå…§å®¹",
  "inputSchema": {
    "type": "object",
    "properties": {
      "path": {
        "type": "string",
        "description": "æª”æ¡ˆçš„å®Œæ•´è·¯å¾‘"
      }
    },
    "required": ["path"]
  }
}
```

**åˆ—å‡ºå·¥å…·ï¼ˆtools/listï¼‰**ï¼š

```json
// Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list"
}

// Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "read_file",
        "description": "è®€å–æª”æ¡ˆå…§å®¹",
        "inputSchema": { ... }
      },
      {
        "name": "write_file",
        "description": "å¯«å…¥æª”æ¡ˆå…§å®¹",
        "inputSchema": { ... }
      }
    ]
  }
}
```

**å‘¼å«å·¥å…·ï¼ˆtools/callï¼‰**ï¼š

```json
// Request
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": {
      "path": "/home/user/document.txt"
    }
  }
}

// Response
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "é€™æ˜¯æª”æ¡ˆçš„å…§å®¹..."
      }
    ],
    "isError": false
  }
}
```

#### 2.3.2 Server ç«¯åŸèªï¼šResources

**Resources** ä»£è¡¨ Server å¯ä»¥æä¾›çš„è³‡æ–™ä¾†æºï¼Œå¯ä»¥æ˜¯æª”æ¡ˆã€è³‡æ–™åº«è¨˜éŒ„ã€API å›æ‡‰ç­‰ã€‚

**Resource å®šç¾©çµæ§‹**ï¼š

```json
{
  "uri": "file:///path/to/document.txt",
  "name": "document.txt",
  "description": "å°ˆæ¡ˆèªªæ˜æ–‡ä»¶",
  "mimeType": "text/plain"
}
```

**åˆ—å‡ºè³‡æºï¼ˆresources/listï¼‰**ï¼š

```json
// Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list"
}

// Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///docs/readme.md",
        "name": "README",
        "mimeType": "text/markdown"
      },
      {
        "uri": "db://users/schema",
        "name": "Users Schema",
        "mimeType": "application/json"
      }
    ]
  }
}
```

**è®€å–è³‡æºï¼ˆresources/readï¼‰**ï¼š

```json
// Request
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///docs/readme.md"
  }
}

// Response
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///docs/readme.md",
        "mimeType": "text/markdown",
        "text": "# README\n\né€™æ˜¯å°ˆæ¡ˆèªªæ˜..."
      }
    ]
  }
}
```

#### 2.3.3 Server ç«¯åŸèªï¼šPrompts

**Prompts** æ˜¯é å®šç¾©çš„å¯é‡ç”¨æ¨¡æ¿ï¼Œå¯ä»¥åŒ…å«å‹•æ…‹åƒæ•¸ã€‚

**Prompt å®šç¾©çµæ§‹**ï¼š

```json
{
  "name": "code_review",
  "description": "ç¨‹å¼ç¢¼å¯©æŸ¥æ¨¡æ¿",
  "arguments": [
    {
      "name": "language",
      "description": "ç¨‹å¼èªè¨€",
      "required": true
    },
    {
      "name": "code",
      "description": "è¦å¯©æŸ¥çš„ç¨‹å¼ç¢¼",
      "required": true
    }
  ]
}
```

**å–å¾—æç¤ºï¼ˆprompts/getï¼‰**ï¼š

```json
// Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "prompts/get",
  "params": {
    "name": "code_review",
    "arguments": {
      "language": "Python",
      "code": "def hello(): print('Hello')"
    }
  }
}

// Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "description": "Python ç¨‹å¼ç¢¼å¯©æŸ¥",
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "è«‹å¯©æŸ¥ä»¥ä¸‹ Python ç¨‹å¼ç¢¼ï¼š\n\ndef hello(): print('Hello')\n\nè«‹æä¾›æ”¹é€²å»ºè­°ã€‚"
        }
      }
    ]
  }
}
```

#### 2.3.4 Client ç«¯åŸèªï¼šSampling

**Sampling** å…è¨± Server è«‹æ±‚ Client é€²è¡Œ LLM å®Œæˆæ“ä½œã€‚

```json
// Server â†’ Client Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sampling/createMessage",
  "params": {
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "è«‹æ‘˜è¦ä»¥ä¸‹å…§å®¹..."
        }
      }
    ],
    "maxTokens": 500
  }
}

// Client â†’ Server Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "role": "assistant",
    "content": {
      "type": "text",
      "text": "é€™æ˜¯æ‘˜è¦å…§å®¹..."
    },
    "model": "claude-3-sonnet",
    "stopReason": "end_turn"
  }
}
```

#### 2.3.5 Client ç«¯åŸèªï¼šElicitation

**Elicitation** å…è¨± Server è«‹æ±‚ä½¿ç”¨è€…è¼¸å…¥æˆ–ç¢ºèªã€‚

```json
// Server â†’ Client Request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "elicitation/create",
  "params": {
    "message": "æ˜¯å¦ç¢ºèªåˆªé™¤æ­¤æª”æ¡ˆï¼Ÿ",
    "requestedSchema": {
      "type": "object",
      "properties": {
        "confirm": {
          "type": "boolean",
          "description": "ç¢ºèªåˆªé™¤"
        }
      },
      "required": ["confirm"]
    }
  }
}
```

#### 2.3.6 Client ç«¯åŸèªï¼šLogging

**Logging** å…è¨± Server ç™¼é€æ—¥èªŒè¨Šæ¯çµ¦ Clientã€‚

```json
// Server â†’ Client Notification
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "info",
    "logger": "FileSystem",
    "data": "æª”æ¡ˆè®€å–æˆåŠŸ: /path/to/file.txt"
  }
}
```

æ—¥èªŒç´šåˆ¥ï¼š

| ç´šåˆ¥ | èªªæ˜ |
|------|------|
| `debug` | é™¤éŒ¯è³‡è¨Š |
| `info` | ä¸€èˆ¬è³‡è¨Š |
| `notice` | é‡è¦é€šçŸ¥ |
| `warning` | è­¦å‘Šè¨Šæ¯ |
| `error` | éŒ¯èª¤è¨Šæ¯ |
| `critical` | åš´é‡éŒ¯èª¤ |
| `alert` | éœ€è¦ç«‹å³è™•ç† |
| `emergency` | ç³»çµ±ä¸å¯ç”¨ |

#### 2.3.7 é€šç”¨åŸèªï¼šTasksï¼ˆå¯¦é©—æ€§ï¼‰

**Tasks** æ˜¯å¯¦é©—æ€§åŠŸèƒ½ï¼Œç”¨æ–¼åŒ…è£é•·æ™‚é–“é‹è¡Œçš„æ“ä½œã€‚

```json
// å•Ÿå‹•ä»»å‹™
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "long_running_task",
    "arguments": { ... }
  }
}

// å›æ‡‰åŒ…å«ä»»å‹™ ID
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "ä»»å‹™å·²å•Ÿå‹•"
      }
    ],
    "taskId": "task-123"
  }
}

// æŸ¥è©¢ä»»å‹™ç‹€æ…‹
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tasks/get",
  "params": {
    "taskId": "task-123"
  }
}
```

---

### 2.4 é€šçŸ¥æ©Ÿåˆ¶ï¼ˆNotificationsï¼‰

MCP çš„é€šçŸ¥æ©Ÿåˆ¶å…è¨± Server å’Œ Client ä¹‹é–“é€²è¡ŒéåŒæ­¥çš„å–®å‘è¨Šæ¯å‚³éã€‚

#### 2.4.1 å³æ™‚æ›´æ–°çš„è¨­è¨ˆ

é€šçŸ¥æ˜¯ç„¡éœ€å›æ‡‰çš„è¨Šæ¯ï¼Œç”¨æ–¼äº‹ä»¶é€šçŸ¥ï¼š

```mermaid
sequenceDiagram
    participant C as Client
    participant S as Server
    
    Note over C,S: æ­£å¸¸æ“ä½œä¸­
    S->>C: notifications/tools/list_changed
    Note over C: Client æ›´æ–°å·¥å…·åˆ—è¡¨
    C->>S: tools/list
    S->>C: tools/list response
```

#### 2.4.2 ä¸»è¦é€šçŸ¥é¡å‹

| é€šçŸ¥é¡å‹ | æ–¹å‘ | èªªæ˜ |
|----------|------|------|
| `notifications/initialized` | Client â†’ Server | Client å®Œæˆåˆå§‹åŒ– |
| `notifications/progress` | é›™å‘ | é€²åº¦æ›´æ–° |
| `notifications/message` | Server â†’ Client | æ—¥èªŒè¨Šæ¯ |
| `notifications/tools/list_changed` | Server â†’ Client | å·¥å…·åˆ—è¡¨è®Šæ›´ |
| `notifications/resources/list_changed` | Server â†’ Client | è³‡æºåˆ—è¡¨è®Šæ›´ |
| `notifications/resources/updated` | Server â†’ Client | è³‡æºå…§å®¹æ›´æ–° |
| `notifications/prompts/list_changed` | Server â†’ Client | æç¤ºåˆ—è¡¨è®Šæ›´ |

#### 2.4.3 é€²åº¦é€šçŸ¥ç¯„ä¾‹

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/progress",
  "params": {
    "progressToken": "operation-123",
    "progress": 50,
    "total": 100,
    "message": "è™•ç†ä¸­... 50%"
  }
}
```

> **ğŸ’¡ å¯¦å‹™å»ºè­°**ï¼š
> - å–„ç”¨é€šçŸ¥æ©Ÿåˆ¶å¯¦ç¾å³æ™‚æ›´æ–°ï¼Œæå‡ä½¿ç”¨è€…é«”é©—
> - é¿å…éæ–¼é »ç¹çš„é€šçŸ¥ï¼Œå¯èƒ½é€ æˆæ•ˆèƒ½å•é¡Œ
> - é‡è¦çš„ç‹€æ…‹è®Šæ›´æ‰ç™¼é€é€šçŸ¥

---

## ç¬¬ä¸‰ç« ï¼šå‚³è¼¸å±¤æ·±åº¦è§£æ

### 3.1 STDIO Transport

#### 3.1.1 é©ç”¨å ´æ™¯ï¼šæœ¬åœ°é€²ç¨‹é€šè¨Š

STDIO Transport é€éæ¨™æº–è¼¸å…¥/è¼¸å‡ºé€²è¡Œé€šè¨Šï¼Œé©ç”¨æ–¼ï¼š

- âœ… æœ¬åœ°å·¥å…·æ•´åˆ
- âœ… é–‹ç™¼æ¸¬è©¦ç’°å¢ƒ
- âœ… å–®ä¸€ä½¿ç”¨è€…å ´æ™¯
- âœ… éœ€è¦å­˜å–æœ¬åœ°è³‡æº
- âŒ ä¸é©åˆå¤šä½¿ç”¨è€…å…±äº«
- âŒ ä¸é©åˆé ç«¯å­˜å–

```mermaid
graph LR
    Host[MCP Host] -->|stdout| Server[MCP Server]
    Server -->|stdin| Host
    
    subgraph "åŒä¸€å°æ©Ÿå™¨"
        Host
        Server
    end
```

#### 3.1.2 é…ç½®æ–¹å¼èˆ‡ç¯„ä¾‹

**Claude Desktop é…ç½®ï¼ˆclaude_desktop_config.jsonï¼‰**ï¼š

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "node",
      "args": ["/path/to/filesystem-server/index.js"],
      "env": {
        "NODE_ENV": "production"
      }
    },
    "database": {
      "command": "python",
      "args": ["-m", "database_server"],
      "env": {
        "DB_CONNECTION": "postgresql://localhost/mydb"
      }
    }
  }
}
```

**é…ç½®èªªæ˜**ï¼š

| æ¬„ä½ | èªªæ˜ | ç¯„ä¾‹ |
|------|------|------|
| `command` | åŸ·è¡Œå‘½ä»¤ | `node`ã€`python`ã€`npx` |
| `args` | å‘½ä»¤åƒæ•¸ | è…³æœ¬è·¯å¾‘ã€æ¨¡çµ„åç¨± |
| `env` | ç’°å¢ƒè®Šæ•¸ | è³‡æ–™åº«é€£ç·šå­—ä¸²ç­‰ |

#### 3.1.3 æ•ˆèƒ½ç‰¹æ€§èˆ‡é™åˆ¶

| ç‰¹æ€§ | èªªæ˜ |
|------|------|
| **å»¶é²** | æ¥µä½ï¼ˆæ¯«ç§’ç´šï¼‰ |
| **ååé‡** | å—é™æ–¼ pipe buffer size |
| **ç©©å®šæ€§** | ä¾è³´é€²ç¨‹ç®¡ç† |
| **é™¤éŒ¯** | éœ€è¦é¡å¤–æ—¥èªŒæ©Ÿåˆ¶ |

**é™åˆ¶**ï¼š
- ç„¡æ³•è·¨æ©Ÿå™¨é€šè¨Š
- é€²ç¨‹é‡å•Ÿæœƒä¸­æ–·é€£æ¥
- é™¤éŒ¯è¼ƒç‚ºå›°é›£

---

### 3.2 Streamable HTTP Transport

#### 3.2.1 é©ç”¨å ´æ™¯ï¼šé ç«¯ä¼ºæœå™¨é€šè¨Š

HTTP Transport é©ç”¨æ–¼éœ€è¦é ç«¯å­˜å–çš„å ´æ™¯ï¼š

- âœ… åœ˜éšŠå…±äº«æœå‹™
- âœ… é›²ç«¯éƒ¨ç½²
- âœ… éœ€è¦èªè­‰æˆæ¬Š
- âœ… è² è¼‰å‡è¡¡
- âŒ å»¶é²è¼ƒé«˜
- âŒ éœ€è¦ç¶²è·¯é€£æ¥

```mermaid
graph LR
    subgraph "ç”¨æˆ¶ç«¯"
        Client[MCP Client]
    end
    
    subgraph "ä¼ºæœå™¨ç«¯"
        Server[MCP Server]
        DB[(è³‡æ–™åº«)]
        API[å¤–éƒ¨ API]
    end
    
    Client -->|HTTP POST| Server
    Server -->|SSE| Client
    Server --> DB
    Server --> API
```

#### 3.2.2 HTTP POST èˆ‡ Server-Sent Events

**è«‹æ±‚æµç¨‹**ï¼š

1. Client ç™¼é€ HTTP POST è«‹æ±‚
2. Server å¯ä»¥å›å‚³ï¼š
   - ç›´æ¥ JSON å›æ‡‰
   - SSE ä¸²æµï¼ˆç”¨æ–¼é•·æ™‚é–“æ“ä½œï¼‰

**HTTP POST ç¯„ä¾‹**ï¼š

```http
POST /mcp/v1 HTTP/1.1
Host: mcp-server.example.com
Content-Type: application/json
Authorization: Bearer <token>

{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list"
}
```

**SSE å›æ‡‰ç¯„ä¾‹**ï¼š

```http
HTTP/1.1 200 OK
Content-Type: text/event-stream

event: message
data: {"jsonrpc":"2.0","id":1,"result":{"tools":[...]}}

event: message
data: {"jsonrpc":"2.0","method":"notifications/progress","params":{...}}
```

#### 3.2.3 èªè­‰æ©Ÿåˆ¶

**Bearer Token**ï¼š

```http
POST /mcp/v1 HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

**API Keys**ï¼š

```http
POST /mcp/v1 HTTP/1.1
X-API-Key: sk-1234567890abcdef
```

**OAuth 2.0 æµç¨‹**ï¼š

```mermaid
sequenceDiagram
    participant U as ä½¿ç”¨è€…
    participant C as MCP Client
    participant A as æˆæ¬Šä¼ºæœå™¨
    participant S as MCP Server
    
    U->>C: è«‹æ±‚é€£æ¥ MCP Server
    C->>A: é‡å°å‘åˆ°æˆæ¬Šé é¢
    U->>A: æˆæ¬ŠåŒæ„
    A->>C: å›å‚³æˆæ¬Šç¢¼
    C->>A: æˆæ¬Šç¢¼æ›å– Token
    A->>C: å›å‚³ Access Token
    C->>S: è«‹æ±‚ + Access Token
    S->>C: å›æ‡‰è³‡æ–™
```

#### 3.2.4 å®‰å…¨æ€§æœ€ä½³å¯¦è¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HTTP Transport å®‰å…¨æ¸…å–®                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  âœ“ ä¸€å¾‹ä½¿ç”¨ HTTPS                                                â”‚
â”‚  âœ“ å¯¦æ–½é©ç•¶çš„èªè­‰æ©Ÿåˆ¶                                            â”‚
â”‚  âœ“ è¨­å®šåˆç†çš„ Token éæœŸæ™‚é–“                                     â”‚
â”‚  âœ“ å¯¦æ–½é€Ÿç‡é™åˆ¶                                                  â”‚
â”‚  âœ“ é©—è­‰è¼¸å…¥åƒæ•¸                                                  â”‚
â”‚  âœ“ è¨˜éŒ„å­˜å–æ—¥èªŒ                                                  â”‚
â”‚  âœ“ ä½¿ç”¨ CORS é™åˆ¶ä¾†æº                                            â”‚
â”‚  âœ“ å®šæœŸè¼ªæ›æ†‘è­‰                                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**CORS é…ç½®ç¯„ä¾‹**ï¼š

```javascript
// Express.js ç¯„ä¾‹
app.use(cors({
  origin: ['https://claude.ai', 'https://your-app.com'],
  methods: ['POST'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
```

> **âš ï¸ å®‰å…¨è­¦å‘Š**ï¼š
> - æ°¸é ä¸è¦åœ¨ç¨‹å¼ç¢¼ä¸­ç¡¬ç·¨ç¢¼èªè­‰æ†‘è­‰
> - ä½¿ç”¨ç’°å¢ƒè®Šæ•¸æˆ–å®‰å…¨çš„å¯†é‘°ç®¡ç†æœå‹™
> - å®šæœŸå¯©è¨ˆå­˜å–æ—¥èªŒ

---

## ç« ç¯€å°çµ

æœ¬ç« ç¯€æ¶µè“‹äº† MCP çš„åŸºç¤æ¦‚å¿µèˆ‡æŠ€è¡“æ¶æ§‹ï¼š

### é‡é»å›é¡§

| ç« ç¯€ | é—œéµæ¦‚å¿µ |
|------|----------|
| **ç¬¬ä¸€ç« ** | MCP å®šç¾©ã€åƒ¹å€¼ã€æ¶æ§‹è§’è‰² |
| **ç¬¬äºŒç« ** | åˆ†å±¤æ¶æ§‹ã€JSON-RPCã€åŸèª |
| **ç¬¬ä¸‰ç« ** | STDIO vs HTTP Transport |

### ä¸‹ä¸€æ­¥

æ¥ä¸‹ä¾†çš„ç« ç¯€å°‡é€²å…¥å¯¦æˆ°é–‹ç™¼ï¼š
- ç¬¬å››ç« ï¼šé–‹ç™¼ç’°å¢ƒè¨­ç½®èˆ‡å¯¦ä½œ
- ç¬¬äº”ç« ï¼šå®Œæ•´ç¯„ä¾‹å°ˆæ¡ˆ
- ç¬¬å…­ç« ï¼šæœ€ä½³å¯¦è¸

---

## ç¬¬å››ç« ï¼šå¯¦æˆ°é–‹ç™¼æŒ‡å—

### 4.1 é–‹ç™¼ç’°å¢ƒè¨­ç½®

#### 4.1.1 SDK é¸æ“‡èˆ‡å®‰è£

MCP æä¾›å¤šç¨®èªè¨€çš„å®˜æ–¹ SDKï¼š

| SDK | èªè¨€ | å¥—ä»¶åç¨± | æˆç†Ÿåº¦ |
|-----|------|---------|--------|
| **Python SDK** | Python 3.10+ | `mcp` | ç©©å®š |
| **TypeScript SDK** | Node.js 18+ | `@modelcontextprotocol/sdk` | ç©©å®š |
| **Java SDK** | Java 17+ | ç¤¾ç¾¤ç¶­è­· | é–‹ç™¼ä¸­ |

**Python SDK å®‰è£**ï¼š

```bash
# ä½¿ç”¨ pip å®‰è£
pip install mcp

# æˆ–ä½¿ç”¨ uvï¼ˆæ¨è–¦ï¼‰
uv add mcp

# å®‰è£é–‹ç™¼å·¥å…·
pip install mcp[cli]
```

**TypeScript SDK å®‰è£**ï¼š

```bash
# ä½¿ç”¨ npm
npm install @modelcontextprotocol/sdk

# æˆ–ä½¿ç”¨ pnpm
pnpm add @modelcontextprotocol/sdk

# å®‰è£ CLI å·¥å…·
npm install -g @modelcontextprotocol/inspector
```

#### 4.1.2 é–‹ç™¼å·¥å…·ä»‹ç´¹ï¼ˆMCP Inspectorï¼‰

**MCP Inspector** æ˜¯å®˜æ–¹æä¾›çš„é™¤éŒ¯å·¥å…·ï¼Œå¯ç”¨æ–¼æ¸¬è©¦ MCP Serverï¼š

```bash
# å•Ÿå‹• Inspector
npx @modelcontextprotocol/inspector

# é€£æ¥åˆ°æœ¬åœ° Server
npx @modelcontextprotocol/inspector node /path/to/server.js
```

**Inspector åŠŸèƒ½**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCP Inspector åŠŸèƒ½                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  ğŸ“‹ å·¥å…·åˆ—è¡¨    æª¢è¦– Server æä¾›çš„æ‰€æœ‰å·¥å…·                        â”‚
â”‚  ğŸ“ è³‡æºç€è¦½    ç€è¦½å¯ç”¨è³‡æºä¸¦è®€å–å…§å®¹                            â”‚
â”‚  ğŸ’¬ æç¤ºæ¸¬è©¦    æ¸¬è©¦ Prompts ä¸¦æŸ¥çœ‹çµæœ                          â”‚
â”‚  ğŸ”§ äº’å‹•æ¸¬è©¦    æ‰‹å‹•å‘¼å«å·¥å…·ä¸¦æª¢è¦–å›æ‡‰                            â”‚
â”‚  ğŸ“Š æ—¥èªŒç›£æ§    å³æ™‚æŸ¥çœ‹ Server æ—¥èªŒ                             â”‚
â”‚  ğŸ” å”è­°æª¢æŸ¥    æª¢è¦–åŸå§‹ JSON-RPC è¨Šæ¯                           â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 4.1.3 å°ˆæ¡ˆçµæ§‹å»ºè­°

**Python å°ˆæ¡ˆçµæ§‹**ï¼š

```
my-mcp-server/
â”œâ”€â”€ pyproject.toml          # å°ˆæ¡ˆé…ç½®
â”œâ”€â”€ README.md               # èªªæ˜æ–‡ä»¶
â”œâ”€â”€ src/
â”‚   â””â”€â”€ my_mcp_server/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ __main__.py     # å…¥å£é»
â”‚       â”œâ”€â”€ server.py       # Server ä¸»ç¨‹å¼
â”‚       â”œâ”€â”€ tools/          # å·¥å…·å®šç¾©
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ file_tools.py
â”‚       â”‚   â””â”€â”€ db_tools.py
â”‚       â”œâ”€â”€ resources/      # è³‡æºè™•ç†
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â””â”€â”€ handlers.py
â”‚       â””â”€â”€ utils/          # å·¥å…·å‡½æ•¸
â”‚           â”œâ”€â”€ __init__.py
â”‚           â””â”€â”€ helpers.py
â”œâ”€â”€ tests/                  # æ¸¬è©¦æª”æ¡ˆ
â”‚   â”œâ”€â”€ test_tools.py
â”‚   â””â”€â”€ test_resources.py
â””â”€â”€ config/                 # é…ç½®æª”æ¡ˆ
    â””â”€â”€ settings.yaml
```

**TypeScript å°ˆæ¡ˆçµæ§‹**ï¼š

```
my-mcp-server/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts           # å…¥å£é»
â”‚   â”œâ”€â”€ server.ts          # Server ä¸»ç¨‹å¼
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ fileTools.ts
â”‚   â”‚   â””â”€â”€ dbTools.ts
â”‚   â”œâ”€â”€ resources/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ handlers.ts
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ index.ts
â”‚       â””â”€â”€ helpers.ts
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ tools.test.ts
â”‚   â””â”€â”€ resources.test.ts
â””â”€â”€ dist/                  # ç·¨è­¯è¼¸å‡º
```

---

### 4.2 é–‹ç™¼ MCP Server

#### 4.2.1 åŸºç¤ç¯„ä¾‹ï¼šæœ€ç°¡å–®çš„ MCP Server

**Python ç‰ˆæœ¬**ï¼š

```python
#!/usr/bin/env python3
"""
æœ€ç°¡å–®çš„ MCP Server ç¯„ä¾‹
"""

from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# å»ºç«‹ Server å¯¦ä¾‹
server = Server("simple-server")

# å®šç¾©å·¥å…·åˆ—è¡¨
@server.list_tools()
async def list_tools() -> list[Tool]:
    """å›å‚³å¯ç”¨å·¥å…·åˆ—è¡¨"""
    return [
        Tool(
            name="hello",
            description="å›å‚³å•å€™è¨Šæ¯",
            inputSchema={
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "è¦å•å€™çš„åå­—"
                    }
                },
                "required": ["name"]
            }
        )
    ]

# å¯¦ä½œå·¥å…·è™•ç†
@server.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    """è™•ç†å·¥å…·å‘¼å«"""
    if name == "hello":
        user_name = arguments.get("name", "World")
        return [TextContent(type="text", text=f"Hello, {user_name}!")]
    
    raise ValueError(f"Unknown tool: {name}")

# ä¸»ç¨‹å¼å…¥å£
async def main():
    """å•Ÿå‹• Server"""
    async with stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            server.create_initialization_options()
        )

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

**TypeScript ç‰ˆæœ¬**ï¼š

```typescript
#!/usr/bin/env node
/**
 * æœ€ç°¡å–®çš„ MCP Server ç¯„ä¾‹
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

// å»ºç«‹ Server å¯¦ä¾‹
const server = new Server(
  {
    name: "simple-server",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// è™•ç†å·¥å…·åˆ—è¡¨è«‹æ±‚
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "hello",
        description: "å›å‚³å•å€™è¨Šæ¯",
        inputSchema: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "è¦å•å€™çš„åå­—",
            },
          },
          required: ["name"],
        },
      },
    ],
  };
});

// è™•ç†å·¥å…·å‘¼å«è«‹æ±‚
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "hello") {
    const userName = (args as { name: string }).name || "World";
    return {
      content: [
        {
          type: "text",
          text: `Hello, ${userName}!`,
        },
      ],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
});

// å•Ÿå‹• Server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Simple MCP Server running on stdio");
}

main().catch(console.error);
```

#### 4.2.2 è¨»å†Šèˆ‡åˆå§‹åŒ–æµç¨‹

```mermaid
sequenceDiagram
    participant C as Client
    participant S as Server
    
    Note over S: Server å•Ÿå‹•
    S->>S: è¼‰å…¥è¨­å®š
    S->>S: è¨»å†Š Handlers
    
    Note over C: Client é€£æ¥
    C->>S: initialize
    S->>S: é©—è­‰ç‰ˆæœ¬
    S->>S: è¨­å®šèƒ½åŠ›
    S->>C: initialize response
    C->>S: initialized (notification)
    
    Note over C,S: å°±ç·’ï¼Œå¯ä»¥è™•ç†è«‹æ±‚
```

**åˆå§‹åŒ–é¸é …é…ç½®**ï¼š

```java
// Java - è‡ªè¨‚åˆå§‹åŒ–é¸é …
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.spec.ServerCapabilities;

public class MyMcpServer {
    public static void main(String[] args) {
        // è¨­å®š Server èƒ½åŠ›
        ServerCapabilities capabilities = ServerCapabilities.builder()
            .tools(ServerCapabilities.ToolCapabilities.builder()
                .listChanged(true)
                .build())
            .resources(ServerCapabilities.ResourceCapabilities.builder()
                .listChanged(true)
                .subscribe(true)
                .build())
            .build();
        
        // å»ºç«‹ Server é…ç½®
        McpServerOptions options = McpServerOptions.builder()
            .serverName("my-server")
            .serverVersion("1.0.0")
            .capabilities(capabilities)
            .build();
        
        McpServer server = new McpServer(options);
    }
}
```

#### 4.2.3 é€²éšç¯„ä¾‹ï¼šå¯¦ä½œ Toolsï¼ˆè³‡æ–™åº«æŸ¥è©¢ï¼‰

```java
/**
 * è³‡æ–™åº«æŸ¥è©¢å·¥å…·ç¯„ä¾‹
 * DatabaseMcpServer.java
 */
package com.example.mcp;

import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.spec.*;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import java.sql.*;
import java.util.*;
import java.util.concurrent.CompletableFuture;

public class DatabaseMcpServer {
    
    private final McpServer server;
    private final HikariDataSource dataSource;
    
    public DatabaseMcpServer() {
        // åˆå§‹åŒ–è³‡æ–™åº«é€£æ¥æ± 
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername("user");
        config.setPassword("password");
        config.setMinimumIdle(5);
        config.setMaximumPoolSize(20);
        this.dataSource = new HikariDataSource(config);
        
        // å»ºç«‹ MCP Server
        McpServerOptions options = McpServerOptions.builder()
            .serverName("database-server")
            .serverVersion("1.0.0")
            .capabilities(ServerCapabilities.builder()
                .tools(ServerCapabilities.ToolCapabilities.builder()
                    .listChanged(true)
                    .build())
                .build())
            .build();
        
        this.server = new McpServer(options);
        
        // è¨»å†Šå·¥å…·
        registerTools();
    }
    
    private void registerTools() {
        // è¨»å†ŠæŸ¥è©¢å·¥å…·
        server.addTool(Tool.builder()
            .name("query_database")
            .description("åŸ·è¡Œ SQL æŸ¥è©¢ï¼ˆåƒ…æ”¯æ´ SELECTï¼‰")
            .inputSchema(Map.of(
                "type", "object",
                "properties", Map.of(
                    "query", Map.of(
                        "type", "string",
                        "description", "SQL SELECT æŸ¥è©¢èªå¥"
                    ),
                    "limit", Map.of(
                        "type", "integer",
                        "description", "çµæœç­†æ•¸é™åˆ¶",
                        "default", 100
                    )
                ),
                "required", List.of("query")
            ))
            .build());
        
        // è¨»å†Šåˆ—è¡¨è³‡æ–™è¡¨å·¥å…·
        server.addTool(Tool.builder()
            .name("list_tables")
            .description("åˆ—å‡ºè³‡æ–™åº«ä¸­çš„æ‰€æœ‰è³‡æ–™è¡¨")
            .inputSchema(Map.of(
                "type", "object",
                "properties", Map.of()
            ))
            .build());
        
        // è¨»å†Šæè¿°è³‡æ–™è¡¨å·¥å…·
        server.addTool(Tool.builder()
            .name("describe_table")
            .description("å–å¾—è³‡æ–™è¡¨çš„ schema è³‡è¨Š")
            .inputSchema(Map.of(
                "type", "object",
                "properties", Map.of(
                    "table_name", Map.of(
                        "type", "string",
                        "description", "è³‡æ–™è¡¨åç¨±"
                    )
                ),
                "required", List.of("table_name")
            ))
            .build());
        
        // è¨­å®šå·¥å…·è™•ç†å™¨
        server.setToolHandler(this::handleToolCall);
    }
    
    private CompletableFuture<CallToolResult> handleToolCall(CallToolRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            String toolName = request.getParams().getName();
            Map<String, Object> arguments = request.getParams().getArguments();
            
            try {
                return switch (toolName) {
                    case "query_database" -> handleQuery(arguments);
                    case "list_tables" -> handleListTables();
                    case "describe_table" -> handleDescribeTable(arguments);
                    default -> CallToolResult.error("Unknown tool: " + toolName);
                };
            } catch (Exception e) {
                return CallToolResult.error("éŒ¯èª¤ï¼š" + e.getMessage());
            }
        });
    }
    
    private CallToolResult handleQuery(Map<String, Object> arguments) throws SQLException {
        String query = (String) arguments.get("query");
        int limit = (int) arguments.getOrDefault("limit", 100);
        
        // å®‰å…¨æª¢æŸ¥ï¼šåƒ…å…è¨± SELECT
        if (!query.trim().toUpperCase().startsWith("SELECT")) {
            return CallToolResult.text("éŒ¯èª¤ï¼šåƒ…æ”¯æ´ SELECT æŸ¥è©¢");
        }
        
        // åŠ å…¥ LIMIT é™åˆ¶
        if (!query.toUpperCase().contains("LIMIT")) {
            query = query + " LIMIT " + limit;
        }
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            
            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            // å»ºç«‹è¡¨é ­
            StringBuilder result = new StringBuilder();
            result.append("| ");
            for (int i = 1; i <= columnCount; i++) {
                result.append(metaData.getColumnName(i)).append(" | ");
            }
            result.append("\n| ");
            for (int i = 1; i <= columnCount; i++) {
                result.append("--- | ");
            }
            result.append("\n");
            
            // å»ºç«‹è³‡æ–™åˆ—
            int rowCount = 0;
            while (rs.next()) {
                result.append("| ");
                for (int i = 1; i <= columnCount; i++) {
                    result.append(rs.getString(i)).append(" | ");
                }
                result.append("\n");
                rowCount++;
            }
            
            if (rowCount == 0) {
                return CallToolResult.text("æŸ¥è©¢ç„¡çµæœ");
            }
            
            return CallToolResult.text(result.toString());
        }
    }
    
    private CallToolResult handleListTables() throws SQLException {
        String query = """
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public'
            ORDER BY table_name
            """;
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            
            List<String> tables = new ArrayList<>();
            while (rs.next()) {
                tables.add(rs.getString("table_name"));
            }
            
            StringBuilder result = new StringBuilder("è³‡æ–™è¡¨åˆ—è¡¨ï¼š\n");
            for (String table : tables) {
                result.append("- ").append(table).append("\n");
            }
            
            return CallToolResult.text(result.toString());
        }
    }
    
    private CallToolResult handleDescribeTable(Map<String, Object> arguments) throws SQLException {
        String tableName = (String) arguments.get("table_name");
        
        String query = """
            SELECT column_name, data_type, is_nullable, column_default
            FROM information_schema.columns
            WHERE table_name = ?
            ORDER BY ordinal_position
            """;
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {
            
            stmt.setString(1, tableName);
            
            try (ResultSet rs = stmt.executeQuery()) {
                StringBuilder result = new StringBuilder();
                result.append("è³‡æ–™è¡¨ ").append(tableName).append(" çµæ§‹ï¼š\n\n");
                result.append("| æ¬„ä½åç¨± | è³‡æ–™å‹åˆ¥ | å¯ç‚ºç©º | é è¨­å€¼ |\n");
                result.append("| --- | --- | --- | --- |\n");
                
                boolean hasRows = false;
                while (rs.next()) {
                    hasRows = true;
                    result.append("| ")
                        .append(rs.getString("column_name")).append(" | ")
                        .append(rs.getString("data_type")).append(" | ")
                        .append(rs.getString("is_nullable")).append(" | ")
                        .append(rs.getString("column_default") != null ? 
                                rs.getString("column_default") : "-")
                        .append(" |\n");
                }
                
                if (!hasRows) {
                    return CallToolResult.text("è³‡æ–™è¡¨ " + tableName + " ä¸å­˜åœ¨");
                }
                
                return CallToolResult.text(result.toString());
            }
        }
    }
    
    public void start() throws Exception {
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport);
        System.err.println("Database MCP Server running on stdio");
    }
    
    public void shutdown() {
        dataSource.close();
    }
    
    public static void main(String[] args) throws Exception {
        DatabaseMcpServer server = new DatabaseMcpServer();
        Runtime.getRuntime().addShutdownHook(new Thread(server::shutdown));
        server.start();
    }
}
```

#### 4.2.4 é€²éšç¯„ä¾‹ï¼šå¯¦ä½œ Resourcesï¼ˆæª”æ¡ˆç³»çµ±ï¼‰

```java
/**
 * æª”æ¡ˆç³»çµ±è³‡æºç¯„ä¾‹
 * FilesystemMcpServer.java
 */
package com.example.mcp;

import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.spec.*;

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.concurrent.CompletableFuture;

public class FilesystemMcpServer {
    
    private final McpServer server;
    private final Path allowedRoot;
    
    public FilesystemMcpServer(String rootPath) {
        this.allowedRoot = Paths.get(rootPath).toAbsolutePath().normalize();
        
        // å»ºç«‹ MCP Server
        McpServerOptions options = McpServerOptions.builder()
            .serverName("filesystem-server")
            .serverVersion("1.0.0")
            .capabilities(ServerCapabilities.builder()
                .resources(ServerCapabilities.ResourceCapabilities.builder()
                    .listChanged(true)
                    .subscribe(true)
                    .build())
                .build())
            .build();
        
        this.server = new McpServer(options);
        
        // è¨»å†Šè³‡æºè™•ç†å™¨
        registerHandlers();
    }
    
    /**
     * æª¢æŸ¥è·¯å¾‘æ˜¯å¦åœ¨å…è¨±ç¯„åœå…§
     */
    private boolean isSafePath(Path path) {
        try {
            Path resolved = path.toAbsolutePath().normalize();
            return resolved.startsWith(allowedRoot);
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * çŒœæ¸¬ MIME é¡å‹
     */
    private String guessMimeType(Path path) {
        try {
            String contentType = Files.probeContentType(path);
            return contentType != null ? contentType : "application/octet-stream";
        } catch (IOException e) {
            return "application/octet-stream";
        }
    }
    
    private void registerHandlers() {
        // è¨»å†Šè³‡æºåˆ—è¡¨è™•ç†å™¨
        server.setResourceListHandler(request -> CompletableFuture.supplyAsync(() -> {
            List<Resource> resources = new ArrayList<>();
            
            try {
                Files.walkFileTree(allowedRoot, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                        Path relativePath = allowedRoot.relativize(file);
                        String mimeType = guessMimeType(file);
                        
                        resources.add(Resource.builder()
                            .uri("file:///" + relativePath.toString().replace("\\", "/"))
                            .name(file.getFileName().toString())
                            .description("æª”æ¡ˆï¼š" + relativePath)
                            .mimeType(mimeType)
                            .build());
                        
                        return FileVisitResult.CONTINUE;
                    }
                });
            } catch (IOException e) {
                System.err.println("æƒæç›®éŒ„éŒ¯èª¤ï¼š" + e.getMessage());
            }
            
            return ListResourcesResult.builder()
                .resources(resources)
                .build();
        }));
        
        // è¨»å†Šè³‡æºè®€å–è™•ç†å™¨
        server.setResourceReadHandler(request -> CompletableFuture.supplyAsync(() -> {
            String uri = request.getParams().getUri();
            
            // è§£æ URI
            String relativePath;
            if (uri.startsWith("file:///")) {
                relativePath = uri.substring(8);
            } else {
                throw new IllegalArgumentException("ä¸æ”¯æ´çš„ URI æ ¼å¼ï¼š" + uri);
            }
            
            Path filePath = allowedRoot.resolve(relativePath);
            
            // å®‰å…¨æª¢æŸ¥
            if (!isSafePath(filePath)) {
                throw new SecurityException("å­˜å–è¢«æ‹’çµ•ï¼šè·¯å¾‘ä¸åœ¨å…è¨±ç¯„åœå…§");
            }
            
            if (!Files.exists(filePath)) {
                throw new IllegalArgumentException("æª”æ¡ˆä¸å­˜åœ¨ï¼š" + relativePath);
            }
            
            try {
                String mimeType = guessMimeType(filePath);
                
                if (mimeType.startsWith("text/") || mimeType.equals("application/json")) {
                    // æ–‡å­—æª”æ¡ˆ
                    String content = Files.readString(filePath);
                    return ReadResourceResult.builder()
                        .contents(List.of(
                            ResourceContent.text(uri, mimeType, content)
                        ))
                        .build();
                } else {
                    // äºŒé€²ä½æª”æ¡ˆ
                    byte[] bytes = Files.readAllBytes(filePath);
                    String base64Content = Base64.getEncoder().encodeToString(bytes);
                    return ReadResourceResult.builder()
                        .contents(List.of(
                            ResourceContent.blob(uri, mimeType, base64Content)
                        ))
                        .build();
                }
            } catch (IOException e) {
                throw new RuntimeException("è®€å–æª”æ¡ˆéŒ¯èª¤ï¼š" + e.getMessage());
            }
        }));
        
        // è¨»å†Šè³‡æºè¨‚é–±è™•ç†å™¨
        server.setResourceSubscribeHandler(request -> CompletableFuture.supplyAsync(() -> {
            String uri = request.getParams().getUri();
            // å¯¦ä½œæª”æ¡ˆç›£æ§é‚è¼¯ï¼ˆå¯ä½¿ç”¨ WatchServiceï¼‰
            System.err.println("è¨‚é–±è³‡æºï¼š" + uri);
            return SubscribeResult.builder().build();
        }));
    }
    
    public void start() throws Exception {
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport);
        System.err.println("Filesystem MCP Server running on stdio");
        System.err.println("Allowed root: " + allowedRoot);
    }
    
    public static void main(String[] args) throws Exception {
        String rootPath = args.length > 0 ? args[0] : System.getProperty("user.home") + "/documents";
        FilesystemMcpServer server = new FilesystemMcpServer(rootPath);
        server.start();
    }
}
```

#### 4.2.5 é€²éšç¯„ä¾‹ï¼šå¯¦ä½œ Promptsï¼ˆäº’å‹•æ¨¡æ¿ï¼‰

```java
/**
 * æç¤ºæ¨¡æ¿ç¯„ä¾‹
 * PromptsMcpServer.java
 */
package com.example.mcp;

import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.spec.*;

import java.util.*;
import java.util.concurrent.CompletableFuture;

public class PromptsMcpServer {
    
    private final McpServer server;
    private final Map<String, PromptDefinition> prompts = new HashMap<>();
    
    // å…§éƒ¨é¡åˆ¥ï¼šæç¤ºå®šç¾©
    private record PromptDefinition(
        String description,
        List<PromptArgument> arguments
    ) {}
    
    public PromptsMcpServer() {
        // åˆå§‹åŒ–æç¤ºæ¨¡æ¿
        initializePrompts();
        
        // å»ºç«‹ MCP Server
        McpServerOptions options = McpServerOptions.builder()
            .serverName("prompts-server")
            .serverVersion("1.0.0")
            .capabilities(ServerCapabilities.builder()
                .prompts(ServerCapabilities.PromptCapabilities.builder()
                    .listChanged(true)
                    .build())
                .build())
            .build();
        
        this.server = new McpServer(options);
        
        // è¨»å†Šè™•ç†å™¨
        registerHandlers();
    }
    
    private void initializePrompts() {
        // ç¨‹å¼ç¢¼å¯©æŸ¥æ¨¡æ¿
        prompts.put("code_review", new PromptDefinition(
            "ç¨‹å¼ç¢¼å¯©æŸ¥æ¨¡æ¿",
            List.of(
                PromptArgument.builder()
                    .name("language")
                    .description("ç¨‹å¼èªè¨€")
                    .required(true)
                    .build(),
                PromptArgument.builder()
                    .name("code")
                    .description("è¦å¯©æŸ¥çš„ç¨‹å¼ç¢¼")
                    .required(true)
                    .build(),
                PromptArgument.builder()
                    .name("focus")
                    .description("å¯©æŸ¥é‡é»ï¼ˆsecurity/performance/styleï¼‰")
                    .required(false)
                    .build()
            )
        ));
        
        // ç¨‹å¼ç¢¼è§£èªªæ¨¡æ¿
        prompts.put("explain_code", new PromptDefinition(
            "ç¨‹å¼ç¢¼è§£èªªæ¨¡æ¿",
            List.of(
                PromptArgument.builder()
                    .name("code")
                    .description("è¦è§£èªªçš„ç¨‹å¼ç¢¼")
                    .required(true)
                    .build(),
                PromptArgument.builder()
                    .name("level")
                    .description("è§£èªªç¨‹åº¦ï¼ˆbeginner/intermediate/advancedï¼‰")
                    .required(false)
                    .build()
            )
        ));
        
        // æ¸¬è©¦æ¡ˆä¾‹ç”Ÿæˆæ¨¡æ¿
        prompts.put("generate_tests", new PromptDefinition(
            "æ¸¬è©¦æ¡ˆä¾‹ç”Ÿæˆæ¨¡æ¿",
            List.of(
                PromptArgument.builder()
                    .name("code")
                    .description("è¦æ¸¬è©¦çš„ç¨‹å¼ç¢¼")
                    .required(true)
                    .build(),
                PromptArgument.builder()
                    .name("framework")
                    .description("æ¸¬è©¦æ¡†æ¶ï¼ˆjunit/testng/mockitoï¼‰")
                    .required(false)
                    .build()
            )
        ));
    }
    
    private void registerHandlers() {
        // åˆ—å‡ºæç¤ºæ¨¡æ¿
        server.setPromptListHandler(request -> CompletableFuture.supplyAsync(() -> {
            List<Prompt> promptList = new ArrayList<>();
            
            prompts.forEach((name, definition) -> {
                promptList.add(Prompt.builder()
                    .name(name)
                    .description(definition.description())
                    .arguments(definition.arguments())
                    .build());
            });
            
            return ListPromptsResult.builder()
                .prompts(promptList)
                .build();
        }));
        
        // å–å¾—æç¤ºå…§å®¹
        server.setPromptGetHandler(request -> CompletableFuture.supplyAsync(() -> {
            String name = request.getParams().getName();
            Map<String, String> arguments = request.getParams().getArguments();
            
            List<PromptMessage> messages = switch (name) {
                case "code_review" -> generateCodeReviewPrompt(arguments);
                case "explain_code" -> generateExplainCodePrompt(arguments);
                case "generate_tests" -> generateTestsPrompt(arguments);
                default -> throw new IllegalArgumentException("Unknown prompt: " + name);
            };
            
            return GetPromptResult.builder()
                .messages(messages)
                .build();
        }));
    }
    
    private List<PromptMessage> generateCodeReviewPrompt(Map<String, String> args) {
        String language = args.getOrDefault("language", "");
        String code = args.getOrDefault("code", "");
        String focus = args.getOrDefault("focus", "general");
        
        Map<String, String> focusInstructions = Map.of(
            "security", "è«‹ç‰¹åˆ¥é—œæ³¨å®‰å…¨æ€§å•é¡Œï¼ŒåŒ…æ‹¬ï¼šè¼¸å…¥é©—è­‰ã€SQL æ³¨å…¥ã€XSSã€èªè­‰æˆæ¬Šç­‰ã€‚",
            "performance", "è«‹ç‰¹åˆ¥é—œæ³¨æ•ˆèƒ½å•é¡Œï¼ŒåŒ…æ‹¬ï¼šæ¼”ç®—æ³•è¤‡é›œåº¦ã€è¨˜æ†¶é«”ä½¿ç”¨ã€è³‡æ–™åº«æŸ¥è©¢æ•ˆç‡ç­‰ã€‚",
            "style", "è«‹ç‰¹åˆ¥é—œæ³¨ç¨‹å¼ç¢¼é¢¨æ ¼ï¼ŒåŒ…æ‹¬ï¼šå‘½åè¦ç¯„ã€ç¨‹å¼ç¢¼çµæ§‹ã€å¯è®€æ€§ã€è¨»è§£ç­‰ã€‚",
            "general", "è«‹å…¨é¢å¯©æŸ¥ç¨‹å¼ç¢¼ï¼ŒåŒ…æ‹¬ï¼šæ­£ç¢ºæ€§ã€å®‰å…¨æ€§ã€æ•ˆèƒ½ã€å¯ç¶­è­·æ€§ç­‰é¢å‘ã€‚"
        );
        
        String promptText = String.format("""
            è«‹å¯©æŸ¥ä»¥ä¸‹ %s ç¨‹å¼ç¢¼ï¼š
            
            ```%s
            %s
            ```
            
            %s
            
            è«‹æä¾›ï¼š
            1. ç™¼ç¾çš„å•é¡Œï¼ˆæŒ‰åš´é‡ç¨‹åº¦æ’åºï¼‰
            2. æ”¹é€²å»ºè­°
            3. æ•´é«”è©•åˆ†ï¼ˆ1-10ï¼‰
            4. ä¿®æ”¹å¾Œçš„ç¨‹å¼ç¢¼ç¯„ä¾‹ï¼ˆå¦‚é©ç”¨ï¼‰
            """, 
            language, 
            language.toLowerCase(), 
            code,
            focusInstructions.getOrDefault(focus, focusInstructions.get("general"))
        );
        
        return List.of(
            PromptMessage.builder()
                .role(Role.USER)
                .content(TextContent.builder()
                    .type("text")
                    .text(promptText)
                    .build())
                .build()
        );
    }
    
    private List<PromptMessage> generateExplainCodePrompt(Map<String, String> args) {
        String code = args.getOrDefault("code", "");
        String level = args.getOrDefault("level", "intermediate");
        
        Map<String, String> levelInstructions = Map.of(
            "beginner", "è«‹ç”¨ç°¡å–®æ˜“æ‡‚çš„èªè¨€è§£èªªï¼Œé¿å…ä½¿ç”¨å°ˆæ¥­è¡“èªï¼Œå¤šç”¨æ¯”å–»èªªæ˜ã€‚",
            "intermediate", "è«‹è©³ç´°è§£èªªç¨‹å¼ç¢¼çš„é‹ä½œåŸç†ï¼Œå¯ä»¥ä½¿ç”¨å¸¸è¦‹çš„æŠ€è¡“è¡“èªã€‚",
            "advanced", "è«‹æ·±å…¥åˆ†æç¨‹å¼ç¢¼çš„è¨­è¨ˆæ¨¡å¼ã€æ•ˆèƒ½è€ƒé‡ã€æ½›åœ¨å•é¡Œç­‰é€²éšé¢å‘ã€‚"
        );
        
        String promptText = String.format("""
            è«‹è§£èªªä»¥ä¸‹ç¨‹å¼ç¢¼ï¼š
            
            ```
            %s
            ```
            
            %s
            
            è«‹åŒ…å«ï¼š
            1. ç¨‹å¼ç¢¼çš„æ•´é«”åŠŸèƒ½èªªæ˜
            2. é€è¡Œæˆ–é€æ®µè§£èªª
            3. ä½¿ç”¨çš„ç¨‹å¼æŠ€å·§æˆ–è¨­è¨ˆæ¨¡å¼
            4. å¯èƒ½çš„ä½¿ç”¨æƒ…å¢ƒ
            """,
            code,
            levelInstructions.getOrDefault(level, levelInstructions.get("intermediate"))
        );
        
        return List.of(
            PromptMessage.builder()
                .role(Role.USER)
                .content(TextContent.builder()
                    .type("text")
                    .text(promptText)
                    .build())
                .build()
        );
    }
    
    private List<PromptMessage> generateTestsPrompt(Map<String, String> args) {
        String code = args.getOrDefault("code", "");
        String framework = args.getOrDefault("framework", "junit");
        
        String promptText = String.format("""
            è«‹ç‚ºä»¥ä¸‹ç¨‹å¼ç¢¼ç”Ÿæˆæ¸¬è©¦æ¡ˆä¾‹ï¼š
            
            ```
            %s
            ```
            
            ä½¿ç”¨ %s æ¸¬è©¦æ¡†æ¶ã€‚
            
            è«‹åŒ…å«ï¼š
            1. æ­£å¸¸æƒ…æ³æ¸¬è©¦ï¼ˆHappy Pathï¼‰
            2. é‚Šç•Œæ¢ä»¶æ¸¬è©¦
            3. éŒ¯èª¤è™•ç†æ¸¬è©¦
            4. æ•ˆèƒ½æ¸¬è©¦ï¼ˆå¦‚é©ç”¨ï¼‰
            
            è«‹æä¾›å®Œæ•´å¯åŸ·è¡Œçš„æ¸¬è©¦ç¨‹å¼ç¢¼ã€‚
            """,
            code,
            framework
        );
        
        return List.of(
            PromptMessage.builder()
                .role(Role.USER)
                .content(TextContent.builder()
                    .type("text")
                    .text(promptText)
                    .build())
                .build()
        );
    }
    
    public void start() throws Exception {
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport);
        System.err.println("Prompts MCP Server running on stdio");
    }
    
    public static void main(String[] args) throws Exception {
        PromptsMcpServer server = new PromptsMcpServer();
        server.start();
    }
}
```

#### 4.2.6 å‹•æ…‹å·¥å…·åˆ—è¡¨ç®¡ç†èˆ‡ç™¼é€é€šçŸ¥

```java
/**
 * å‹•æ…‹å·¥å…·ç®¡ç†ç¯„ä¾‹
 * DynamicToolsMcpServer.java
 */
package com.example.mcp;

import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.spec.*;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;

public class DynamicToolsMcpServer {
    
    private final McpServer server;
    private final Map<String, Tool> registeredTools = new ConcurrentHashMap<>();
    
    public DynamicToolsMcpServer() {
        // å»ºç«‹ MCP Server
        McpServerOptions options = McpServerOptions.builder()
            .serverName("dynamic-tools-server")
            .serverVersion("1.0.0")
            .capabilities(ServerCapabilities.builder()
                .tools(ServerCapabilities.ToolCapabilities.builder()
                    .listChanged(true)
                    .build())
                .build())
            .build();
        
        this.server = new McpServer(options);
        
        // åˆå§‹åŒ–å…§å»ºå·¥å…·
        initBuiltinTools();
        
        // è¨»å†Šè™•ç†å™¨
        registerHandlers();
    }
    
    /**
     * è¨»å†Šæ–°å·¥å…·ä¸¦é€šçŸ¥ Client
     */
    public void registerTool(Tool tool) {
        registeredTools.put(tool.getName(), tool);
        // ç™¼é€å·¥å…·åˆ—è¡¨è®Šæ›´é€šçŸ¥
        server.sendNotification("notifications/tools/list_changed", Map.of());
        System.err.println("å·²è¨»å†Šå·¥å…·ï¼š" + tool.getName());
    }
    
    /**
     * å–æ¶ˆè¨»å†Šå·¥å…·ä¸¦é€šçŸ¥ Client
     */
    public void unregisterTool(String name) {
        if (registeredTools.remove(name) != null) {
            server.sendNotification("notifications/tools/list_changed", Map.of());
            System.err.println("å·²ç§»é™¤å·¥å…·ï¼š" + name);
        }
    }
    
    private void initBuiltinTools() {
        // è¨»å†Šç®¡ç†å·¥å…·
        registerTool(Tool.builder()
            .name("register_calculator")
            .description("è¨»å†Šè¨ˆç®—æ©Ÿå·¥å…·")
            .inputSchema(Map.of(
                "type", "object",
                "properties", Map.of()
            ))
            .build());
        
        registerTool(Tool.builder()
            .name("list_registered_tools")
            .description("åˆ—å‡ºæ‰€æœ‰å·²è¨»å†Šçš„å·¥å…·")
            .inputSchema(Map.of(
                "type", "object",
                "properties", Map.of()
            ))
            .build());
    }
    
    private void registerHandlers() {
        // å·¥å…·åˆ—è¡¨è™•ç†å™¨
        server.setToolListHandler(request -> CompletableFuture.supplyAsync(() -> 
            ListToolsResult.builder()
                .tools(new ArrayList<>(registeredTools.values()))
                .build()
        ));
        
        // å·¥å…·å‘¼å«è™•ç†å™¨
        server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
            String toolName = request.getParams().getName();
            Map<String, Object> arguments = request.getParams().getArguments();
            
            return switch (toolName) {
                case "register_calculator" -> handleRegisterCalculator();
                case "calculate" -> handleCalculate(arguments);
                case "list_registered_tools" -> handleListTools();
                default -> CallToolResult.error("Unknown tool: " + toolName);
            };
        }));
    }
    
    private CallToolResult handleRegisterCalculator() {
        // å‹•æ…‹è¨»å†Šè¨ˆç®—æ©Ÿå·¥å…·
        Tool calculatorTool = Tool.builder()
            .name("calculate")
            .description("åŸ·è¡Œæ•¸å­¸è¨ˆç®—")
            .inputSchema(Map.of(
                "type", "object",
                "properties", Map.of(
                    "expression", Map.of(
                        "type", "string",
                        "description", "æ•¸å­¸è¡¨é”å¼ï¼ˆä¾‹å¦‚ï¼š2+3*4ï¼‰"
                    )
                ),
                "required", List.of("expression")
            ))
            .build();
        
        registerTool(calculatorTool);
        
        return CallToolResult.text("Calculator tool registered successfully");
    }
    
    private CallToolResult handleCalculate(Map<String, Object> arguments) {
        String expression = (String) arguments.get("expression");
        
        if (expression == null || expression.isEmpty()) {
            return CallToolResult.error("è¡¨é”å¼ä¸èƒ½ç‚ºç©º");
        }
        
        // å®‰å…¨æª¢æŸ¥ï¼šåƒ…å…è¨±åŸºæœ¬é‹ç®—ç¬¦å’Œæ•¸å­—
        if (!expression.matches("[0-9+\\-*/().\\s]+")) {
            return CallToolResult.error("ä¸å…è¨±çš„å­—å…ƒï¼Œåƒ…æ”¯æ´æ•¸å­—å’ŒåŸºæœ¬é‹ç®—ç¬¦");
        }
        
        try {
            // ä½¿ç”¨ JavaScript å¼•æ“è¨ˆç®—è¡¨é”å¼
            ScriptEngineManager manager = new ScriptEngineManager();
            ScriptEngine engine = manager.getEngineByName("JavaScript");
            
            if (engine == null) {
                // å¦‚æœæ²’æœ‰ JavaScript å¼•æ“ï¼Œä½¿ç”¨ç°¡å–®çš„è¨ˆç®—æ–¹å¼
                double result = evaluateSimpleExpression(expression);
                return CallToolResult.text("çµæœï¼š" + result);
            }
            
            Object result = engine.eval(expression);
            return CallToolResult.text("çµæœï¼š" + result);
            
        } catch (Exception e) {
            return CallToolResult.error("è¨ˆç®—éŒ¯èª¤ï¼š" + e.getMessage());
        }
    }
    
    private double evaluateSimpleExpression(String expression) {
        // ç°¡å–®çš„è¡¨é”å¼è¨ˆç®—ï¼ˆåƒ…æ”¯æ´åŠ æ¸›ä¹˜é™¤ï¼‰
        expression = expression.replaceAll("\\s+", "");
        
        // é€™æ˜¯ä¸€å€‹ç°¡åŒ–çš„å¯¦ä½œï¼Œç”Ÿç”¢ç’°å¢ƒæ‡‰ä½¿ç”¨æ›´å®Œå–„çš„è¡¨é”å¼è§£æå™¨
        javax.script.ScriptEngineManager mgr = new javax.script.ScriptEngineManager();
        javax.script.ScriptEngine eng = mgr.getEngineByName("nashorn");
        
        if (eng != null) {
            try {
                return ((Number) eng.eval(expression)).doubleValue();
            } catch (Exception e) {
                throw new RuntimeException("ç„¡æ³•è¨ˆç®—è¡¨é”å¼ï¼š" + expression);
            }
        }
        
        // ç°¡å–®çš„åŠ æ³•è¨ˆç®—ä½œç‚ºå¾Œå‚™
        try {
            return Double.parseDouble(expression);
        } catch (NumberFormatException e) {
            throw new RuntimeException("ç„¡æ³•è¨ˆç®—è¡¨é”å¼ï¼š" + expression);
        }
    }
    
    private CallToolResult handleListTools() {
        StringBuilder result = new StringBuilder("å·²è¨»å†Šçš„å·¥å…·ï¼š\n");
        
        for (Tool tool : registeredTools.values()) {
            result.append("- ").append(tool.getName())
                  .append(": ").append(tool.getDescription())
                  .append("\n");
        }
        
        return CallToolResult.text(result.toString());
    }
    
    public void start() throws Exception {
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport);
        System.err.println("Dynamic Tools MCP Server running on stdio");
    }
    
    public static void main(String[] args) throws Exception {
        DynamicToolsMcpServer server = new DynamicToolsMcpServer();
        server.start();
    }
}
```

---

### 4.3 é–‹ç™¼ MCP Client

#### 4.3.1 åŸºç¤ç¯„ä¾‹ï¼šé€£æ¥åˆ° MCP Server

**Java Client**ï¼š

```java
/**
 * MCP Client åŸºç¤ç¯„ä¾‹
 * McpClientExample.java
 */
package com.example.mcp.client;

import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.client.McpClientOptions;
import io.modelcontextprotocol.client.transport.StdioClientTransport;
import io.modelcontextprotocol.spec.*;

import java.util.*;
import java.util.concurrent.CompletableFuture;

public class McpClientExample {
    
    public static void main(String[] args) throws Exception {
        // è¨­å®š Server é€£æ¥åƒæ•¸
        StdioClientTransport transport = new StdioClientTransport(
            "java",                           // å‘½ä»¤
            List.of("-jar", "my-mcp-server.jar")  // åƒæ•¸
        );
        
        // å»ºç«‹ Client
        McpClientOptions options = McpClientOptions.builder()
            .clientInfo(ClientInfo.builder()
                .name("example-client")
                .version("1.0.0")
                .build())
            .build();
        
        try (McpClient client = new McpClient(options)) {
            // é€£æ¥åˆ° Server
            client.connect(transport);
            
            // åˆå§‹åŒ–é€£æ¥
            InitializeResult initResult = client.initialize().get();
            System.out.println("å·²é€£æ¥åˆ° Serverï¼š" + initResult.getServerInfo().getName());
            
            // åˆ—å‡ºå¯ç”¨å·¥å…·
            ListToolsResult toolsResult = client.listTools().get();
            System.out.println("\nå¯ç”¨å·¥å…·ï¼š");
            for (Tool tool : toolsResult.getTools()) {
                System.out.println("  - " + tool.getName() + ": " + tool.getDescription());
            }
            
            // å‘¼å«å·¥å…·
            CallToolResult result = client.callTool(
                "hello",
                Map.of("name", "MCP User")
            ).get();
            
            System.out.println("\nå·¥å…·å›æ‡‰ï¼š" + result.getContent().get(0).getText());
        }
    }
}
```

**TypeScript Client**ï¼š

```typescript
/**
 * MCP Client åŸºç¤ç¯„ä¾‹
 */

import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";

async function main() {
  // å»ºç«‹ Client
  const client = new Client(
    {
      name: "example-client",
      version: "1.0.0",
    },
    {
      capabilities: {},
    }
  );

  // å»ºç«‹ Transport
  const transport = new StdioClientTransport({
    command: "node",
    args: ["./server.js"],
  });

  // é€£æ¥åˆ° Server
  await client.connect(transport);

  // åˆ—å‡ºå¯ç”¨å·¥å…·
  const tools = await client.listTools();
  console.log("å¯ç”¨å·¥å…·ï¼š");
  for (const tool of tools.tools) {
    console.log(`  - ${tool.name}: ${tool.description}`);
  }

  // å‘¼å«å·¥å…·
  const result = await client.callTool({
    name: "hello",
    arguments: { name: "MCP User" },
  });

  console.log("\nå·¥å…·å›æ‡‰ï¼š", result.content[0]);

  // é—œé–‰é€£æ¥
  await client.close();
}

main().catch(console.error);
```

#### 4.3.2 åˆå§‹åŒ–èˆ‡èƒ½åŠ›å”å•†

```java
/**
 * èƒ½åŠ›å”å•†ç¯„ä¾‹
 * CapabilityNegotiationExample.java
 */
package com.example.mcp.client;

import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.client.McpClientOptions;
import io.modelcontextprotocol.client.transport.StdioClientTransport;
import io.modelcontextprotocol.spec.*;

import java.util.List;

public class CapabilityNegotiationExample {
    
    public static void main(String[] args) throws Exception {
        StdioClientTransport transport = new StdioClientTransport(
            "java",
            List.of("-jar", "my-mcp-server.jar")
        );
        
        McpClientOptions options = McpClientOptions.builder()
            .clientInfo(ClientInfo.builder()
                .name("capability-client")
                .version("1.0.0")
                .build())
            .build();
        
        try (McpClient client = new McpClient(options)) {
            client.connect(transport);
            
            // åˆå§‹åŒ–ä¸¦å–å¾— Server èƒ½åŠ›
            InitializeResult initResult = client.initialize().get();
            
            System.out.println("Server è³‡è¨Šï¼š");
            System.out.println("  åç¨±ï¼š" + initResult.getServerInfo().getName());
            System.out.println("  ç‰ˆæœ¬ï¼š" + initResult.getServerInfo().getVersion());
            System.out.println("  å”è­°ç‰ˆæœ¬ï¼š" + initResult.getProtocolVersion());
            
            System.out.println("\nServer èƒ½åŠ›ï¼š");
            ServerCapabilities caps = initResult.getCapabilities();
            
            if (caps.getTools() != null) {
                System.out.println("  âœ“ Tools æ”¯æ´");
                if (Boolean.TRUE.equals(caps.getTools().getListChanged())) {
                    System.out.println("    - æ”¯æ´å·¥å…·åˆ—è¡¨è®Šæ›´é€šçŸ¥");
                }
            }
            
            if (caps.getResources() != null) {
                System.out.println("  âœ“ Resources æ”¯æ´");
                if (Boolean.TRUE.equals(caps.getResources().getSubscribe())) {
                    System.out.println("    - æ”¯æ´è³‡æºè¨‚é–±");
                }
                if (Boolean.TRUE.equals(caps.getResources().getListChanged())) {
                    System.out.println("    - æ”¯æ´è³‡æºåˆ—è¡¨è®Šæ›´é€šçŸ¥");
                }
            }
            
            if (caps.getPrompts() != null) {
                System.out.println("  âœ“ Prompts æ”¯æ´");
                if (Boolean.TRUE.equals(caps.getPrompts().getListChanged())) {
                    System.out.println("    - æ”¯æ´æç¤ºåˆ—è¡¨è®Šæ›´é€šçŸ¥");
                }
            }
            
            if (caps.getLogging() != null) {
                System.out.println("  âœ“ Logging æ”¯æ´");
            }
        }
    }
}
```

#### 4.3.3 é€²éšç¯„ä¾‹ï¼šè™•ç†é€šçŸ¥èˆ‡éŒ¯èª¤

```java
/**
 * é€²éš Client ç¯„ä¾‹ï¼šé€šçŸ¥è™•ç†èˆ‡éŒ¯èª¤é‡è©¦
 * McpClientWrapper.java
 */
package com.example.mcp.client;

import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.client.McpClientOptions;
import io.modelcontextprotocol.client.transport.StdioClientTransport;
import io.modelcontextprotocol.spec.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * å°è£ MCP Client çš„é€²éšåŠŸèƒ½
 */
public class McpClientWrapper implements AutoCloseable {
    
    private static final Logger logger = Logger.getLogger(McpClientWrapper.class.getName());
    
    private final String serverCommand;
    private final List<String> serverArgs;
    private McpClient client;
    private final Map<String, Consumer<Map<String, Object>>> notificationHandlers;
    private final int retryCount;
    private final long retryDelayMs;
    
    public McpClientWrapper(String serverCommand, List<String> serverArgs) {
        this.serverCommand = serverCommand;
        this.serverArgs = serverArgs;
        this.notificationHandlers = new ConcurrentHashMap<>();
        this.retryCount = 3;
        this.retryDelayMs = 1000L;
    }
    
    /**
     * è¨»å†Šé€šçŸ¥è™•ç†å™¨
     */
    public void onNotification(String method, Consumer<Map<String, Object>> handler) {
        notificationHandlers.put(method, handler);
    }
    
    /**
     * è™•ç†æ¥æ”¶åˆ°çš„é€šçŸ¥
     */
    private void handleNotification(String method, Map<String, Object> params) {
        Consumer<Map<String, Object>> handler = notificationHandlers.get(method);
        if (handler != null) {
            handler.accept(params);
        } else {
            logger.fine("æœªè™•ç†çš„é€šçŸ¥ï¼š" + method);
        }
    }
    
    /**
     * å¸¶é‡è©¦æ©Ÿåˆ¶çš„å·¥å…·å‘¼å«
     */
    public CompletableFuture<CallToolResult> callToolWithRetry(String name, Map<String, Object> arguments) {
        return CompletableFuture.supplyAsync(() -> {
            Exception lastError = null;
            
            for (int attempt = 0; attempt < retryCount; attempt++) {
                try {
                    return client.callTool(name, arguments).get();
                } catch (Exception e) {
                    lastError = e;
                    logger.warning(String.format("å·¥å…·å‘¼å«å¤±æ•— (å˜—è©¦ %d/%d): %s", 
                        attempt + 1, retryCount, e.getMessage()));
                    
                    if (attempt < retryCount - 1) {
                        try {
                            Thread.sleep(retryDelayMs * (attempt + 1));
                        } catch (InterruptedException ie) {
                            Thread.currentThread().interrupt();
                            throw new CompletionException(ie);
                        }
                    }
                }
            }
            
            throw new CompletionException(lastError);
        });
    }
    
    /**
     * é€£æ¥åˆ° Server
     */
    public void connect() throws Exception {
        StdioClientTransport transport = new StdioClientTransport(serverCommand, serverArgs);
        
        McpClientOptions options = McpClientOptions.builder()
            .clientInfo(ClientInfo.builder()
                .name("advanced-client")
                .version("1.0.0")
                .build())
            .notificationHandler(this::handleNotification)
            .build();
        
        client = new McpClient(options);
        client.connect(transport);
        client.initialize().get();
    }
    
    /**
     * å–å¾— Session
     */
    public McpClient getClient() {
        return client;
    }
    
    @Override
    public void close() throws Exception {
        if (client != null) {
            client.close();
        }
    }
    
    // ä½¿ç”¨ç¯„ä¾‹
    public static void main(String[] args) throws Exception {
        McpClientWrapper wrapper = new McpClientWrapper(
            "java", 
            List.of("-jar", "my-mcp-server.jar")
        );
        
        // è¨»å†Šé€šçŸ¥è™•ç†å™¨
        wrapper.onNotification("notifications/tools/list_changed", params -> {
            logger.info("å·¥å…·åˆ—è¡¨å·²è®Šæ›´ï¼Œé‡æ–°è¼‰å…¥...");
            try {
                ListToolsResult tools = wrapper.getClient().listTools().get();
                logger.info("æ–°å·¥å…·åˆ—è¡¨ï¼š" + tools.getTools().stream()
                    .map(Tool::getName)
                    .toList());
            } catch (Exception e) {
                logger.severe("é‡æ–°è¼‰å…¥å·¥å…·åˆ—è¡¨å¤±æ•—ï¼š" + e.getMessage());
            }
        });
        
        wrapper.onNotification("notifications/message", params -> {
            String level = (String) params.getOrDefault("level", "info");
            String message = (String) params.getOrDefault("data", "");
            logger.log(Level.parse(level.toUpperCase()), "Server: " + message);
        });
        
        try {
            wrapper.connect();
            
            // åˆ—å‡ºå·¥å…·
            ListToolsResult tools = wrapper.getClient().listTools().get();
            System.out.println("å¯ç”¨å·¥å…·æ•¸é‡ï¼š" + tools.getTools().size());
            
            // ä½¿ç”¨é‡è©¦æ©Ÿåˆ¶å‘¼å«å·¥å…·
            try {
                CallToolResult result = wrapper.callToolWithRetry(
                    "hello",
                    Map.of("name", "World")
                ).get();
                System.out.println("çµæœï¼š" + result.getContent().get(0).getText());
            } catch (Exception e) {
                System.out.println("å·¥å…·å‘¼å«å¤±æ•—ï¼š" + e.getMessage());
            }
        } finally {
            wrapper.close();
        }
    }
}
```

#### 4.3.4 å¤šä¼ºæœå™¨ç®¡ç†

```java
/**
 * å¤š MCP Server ç®¡ç†ç¯„ä¾‹
 * MultiServerClient.java
 */
package com.example.mcp.client;

import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.client.McpClientOptions;
import io.modelcontextprotocol.client.transport.StdioClientTransport;
import io.modelcontextprotocol.spec.*;

import java.util.*;
import java.util.concurrent.*;

/**
 * Server é…ç½®
 */
record ServerConfig(
    String name,
    String command,
    List<String> args,
    String description
) {}

/**
 * ç®¡ç†å¤šå€‹ MCP Server é€£æ¥
 */
public class MultiServerClient implements AutoCloseable {
    
    private final Map<String, McpClient> servers = new ConcurrentHashMap<>();
    private final Map<String, List<String>> serverTools = new ConcurrentHashMap<>();
    
    /**
     * æ·»åŠ ä¸¦é€£æ¥åˆ° Server
     */
    public void addServer(ServerConfig config) throws Exception {
        StdioClientTransport transport = new StdioClientTransport(
            config.command(), 
            config.args()
        );
        
        McpClientOptions options = McpClientOptions.builder()
            .clientInfo(ClientInfo.builder()
                .name("multi-server-client")
                .version("1.0.0")
                .build())
            .build();
        
        McpClient client = new McpClient(options);
        client.connect(transport);
        client.initialize().get();
        
        servers.put(config.name(), client);
        
        // å¿«å–å·¥å…·åˆ—è¡¨
        ListToolsResult tools = client.listTools().get();
        List<String> toolNames = tools.getTools().stream()
            .map(Tool::getName)
            .toList();
        serverTools.put(config.name(), toolNames);
        
        System.out.println("å·²é€£æ¥åˆ° " + config.name() + "ï¼Œå¯ç”¨å·¥å…·ï¼š" + toolNames);
    }
    
    /**
     * æ ¹æ“šå·¥å…·åç¨±æ‰¾åˆ°å°æ‡‰çš„ Server
     */
    public Optional<String> findServerForTool(String toolName) {
        for (Map.Entry<String, List<String>> entry : serverTools.entrySet()) {
            if (entry.getValue().contains(toolName)) {
                return Optional.of(entry.getKey());
            }
        }
        return Optional.empty();
    }
    
    /**
     * æ™ºèƒ½è·¯ç”±å·¥å…·å‘¼å«
     */
    public CompletableFuture<CallToolResult> callTool(String toolName, Map<String, Object> arguments) {
        String serverName = findServerForTool(toolName)
            .orElseThrow(() -> new IllegalArgumentException("æ‰¾ä¸åˆ°æä¾› " + toolName + " çš„ Server"));
        
        McpClient client = servers.get(serverName);
        return client.callTool(toolName, arguments);
    }
    
    /**
     * åˆ—å‡ºæ‰€æœ‰ Server çš„å·¥å…·
     */
    public Map<String, List<Map<String, String>>> listAllTools() throws Exception {
        Map<String, List<Map<String, String>>> allTools = new LinkedHashMap<>();
        
        for (Map.Entry<String, McpClient> entry : servers.entrySet()) {
            ListToolsResult tools = entry.getValue().listTools().get();
            List<Map<String, String>> toolInfoList = tools.getTools().stream()
                .map(t -> Map.of(
                    "name", t.getName(),
                    "description", t.getDescription() != null ? t.getDescription() : ""
                ))
                .toList();
            allTools.put(entry.getKey(), toolInfoList);
        }
        
        return allTools;
    }
    
    @Override
    public void close() throws Exception {
        for (McpClient client : servers.values()) {
            try {
                client.close();
            } catch (Exception e) {
                // è¨˜éŒ„éŒ¯èª¤ä½†ç¹¼çºŒé—œé–‰å…¶ä»–é€£æ¥
            }
        }
        servers.clear();
        serverTools.clear();
    }
    
    // ä½¿ç”¨ç¯„ä¾‹
    public static void main(String[] args) throws Exception {
        MultiServerClient client = new MultiServerClient();
        
        // é…ç½®å¤šå€‹ Server
        List<ServerConfig> serverConfigs = List.of(
            new ServerConfig(
                "filesystem",
                "java",
                List.of("-jar", "filesystem-server.jar"),
                "æª”æ¡ˆç³»çµ±æ“ä½œ"
            ),
            new ServerConfig(
                "database",
                "java",
                List.of("-jar", "database-server.jar"),
                "è³‡æ–™åº«æŸ¥è©¢"
            ),
            new ServerConfig(
                "github",
                "node",
                List.of("./github-server.js"),
                "GitHub æ•´åˆ"
            )
        );
        
        try {
            // é€£æ¥æ‰€æœ‰ Server
            for (ServerConfig config : serverConfigs) {
                try {
                    client.addServer(config);
                } catch (Exception e) {
                    System.out.println("ç„¡æ³•é€£æ¥åˆ° " + config.name() + ": " + e.getMessage());
                }
            }
            
            // åˆ—å‡ºæ‰€æœ‰å·¥å…·
            Map<String, List<Map<String, String>>> allTools = client.listAllTools();
            System.out.println("\næ‰€æœ‰å¯ç”¨å·¥å…·ï¼š");
            for (Map.Entry<String, List<Map<String, String>>> entry : allTools.entrySet()) {
                System.out.println("\n" + entry.getKey() + ":");
                for (Map<String, String> tool : entry.getValue()) {
                    System.out.println("  - " + tool.get("name") + ": " + tool.get("description"));
                }
            }
            
            // æ™ºèƒ½è·¯ç”±å‘¼å«
            CallToolResult result = client.callTool(
                "read_file", 
                Map.of("path", "/etc/hosts")
            ).get();
            String content = result.getContent().get(0).getText();
            System.out.println("\nè®€å–æª”æ¡ˆçµæœï¼š" + content.substring(0, Math.min(100, content.length())) + "...");
            
        } finally {
            client.close();
        }
    }
}
```

---

### 4.4 æ•´åˆåˆ° AI æ‡‰ç”¨

#### 4.4.1 Claude Desktop æ•´åˆç¯„ä¾‹

**é…ç½®æª”æ¡ˆä½ç½®**ï¼š
- macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
- Windows: `%APPDATA%\Claude\claude_desktop_config.json`
- Linux: `~/.config/Claude/claude_desktop_config.json`

**é…ç½®ç¯„ä¾‹**ï¼š

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/Users/user/Documents"],
      "env": {}
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_TOKEN": "ghp_xxxxxxxxxxxx"
      }
    },
    "postgres": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {
        "DATABASE_URL": "postgresql://user:pass@localhost/mydb"
      }
    },
    "custom-server": {
      "command": "python",
      "args": ["-m", "my_custom_server"],
      "env": {
        "API_KEY": "your-api-key"
      }
    }
  }
}
```

#### 4.4.2 Claude Code æ•´åˆç¯„ä¾‹

VS Code è¨­å®šï¼ˆ`settings.json`ï¼‰ï¼š

```json
{
  "claude.mcpServers": {
    "workspace-tools": {
      "command": "node",
      "args": ["${workspaceFolder}/.mcp/server.js"],
      "env": {}
    },
    "docker": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-docker"],
      "env": {}
    }
  }
}
```

#### 4.4.3 è‡ªè¨‚ AI æ‡‰ç”¨æ•´åˆæµç¨‹

```mermaid
graph TB
    subgraph "æ•´åˆæµç¨‹"
        A[1. åˆå§‹åŒ– MCP Client] --> B[2. é€£æ¥ MCP Server]
        B --> C[3. æ¢ç´¢å¯ç”¨å·¥å…·]
        C --> D[4. å»ºç«‹å·¥å…·æè¿°]
        D --> E[5. å‚³é€çµ¦ LLM]
        E --> F{LLM æ±ºå®šä½¿ç”¨å·¥å…·?}
        F -->|æ˜¯| G[6. åŸ·è¡Œå·¥å…·å‘¼å«]
        G --> H[7. å–å¾—çµæœ]
        H --> I[8. å›å‚³çµ¦ LLM]
        I --> E
        F -->|å¦| J[9. è¼¸å‡ºæœ€çµ‚å›æ‡‰]
    end
```

**æ•´åˆç¨‹å¼ç¢¼ç¯„ä¾‹**ï¼š

```java
/**
 * è‡ªè¨‚ AI æ‡‰ç”¨æ•´åˆ MCP ç¯„ä¾‹
 * McpEnabledAssistant.java
 */
package com.example.mcp.assistant;

import com.anthropic.client.AnthropicClient;
import com.anthropic.models.*;
import io.modelcontextprotocol.client.McpClient;
import io.modelcontextprotocol.client.McpClientOptions;
import io.modelcontextprotocol.client.transport.StdioClientTransport;
import io.modelcontextprotocol.spec.*;

import java.util.*;
import java.util.stream.Collectors;

/**
 * æ•´åˆ MCP çš„ AI åŠ©ç†
 */
public class McpEnabledAssistant implements AutoCloseable {
    
    private final AnthropicClient anthropic;
    private McpClient mcpClient;
    private List<Map<String, Object>> availableTools;
    
    public McpEnabledAssistant(String anthropicApiKey) {
        this.anthropic = AnthropicClient.builder()
            .apiKey(anthropicApiKey)
            .build();
        this.availableTools = new ArrayList<>();
    }
    
    /**
     * é€£æ¥ MCP Server
     */
    public void connectMcp(String command, List<String> args) throws Exception {
        StdioClientTransport transport = new StdioClientTransport(command, args);
        
        McpClientOptions options = McpClientOptions.builder()
            .clientInfo(ClientInfo.builder()
                .name("ai-assistant")
                .version("1.0.0")
                .build())
            .build();
        
        mcpClient = new McpClient(options);
        mcpClient.connect(transport);
        mcpClient.initialize().get();
        
        // å–å¾—ä¸¦è½‰æ›å·¥å…·æ ¼å¼
        ListToolsResult toolsResponse = mcpClient.listTools().get();
        availableTools = convertToolsForClaude(toolsResponse.getTools());
    }
    
    /**
     * å°‡ MCP å·¥å…·æ ¼å¼è½‰æ›ç‚º Claude API æ ¼å¼
     */
    private List<Map<String, Object>> convertToolsForClaude(List<Tool> mcpTools) {
        return mcpTools.stream()
            .map(tool -> Map.<String, Object>of(
                "name", tool.getName(),
                "description", tool.getDescription() != null ? tool.getDescription() : "",
                "input_schema", tool.getInputSchema()
            ))
            .collect(Collectors.toList());
    }
    
    /**
     * èˆ‡åŠ©ç†å°è©±
     */
    public String chat(String userMessage) throws Exception {
        List<Map<String, Object>> messages = new ArrayList<>();
        messages.add(Map.of("role", "user", "content", userMessage));
        
        while (true) {
            // å‘¼å« Claude API
            MessageCreateParams params = MessageCreateParams.builder()
                .model("claude-sonnet-4-20250514")
                .maxTokens(4096)
                .tools(availableTools)
                .messages(messages)
                .build();
            
            Message response = anthropic.messages().create(params);
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦ä½¿ç”¨å·¥å…·
            if ("tool_use".equals(response.getStopReason())) {
                // è™•ç†å·¥å…·å‘¼å«
                List<Map<String, Object>> toolResults = new ArrayList<>();
                
                for (ContentBlock content : response.getContent()) {
                    if (content instanceof ToolUseBlock toolUse) {
                        String toolName = toolUse.getName();
                        Map<String, Object> toolInput = toolUse.getInput();
                        String toolUseId = toolUse.getId();
                        
                        // é€é MCP åŸ·è¡Œå·¥å…·
                        String toolResult;
                        boolean isError;
                        
                        try {
                            CallToolResult result = mcpClient.callTool(toolName, toolInput).get();
                            toolResult = result.getContent().get(0).getText();
                            isError = false;
                        } catch (Exception e) {
                            toolResult = "å·¥å…·åŸ·è¡ŒéŒ¯èª¤ï¼š" + e.getMessage();
                            isError = true;
                        }
                        
                        toolResults.add(Map.of(
                            "type", "tool_result",
                            "tool_use_id", toolUseId,
                            "content", toolResult,
                            "is_error", isError
                        ));
                    }
                }
                
                // å°‡çµæœåŠ å…¥å°è©±
                messages.add(Map.of("role", "assistant", "content", response.getContent()));
                messages.add(Map.of("role", "user", "content", toolResults));
            } else {
                // æ²’æœ‰å·¥å…·å‘¼å«ï¼Œå›å‚³æœ€çµ‚å›æ‡‰
                StringBuilder finalResponse = new StringBuilder();
                for (ContentBlock content : response.getContent()) {
                    if (content instanceof TextBlock textBlock) {
                        finalResponse.append(textBlock.getText());
                    }
                }
                return finalResponse.toString();
            }
        }
    }
    
    @Override
    public void close() throws Exception {
        if (mcpClient != null) {
            mcpClient.close();
        }
    }
    
    // ä½¿ç”¨ç¯„ä¾‹
    public static void main(String[] args) throws Exception {
        String apiKey = System.getenv("ANTHROPIC_API_KEY");
        
        try (McpEnabledAssistant assistant = new McpEnabledAssistant(apiKey)) {
            // é€£æ¥ MCP Server
            assistant.connectMcp("java", List.of("-jar", "filesystem-server.jar"));
            
            // å°è©±
            String response = assistant.chat(
                "è«‹å¹«æˆ‘è®€å– /tmp/test.txt çš„å…§å®¹ï¼Œä¸¦æ‘˜è¦å…¶ä¸­çš„é‡é»"
            );
            System.out.println("åŠ©ç†å›æ‡‰ï¼š" + response);
        }
    }
}
```

> **ğŸ’¡ å¯¦å‹™å»ºè­°**ï¼š
> - åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ï¼Œç¢ºä¿æ­£ç¢ºè™•ç† API Key å’Œæ•æ„Ÿè³‡è¨Š
> - å¯¦ä½œé©ç•¶çš„éŒ¯èª¤è™•ç†å’Œé‡è©¦æ©Ÿåˆ¶
> - è€ƒæ…®ä½¿ç”¨é€£æ¥æ± ç®¡ç†å¤šå€‹ MCP Server é€£æ¥

---

## ç¬¬äº”ç« ï¼šå®Œæ•´å¯¦æˆ°ç¯„ä¾‹

æœ¬ç« æä¾›ä¸‰å€‹å®Œæ•´çš„ç«¯åˆ°ç«¯ç¯„ä¾‹ï¼ŒåŒ…å«å¯ç›´æ¥åŸ·è¡Œçš„ç¨‹å¼ç¢¼ã€‚

### 5.1 ç¯„ä¾‹ä¸€ï¼šæª”æ¡ˆç³»çµ± MCP Server

#### 5.1.1 åŠŸèƒ½èªªæ˜

æä¾›å®‰å…¨çš„æª”æ¡ˆç³»çµ±æ“ä½œåŠŸèƒ½ï¼š
- è®€å–æª”æ¡ˆå…§å®¹
- å¯«å…¥æª”æ¡ˆ
- åˆ—å‡ºç›®éŒ„
- æœå°‹æª”æ¡ˆ
- å–å¾—æª”æ¡ˆè³‡è¨Š

#### 5.1.2 å®Œæ•´ç¨‹å¼ç¢¼

**å°ˆæ¡ˆçµæ§‹**ï¼š
```
filesystem-mcp-server/
â”œâ”€â”€ pom.xml
â”œâ”€â”€ README.md
â””â”€â”€ src/
    â””â”€â”€ main/
        â””â”€â”€ java/
            â””â”€â”€ com/
                â””â”€â”€ example/
                    â””â”€â”€ mcp/
                        â””â”€â”€ filesystem/
                            â””â”€â”€ FilesystemMcpServer.java
```

**pom.xml**ï¼š
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example.mcp</groupId>
    <artifactId>filesystem-mcp-server</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <name>Filesystem MCP Server</name>
    <description>MCP Server for filesystem operations</description>
    
    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>io.modelcontextprotocol</groupId>
            <artifactId>mcp-server</artifactId>
            <version>1.0.0</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.10.1</version>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>com.example.mcp.filesystem.FilesystemMcpServer</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

**src/main/java/com/example/mcp/filesystem/FilesystemMcpServer.java**ï¼š
```java
package com.example.mcp.filesystem;

import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.spec.*;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * æª”æ¡ˆç³»çµ± MCP Server
 * æä¾›å®‰å…¨çš„æª”æ¡ˆè®€å¯«ã€æœå°‹åŠŸèƒ½
 */
public class FilesystemMcpServer {
    
    private final McpServer server;
    
    // é…ç½®ï¼šå…è¨±å­˜å–çš„ç›®éŒ„ï¼ˆå¯é€éç’°å¢ƒè®Šæ•¸è¨­å®šï¼‰
    private final List<String> allowedDirectories;
    
    // æœ€å¤§æª”æ¡ˆå¤§å°é™åˆ¶ï¼ˆ10MBï¼‰
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024;
    
    // ç¦æ­¢çš„æª”æ¡ˆé¡å‹
    private static final Set<String> FORBIDDEN_EXTENSIONS = Set.of(
        ".exe", ".dll", ".so", ".dylib", ".bin"
    );
    
    public FilesystemMcpServer() {
        // å¾ç’°å¢ƒè®Šæ•¸è®€å–å…è¨±çš„ç›®éŒ„
        String allowedDirs = System.getenv().getOrDefault("MCP_ALLOWED_DIRS", "/tmp,/home");
        this.allowedDirectories = Arrays.stream(allowedDirs.split(","))
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .collect(Collectors.toList());
        
        // å»ºç«‹ Server
        McpServerOptions options = McpServerOptions.builder()
            .serverInfo(ServerInfo.builder()
                .name("filesystem-server")
                .version("1.0.0")
                .build())
            .capabilities(ServerCapabilities.builder()
                .tools(ToolsCapability.builder().listChanged(true).build())
                .resources(ResourcesCapability.builder().subscribe(true).listChanged(true).build())
                .build())
            .build();
        
        this.server = new McpServer(options);
        setupHandlers();
    }
    
    private boolean isPathAllowed(Path path) {
        try {
            Path resolved = path.toAbsolutePath().normalize();
            return allowedDirectories.stream()
                .anyMatch(dir -> resolved.startsWith(dir));
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean isSafeFilename(String filename) {
        // æª¢æŸ¥è·¯å¾‘éæ­·æ”»æ“Š
        if (filename.contains("..") || filename.startsWith("/")) {
            return false;
        }
        
        // æª¢æŸ¥ç¦æ­¢çš„å‰¯æª”å
        String ext = filename.contains(".") 
            ? filename.substring(filename.lastIndexOf(".")).toLowerCase() 
            : "";
        return !FORBIDDEN_EXTENSIONS.contains(ext);
    }
    
    private void setupHandlers() {
        // å·¥å…·åˆ—è¡¨è™•ç†å™¨
        server.setToolListHandler(request -> CompletableFuture.supplyAsync(() -> 
            ListToolsResult.builder()
                .tools(List.of(
                    Tool.builder()
                        .name("read_file")
                        .description("è®€å–æŒ‡å®šæª”æ¡ˆçš„å…§å®¹ã€‚æ”¯æ´æ–‡å­—æª”æ¡ˆã€‚")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "path", Map.of(
                                    "type", "string",
                                    "description", "æª”æ¡ˆçš„å®Œæ•´è·¯å¾‘"
                                ),
                                "encoding", Map.of(
                                    "type", "string",
                                    "description", "æª”æ¡ˆç·¨ç¢¼ï¼ˆé è¨­ utf-8ï¼‰",
                                    "default", "utf-8"
                                )
                            ),
                            "required", List.of("path")
                        ))
                        .build(),
                    Tool.builder()
                        .name("write_file")
                        .description("å¯«å…¥å…§å®¹åˆ°æŒ‡å®šæª”æ¡ˆã€‚å¦‚æœæª”æ¡ˆä¸å­˜åœ¨æœƒå»ºç«‹ã€‚")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "path", Map.of("type", "string", "description", "æª”æ¡ˆçš„å®Œæ•´è·¯å¾‘"),
                                "content", Map.of("type", "string", "description", "è¦å¯«å…¥çš„å…§å®¹"),
                                "mode", Map.of(
                                    "type", "string",
                                    "enum", List.of("overwrite", "append"),
                                    "description", "å¯«å…¥æ¨¡å¼ï¼šoverwriteï¼ˆè¦†è“‹ï¼‰æˆ– appendï¼ˆé™„åŠ ï¼‰",
                                    "default", "overwrite"
                                )
                            ),
                            "required", List.of("path", "content")
                        ))
                        .build(),
                    Tool.builder()
                        .name("list_directory")
                        .description("åˆ—å‡ºç›®éŒ„ä¸­çš„æª”æ¡ˆå’Œå­ç›®éŒ„")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "path", Map.of("type", "string", "description", "ç›®éŒ„è·¯å¾‘"),
                                "recursive", Map.of("type", "boolean", "description", "æ˜¯å¦éè¿´åˆ—å‡ºå­ç›®éŒ„", "default", false),
                                "pattern", Map.of("type", "string", "description", "æª”æ¡ˆåç¨±éæ¿¾æ¨¡å¼ï¼ˆå¦‚ *.txtï¼‰")
                            ),
                            "required", List.of("path")
                        ))
                        .build(),
                    Tool.builder()
                        .name("search_files")
                        .description("åœ¨æŒ‡å®šç›®éŒ„ä¸­æœå°‹åŒ…å«ç‰¹å®šå…§å®¹çš„æª”æ¡ˆ")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "directory", Map.of("type", "string", "description", "æœå°‹çš„èµ·å§‹ç›®éŒ„"),
                                "query", Map.of("type", "string", "description", "è¦æœå°‹çš„æ–‡å­—å…§å®¹"),
                                "file_pattern", Map.of("type", "string", "description", "æª”æ¡ˆåç¨±éæ¿¾æ¨¡å¼", "default", "*"),
                                "max_results", Map.of("type", "integer", "description", "æœ€å¤§çµæœæ•¸é‡", "default", 20)
                            ),
                            "required", List.of("directory", "query")
                        ))
                        .build(),
                    Tool.builder()
                        .name("get_file_info")
                        .description("å–å¾—æª”æ¡ˆçš„è©³ç´°è³‡è¨Šï¼ˆå¤§å°ã€ä¿®æ”¹æ™‚é–“ç­‰ï¼‰")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "path", Map.of("type", "string", "description", "æª”æ¡ˆè·¯å¾‘")
                            ),
                            "required", List.of("path")
                        ))
                        .build(),
                    Tool.builder()
                        .name("create_directory")
                        .description("å»ºç«‹æ–°ç›®éŒ„ï¼ˆåŒ…å«çˆ¶ç›®éŒ„ï¼‰")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "path", Map.of("type", "string", "description", "ç›®éŒ„è·¯å¾‘")
                            ),
                            "required", List.of("path")
                        ))
                        .build(),
                    Tool.builder()
                        .name("delete_file")
                        .description("åˆªé™¤æŒ‡å®šæª”æ¡ˆ")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "path", Map.of("type", "string", "description", "æª”æ¡ˆè·¯å¾‘"),
                                "confirm", Map.of("type", "boolean", "description", "ç¢ºèªåˆªé™¤", "default", false)
                            ),
                            "required", List.of("path", "confirm")
                        ))
                        .build()
                ))
                .build()
        ));
        
        // å·¥å…·å‘¼å«è™•ç†å™¨
        server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
            String name = request.getParams().getName();
            Map<String, Object> args = request.getParams().getArguments();
            
            try {
                return switch (name) {
                    case "read_file" -> handleReadFile(args);
                    case "write_file" -> handleWriteFile(args);
                    case "list_directory" -> handleListDirectory(args);
                    case "search_files" -> handleSearchFiles(args);
                    case "get_file_info" -> handleGetFileInfo(args);
                    case "create_directory" -> handleCreateDirectory(args);
                    case "delete_file" -> handleDeleteFile(args);
                    default -> CallToolResult.error("æœªçŸ¥çš„å·¥å…·ï¼š" + name);
                };
            } catch (Exception e) {
                return CallToolResult.error("éŒ¯èª¤ï¼š" + e.getMessage());
            }
        }));
        
        // è³‡æºåˆ—è¡¨è™•ç†å™¨
        server.setResourceListHandler(request -> CompletableFuture.supplyAsync(() -> {
            List<Resource> resources = allowedDirectories.stream()
                .map(dir -> {
                    Path path = Path.of(dir);
                    if (Files.exists(path) && Files.isDirectory(path)) {
                        return Resource.builder()
                            .uri("file://" + path.toAbsolutePath())
                            .name("ç›®éŒ„ï¼š" + path)
                            .description("å…è¨±å­˜å–çš„ç›®éŒ„ï¼š" + path)
                            .mimeType("inode/directory")
                            .build();
                    }
                    return null;
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
            
            return ListResourcesResult.builder().resources(resources).build();
        }));
    }
    
    private CallToolResult handleReadFile(Map<String, Object> args) throws IOException {
        Path path = Path.of((String) args.get("path"));
        String encoding = (String) args.getOrDefault("encoding", "utf-8");
        
        if (!isPathAllowed(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šå­˜å–è¢«æ‹’çµ•ï¼Œè·¯å¾‘ä¸åœ¨å…è¨±ç¯„åœå…§");
        }
        
        if (!Files.exists(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šæª”æ¡ˆä¸å­˜åœ¨ - " + path);
        }
        
        if (!Files.isRegularFile(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šæŒ‡å®šè·¯å¾‘ä¸æ˜¯æª”æ¡ˆ");
        }
        
        if (Files.size(path) > MAX_FILE_SIZE) {
            return CallToolResult.error("éŒ¯èª¤ï¼šæª”æ¡ˆéå¤§ï¼ˆè¶…é " + (MAX_FILE_SIZE / 1024 / 1024) + "MBï¼‰");
        }
        
        try {
            String content = Files.readString(path, java.nio.charset.Charset.forName(encoding));
            return CallToolResult.text(content);
        } catch (java.nio.charset.MalformedInputException e) {
            return CallToolResult.error("éŒ¯èª¤ï¼šç„¡æ³•ä»¥æŒ‡å®šç·¨ç¢¼è®€å–æª”æ¡ˆï¼Œå¯èƒ½æ˜¯äºŒé€²ä½æª”æ¡ˆ");
        }
    }
    
    private CallToolResult handleWriteFile(Map<String, Object> args) throws IOException {
        Path path = Path.of((String) args.get("path"));
        String content = (String) args.get("content");
        String mode = (String) args.getOrDefault("mode", "overwrite");
        
        if (!isPathAllowed(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šå­˜å–è¢«æ‹’çµ•ï¼Œè·¯å¾‘ä¸åœ¨å…è¨±ç¯„åœå…§");
        }
        
        if (!isSafeFilename(path.getFileName().toString())) {
            return CallToolResult.error("éŒ¯èª¤ï¼šä¸å®‰å…¨çš„æª”æ¡ˆåç¨±");
        }
        
        // ç¢ºä¿çˆ¶ç›®éŒ„å­˜åœ¨
        Files.createDirectories(path.getParent());
        
        if ("append".equals(mode)) {
            Files.writeString(path, content, StandardCharsets.UTF_8, 
                StandardOpenOption.CREATE, StandardOpenOption.APPEND);
            return CallToolResult.text("æˆåŠŸï¼šå·²é™„åŠ æª”æ¡ˆ - " + path);
        } else {
            Files.writeString(path, content, StandardCharsets.UTF_8);
            return CallToolResult.text("æˆåŠŸï¼šå·²è¦†å¯«æª”æ¡ˆ - " + path);
        }
    }
    
    private CallToolResult handleListDirectory(Map<String, Object> args) throws IOException {
        Path path = Path.of((String) args.get("path"));
        boolean recursive = Boolean.TRUE.equals(args.get("recursive"));
        String pattern = (String) args.getOrDefault("pattern", "*");
        
        if (!isPathAllowed(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šå­˜å–è¢«æ‹’çµ•");
        }
        
        if (!Files.exists(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šç›®éŒ„ä¸å­˜åœ¨ - " + path);
        }
        
        if (!Files.isDirectory(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šæŒ‡å®šè·¯å¾‘ä¸æ˜¯ç›®éŒ„");
        }
        
        PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:" + pattern);
        List<String> results = new ArrayList<>();
        
        try (Stream<Path> stream = recursive ? Files.walk(path) : Files.list(path)) {
            stream.filter(p -> matcher.matches(p.getFileName()))
                .sorted()
                .limit(100)
                .forEach(p -> {
                    String icon = Files.isDirectory(p) ? "ğŸ“" : "ğŸ“„";
                    Path relPath = path.relativize(p);
                    String size = "";
                    if (Files.isRegularFile(p)) {
                        try {
                            size = " (" + Files.size(p) + " bytes)";
                        } catch (IOException ignored) {}
                    }
                    results.add(icon + " " + relPath + size);
                });
        }
        
        if (results.isEmpty()) {
            return CallToolResult.text("ç›®éŒ„ç‚ºç©ºæˆ–ç„¡ç¬¦åˆæ¢ä»¶çš„é …ç›®");
        }
        
        String header = "ç›®éŒ„åˆ—è¡¨ï¼š" + path + "\n" + "=".repeat(50) + "\n";
        return CallToolResult.text(header + String.join("\n", results));
    }
    
    private CallToolResult handleSearchFiles(Map<String, Object> args) throws IOException {
        Path directory = Path.of((String) args.get("directory"));
        String query = (String) args.get("query");
        String filePattern = (String) args.getOrDefault("file_pattern", "*");
        int maxResults = ((Number) args.getOrDefault("max_results", 20)).intValue();
        
        if (!isPathAllowed(directory)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šå­˜å–è¢«æ‹’çµ•");
        }
        
        if (!Files.exists(directory) || !Files.isDirectory(directory)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šç›®éŒ„ä¸å­˜åœ¨");
        }
        
        PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:" + filePattern);
        List<Map<String, Object>> results = new ArrayList<>();
        String queryLower = query.toLowerCase();
        
        try (Stream<Path> stream = Files.walk(directory)) {
            stream.filter(Files::isRegularFile)
                .filter(p -> matcher.matches(p.getFileName()))
                .filter(p -> {
                    try {
                        return Files.size(p) <= MAX_FILE_SIZE;
                    } catch (IOException e) {
                        return false;
                    }
                })
                .forEach(filePath -> {
                    if (results.size() >= maxResults) return;
                    
                    try {
                        String content = Files.readString(filePath, StandardCharsets.UTF_8);
                        if (content.toLowerCase().contains(queryLower)) {
                            String[] lines = content.split("\n");
                            List<String> matchingLines = new ArrayList<>();
                            
                            for (int i = 0; i < lines.length && matchingLines.size() < 5; i++) {
                                if (lines[i].toLowerCase().contains(queryLower)) {
                                    String line = lines[i].length() > 100 
                                        ? lines[i].substring(0, 100) 
                                        : lines[i];
                                    matchingLines.add("  Line " + (i + 1) + ": " + line);
                                }
                            }
                            
                            results.add(Map.of(
                                "path", filePath.toString(),
                                "matches", matchingLines
                            ));
                        }
                    } catch (IOException ignored) {}
                });
        }
        
        if (results.isEmpty()) {
            return CallToolResult.text("æ‰¾ä¸åˆ°åŒ…å« '" + query + "' çš„æª”æ¡ˆ");
        }
        
        StringBuilder output = new StringBuilder();
        output.append("æœå°‹çµæœï¼šæ‰¾åˆ° ").append(results.size()).append(" å€‹æª”æ¡ˆåŒ…å« '").append(query).append("'\n");
        output.append("=".repeat(50)).append("\n\n");
        
        for (Map<String, Object> result : results) {
            output.append("ğŸ“„ ").append(result.get("path")).append("\n");
            @SuppressWarnings("unchecked")
            List<String> matches = (List<String>) result.get("matches");
            for (String match : matches) {
                output.append(match).append("\n");
            }
            output.append("\n");
        }
        
        return CallToolResult.text(output.toString());
    }
    
    private CallToolResult handleGetFileInfo(Map<String, Object> args) throws IOException {
        Path path = Path.of((String) args.get("path"));
        
        if (!isPathAllowed(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šå­˜å–è¢«æ‹’çµ•");
        }
        
        if (!Files.exists(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šè·¯å¾‘ä¸å­˜åœ¨ - " + path);
        }
        
        BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
        String mimeType = Files.probeContentType(path);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
            .withZone(ZoneId.systemDefault());
        
        String info = String.format("""
            æª”æ¡ˆè³‡è¨Šï¼š%s
            %s
            é¡å‹ï¼š%s
            å¤§å°ï¼š%,d bytes
            MIME é¡å‹ï¼š%s
            å»ºç«‹æ™‚é–“ï¼š%s
            ä¿®æ”¹æ™‚é–“ï¼š%s
            å­˜å–æ™‚é–“ï¼š%s
            """,
            path,
            "=".repeat(50),
            Files.isDirectory(path) ? "ç›®éŒ„" : "æª”æ¡ˆ",
            attrs.size(),
            mimeType != null ? mimeType : "æœªçŸ¥",
            formatter.format(attrs.creationTime().toInstant()),
            formatter.format(attrs.lastModifiedTime().toInstant()),
            formatter.format(attrs.lastAccessTime().toInstant())
        );
        
        return CallToolResult.text(info);
    }
    
    private CallToolResult handleCreateDirectory(Map<String, Object> args) throws IOException {
        Path path = Path.of((String) args.get("path"));
        
        if (!isPathAllowed(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šå­˜å–è¢«æ‹’çµ•");
        }
        
        Files.createDirectories(path);
        return CallToolResult.text("æˆåŠŸï¼šå·²å»ºç«‹ç›®éŒ„ - " + path);
    }
    
    private CallToolResult handleDeleteFile(Map<String, Object> args) throws IOException {
        Path path = Path.of((String) args.get("path"));
        boolean confirm = Boolean.TRUE.equals(args.get("confirm"));
        
        if (!confirm) {
            return CallToolResult.error("éŒ¯èª¤ï¼šè«‹è¨­å®š confirm=true ä»¥ç¢ºèªåˆªé™¤");
        }
        
        if (!isPathAllowed(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šå­˜å–è¢«æ‹’çµ•");
        }
        
        if (!Files.exists(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šæª”æ¡ˆä¸å­˜åœ¨");
        }
        
        if (Files.isDirectory(path)) {
            return CallToolResult.error("éŒ¯èª¤ï¼šä¸æ”¯æ´åˆªé™¤ç›®éŒ„");
        }
        
        Files.delete(path);
        return CallToolResult.text("æˆåŠŸï¼šå·²åˆªé™¤æª”æ¡ˆ - " + path);
    }
    
    public void start() throws Exception {
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport);
        System.err.println("Filesystem MCP Server å•Ÿå‹•ä¸­...");
        System.err.println("å…è¨±çš„ç›®éŒ„ï¼š" + allowedDirectories);
    }
    
    public static void main(String[] args) throws Exception {
        FilesystemMcpServer server = new FilesystemMcpServer();
        server.start();
    }
}
```

#### 5.1.3 æ¸¬è©¦èˆ‡é™¤éŒ¯æ­¥é©Ÿ

**1. å»ºç½®å°ˆæ¡ˆ**ï¼š
```bash
cd filesystem-mcp-server
mvn clean package
```

**2. ä½¿ç”¨ MCP Inspector æ¸¬è©¦**ï¼š
```bash
npx @modelcontextprotocol/inspector java -jar target/filesystem-mcp-server-1.0.0.jar
```

**3. æ¸¬è©¦æŒ‡ä»¤**ï¼š
```json
// åˆ—å‡ºå·¥å…·
{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}

// è®€å–æª”æ¡ˆ
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/call",
  "params": {
    "name": "read_file",
    "arguments": {"path": "/tmp/test.txt"}
  }
}

// åˆ—å‡ºç›®éŒ„
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tools/call",
  "params": {
    "name": "list_directory",
    "arguments": {"path": "/tmp", "pattern": "*.txt"}
  }
}
```

---

### 5.2 ç¯„ä¾‹äºŒï¼šè³‡æ–™åº«æŸ¥è©¢ MCP Server

#### 5.2.1 åŠŸèƒ½èªªæ˜

æä¾›å®‰å…¨çš„ PostgreSQL è³‡æ–™åº«æ“ä½œï¼š
- åˆ—å‡ºè³‡æ–™è¡¨
- æŸ¥çœ‹ Schema
- åŸ·è¡Œ SELECT æŸ¥è©¢
- å®‰å…¨çš„åƒæ•¸åŒ–æŸ¥è©¢

#### 5.2.2 å®Œæ•´ç¨‹å¼ç¢¼

**pom.xml**ï¼ˆè³‡æ–™åº« Serverï¼‰ï¼š
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example.mcp</groupId>
    <artifactId>database-mcp-server</artifactId>
    <version>1.0.0</version>
    
    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>io.modelcontextprotocol</groupId>
            <artifactId>mcp-server</artifactId>
            <version>1.0.0</version>
        </dependency>
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>5.1.0</version>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.7.1</version>
        </dependency>
    </dependencies>
</project>
```

**DatabaseMcpServer.java**ï¼š
```java
package com.example.mcp.database;

import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.spec.*;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import java.sql.*;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.regex.*;

/**
 * è³‡æ–™åº«æŸ¥è©¢ MCP Server
 * æä¾›å®‰å…¨çš„ PostgreSQL è³‡æ–™åº«æŸ¥è©¢åŠŸèƒ½
 */
public class DatabaseMcpServer {
    
    private final McpServer server;
    private final HikariDataSource dataSource;
    
    // é…ç½®
    private static final int MAX_QUERY_ROWS = Integer.parseInt(
        System.getenv().getOrDefault("MAX_QUERY_ROWS", "100")
    );
    private static final int QUERY_TIMEOUT = Integer.parseInt(
        System.getenv().getOrDefault("QUERY_TIMEOUT", "30")
    );
    
    // SQL å®‰å…¨æª¢æŸ¥
    private static final Set<String> DANGEROUS_KEYWORDS = Set.of(
        "DROP", "DELETE", "TRUNCATE", "UPDATE", "INSERT",
        "ALTER", "CREATE", "GRANT", "REVOKE", "EXECUTE"
    );
    
    public DatabaseMcpServer() {
        // åˆå§‹åŒ–é€£æ¥æ± 
        String databaseUrl = System.getenv().getOrDefault(
            "DATABASE_URL", 
            "jdbc:postgresql://localhost/postgres"
        );
        
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(databaseUrl);
        config.setMinimumIdle(2);
        config.setMaximumPoolSize(10);
        config.setConnectionTimeout(QUERY_TIMEOUT * 1000L);
        
        this.dataSource = new HikariDataSource(config);
        
        // å»ºç«‹ Server
        McpServerOptions options = McpServerOptions.builder()
            .serverInfo(ServerInfo.builder()
                .name("database-server")
                .version("1.0.0")
                .build())
            .capabilities(ServerCapabilities.builder()
                .tools(ToolsCapability.builder().build())
                .resources(ResourcesCapability.builder().build())
                .build())
            .build();
        
        this.server = new McpServer(options);
        setupHandlers();
    }
    
    private record SafeQueryResult(boolean safe, String errorMessage) {}
    
    private SafeQueryResult isSafeQuery(String query) {
        // ç§»é™¤è¨»è§£
        String cleanQuery = query.replaceAll("--.*$", "");
        cleanQuery = cleanQuery.replaceAll("/\\*.*?\\*/", "");
        String upperQuery = cleanQuery.toUpperCase().trim();
        
        // å¿…é ˆä»¥ SELECT é–‹é ­
        if (!upperQuery.startsWith("SELECT")) {
            return new SafeQueryResult(false, "åƒ…æ”¯æ´ SELECT æŸ¥è©¢");
        }
        
        // æª¢æŸ¥å±éšªé—œéµå­—
        for (String keyword : DANGEROUS_KEYWORDS) {
            Pattern pattern = Pattern.compile("\\b" + keyword + "\\b");
            if (pattern.matcher(upperQuery).find()) {
                return new SafeQueryResult(false, "æŸ¥è©¢åŒ…å«ä¸å…è¨±çš„é—œéµå­—ï¼š" + keyword);
            }
        }
        
        // æª¢æŸ¥å¤šèªå¥
        String queryWithoutTrailing = cleanQuery.replaceAll(";\\s*$", "");
        if (queryWithoutTrailing.contains(";")) {
            return new SafeQueryResult(false, "ä¸æ”¯æ´å¤šèªå¥æŸ¥è©¢");
        }
        
        return new SafeQueryResult(true, "");
    }
    
    private void setupHandlers() {
        // å·¥å…·åˆ—è¡¨è™•ç†å™¨
        server.setToolListHandler(request -> CompletableFuture.supplyAsync(() ->
            ListToolsResult.builder()
                .tools(List.of(
                    Tool.builder()
                        .name("list_tables")
                        .description("åˆ—å‡ºè³‡æ–™åº«ä¸­çš„æ‰€æœ‰è³‡æ–™è¡¨")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "schema", Map.of(
                                    "type", "string",
                                    "description", "Schema åç¨±ï¼ˆé è¨­ publicï¼‰",
                                    "default", "public"
                                )
                            )
                        ))
                        .build(),
                    Tool.builder()
                        .name("describe_table")
                        .description("å–å¾—è³‡æ–™è¡¨çš„çµæ§‹è³‡è¨Šï¼ˆæ¬„ä½ã€å‹åˆ¥ã€é™åˆ¶ï¼‰")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "table_name", Map.of("type", "string", "description", "è³‡æ–™è¡¨åç¨±"),
                                "schema", Map.of("type", "string", "description", "Schema åç¨±", "default", "public")
                            ),
                            "required", List.of("table_name")
                        ))
                        .build(),
                    Tool.builder()
                        .name("query")
                        .description("åŸ·è¡Œ SQL SELECT æŸ¥è©¢ï¼ˆåƒ…æ”¯æ´è®€å–æ“ä½œï¼‰")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "sql", Map.of("type", "string", "description", "SQL SELECT æŸ¥è©¢èªå¥"),
                                "limit", Map.of("type", "integer", "description", "çµæœç­†æ•¸é™åˆ¶", "default", 50)
                            ),
                            "required", List.of("sql")
                        ))
                        .build(),
                    Tool.builder()
                        .name("get_table_sample")
                        .description("å–å¾—è³‡æ–™è¡¨çš„ç¯„ä¾‹è³‡æ–™")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "table_name", Map.of("type", "string", "description", "è³‡æ–™è¡¨åç¨±"),
                                "limit", Map.of("type", "integer", "description", "ç¯„ä¾‹ç­†æ•¸", "default", 5)
                            ),
                            "required", List.of("table_name")
                        ))
                        .build(),
                    Tool.builder()
                        .name("get_table_stats")
                        .description("å–å¾—è³‡æ–™è¡¨çš„çµ±è¨ˆè³‡è¨Š")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "table_name", Map.of("type", "string", "description", "è³‡æ–™è¡¨åç¨±")
                            ),
                            "required", List.of("table_name")
                        ))
                        .build()
                ))
                .build()
        ));
        
        // å·¥å…·å‘¼å«è™•ç†å™¨
        server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
            String name = request.getParams().getName();
            Map<String, Object> args = request.getParams().getArguments();
            
            try {
                return switch (name) {
                    case "list_tables" -> handleListTables(args);
                    case "describe_table" -> handleDescribeTable(args);
                    case "query" -> handleQuery(args);
                    case "get_table_sample" -> handleTableSample(args);
                    case "get_table_stats" -> handleTableStats(args);
                    default -> CallToolResult.error("æœªçŸ¥çš„å·¥å…·ï¼š" + name);
                };
            } catch (SQLException e) {
                return CallToolResult.error("è³‡æ–™åº«éŒ¯èª¤ï¼š" + e.getMessage());
            } catch (Exception e) {
                return CallToolResult.error("éŒ¯èª¤ï¼š" + e.getMessage());
            }
        }));
    }
    
    private CallToolResult handleListTables(Map<String, Object> args) throws SQLException {
        String schema = (String) args.getOrDefault("schema", "public");
        
        String query = """
            SELECT 
                table_name,
                table_type,
                (SELECT count(*) FROM information_schema.columns c 
                 WHERE c.table_name = t.table_name 
                 AND c.table_schema = t.table_schema) as column_count
            FROM information_schema.tables t
            WHERE table_schema = ?
            ORDER BY table_name
            """;
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setString(1, schema);
            ResultSet rs = stmt.executeQuery();
            
            StringBuilder output = new StringBuilder();
            output.append("è³‡æ–™è¡¨åˆ—è¡¨ï¼ˆSchema: ").append(schema).append("ï¼‰\n");
            output.append("=".repeat(50)).append("\n\n");
            output.append("| è³‡æ–™è¡¨åç¨± | é¡å‹ | æ¬„ä½æ•¸ |\n");
            output.append("| --- | --- | --- |\n");
            
            boolean hasResults = false;
            while (rs.next()) {
                hasResults = true;
                output.append("| ").append(rs.getString("table_name"))
                      .append(" | ").append(rs.getString("table_type"))
                      .append(" | ").append(rs.getInt("column_count"))
                      .append(" |\n");
            }
            
            if (!hasResults) {
                return CallToolResult.text("Schema '" + schema + "' ä¸­æ²’æœ‰è³‡æ–™è¡¨");
            }
            
            return CallToolResult.text(output.toString());
        }
    }
    
    private CallToolResult handleDescribeTable(Map<String, Object> args) throws SQLException {
        String tableName = (String) args.get("table_name");
        String schema = (String) args.getOrDefault("schema", "public");
        
        // é©—è­‰è³‡æ–™è¡¨åç¨±ï¼ˆé˜²æ­¢ SQL æ³¨å…¥ï¼‰
        if (!tableName.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
            return CallToolResult.error("éŒ¯èª¤ï¼šç„¡æ•ˆçš„è³‡æ–™è¡¨åç¨±");
        }
        
        String columnQuery = """
            SELECT 
                column_name,
                data_type,
                character_maximum_length,
                is_nullable,
                column_default
            FROM information_schema.columns
            WHERE table_schema = ? AND table_name = ?
            ORDER BY ordinal_position
            """;
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(columnQuery)) {
            stmt.setString(1, schema);
            stmt.setString(2, tableName);
            ResultSet rs = stmt.executeQuery();
            
            StringBuilder output = new StringBuilder();
            output.append("è³‡æ–™è¡¨çµæ§‹ï¼š").append(schema).append(".").append(tableName).append("\n");
            output.append("=".repeat(60)).append("\n\n");
            output.append("| æ¬„ä½åç¨± | è³‡æ–™å‹åˆ¥ | å¯ç‚ºç©º | é è¨­å€¼ |\n");
            output.append("| --- | --- | --- | --- |\n");
            
            boolean hasResults = false;
            while (rs.next()) {
                hasResults = true;
                String dataType = rs.getString("data_type");
                Integer maxLen = rs.getObject("character_maximum_length", Integer.class);
                if (maxLen != null) {
                    dataType += "(" + maxLen + ")";
                }
                
                output.append("| ").append(rs.getString("column_name"))
                      .append(" | ").append(dataType)
                      .append(" | ").append(rs.getString("is_nullable"))
                      .append(" | ").append(rs.getString("column_default") != null ? rs.getString("column_default") : "-")
                      .append(" |\n");
            }
            
            if (!hasResults) {
                return CallToolResult.error("è³‡æ–™è¡¨ '" + tableName + "' ä¸å­˜åœ¨");
            }
            
            return CallToolResult.text(output.toString());
        }
    }
    
    private CallToolResult handleQuery(Map<String, Object> args) throws SQLException {
        String sql = (String) args.get("sql");
        int limit = Math.min(((Number) args.getOrDefault("limit", 50)).intValue(), MAX_QUERY_ROWS);
        
        // å®‰å…¨æª¢æŸ¥
        SafeQueryResult safeResult = isSafeQuery(sql);
        if (!safeResult.safe()) {
            return CallToolResult.error("æŸ¥è©¢è¢«æ‹’çµ•ï¼š" + safeResult.errorMessage());
        }
        
        // æ·»åŠ  LIMITï¼ˆå¦‚æœæ²’æœ‰ï¼‰
        if (!sql.toUpperCase().contains("LIMIT")) {
            sql = sql.replaceAll(";\\s*$", "") + " LIMIT " + limit;
        }
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.setQueryTimeout(QUERY_TIMEOUT);
            ResultSet rs = stmt.executeQuery(sql);
            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            // å–å¾—æ¬„ä½åç¨±
            List<String> columns = new ArrayList<>();
            for (int i = 1; i <= columnCount; i++) {
                columns.add(metaData.getColumnName(i));
            }
            
            // å»ºç«‹è¼¸å‡º
            StringBuilder output = new StringBuilder();
            List<List<String>> rows = new ArrayList<>();
            
            while (rs.next()) {
                List<String> row = new ArrayList<>();
                for (int i = 1; i <= columnCount; i++) {
                    Object value = rs.getObject(i);
                    String strValue = value != null ? value.toString() : "NULL";
                    if (strValue.length() > 50) {
                        strValue = strValue.substring(0, 50) + "...";
                    }
                    row.add(strValue);
                }
                rows.add(row);
            }
            
            if (rows.isEmpty()) {
                return CallToolResult.text("æŸ¥è©¢ç„¡çµæœ");
            }
            
            output.append("æŸ¥è©¢çµæœï¼ˆå…± ").append(rows.size()).append(" ç­†ï¼‰\n");
            output.append("=".repeat(50)).append("\n\n");
            output.append("| ").append(String.join(" | ", columns)).append(" |\n");
            output.append("| ").append(String.join(" | ", Collections.nCopies(columns.size(), "---"))).append(" |\n");
            
            for (List<String> row : rows) {
                output.append("| ").append(String.join(" | ", row)).append(" |\n");
            }
            
            return CallToolResult.text(output.toString());
        }
    }
    
    private CallToolResult handleTableSample(Map<String, Object> args) throws SQLException {
        String tableName = (String) args.get("table_name");
        int limit = Math.min(((Number) args.getOrDefault("limit", 5)).intValue(), 20);
        
        if (!tableName.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
            return CallToolResult.error("éŒ¯èª¤ï¼šç„¡æ•ˆçš„è³‡æ–™è¡¨åç¨±");
        }
        
        return handleQuery(Map.of(
            "sql", "SELECT * FROM " + tableName,
            "limit", limit
        ));
    }
    
    private CallToolResult handleTableStats(Map<String, Object> args) throws SQLException {
        String tableName = (String) args.get("table_name");
        
        if (!tableName.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
            return CallToolResult.error("éŒ¯èª¤ï¼šç„¡æ•ˆçš„è³‡æ–™è¡¨åç¨±");
        }
        
        try (Connection conn = dataSource.getConnection()) {
            // å–å¾—è¡Œæ•¸
            long rowCount;
            try (Statement stmt = conn.createStatement()) {
                ResultSet rs = stmt.executeQuery("SELECT count(*) FROM " + tableName);
                rs.next();
                rowCount = rs.getLong(1);
            }
            
            // å–å¾—è¡¨å¤§å°
            String sizeQuery = """
                SELECT 
                    pg_size_pretty(pg_total_relation_size(?)) as total_size,
                    pg_size_pretty(pg_relation_size(?)) as table_size,
                    pg_size_pretty(pg_indexes_size(?)) as index_size
                """;
            
            try (PreparedStatement stmt = conn.prepareStatement(sizeQuery)) {
                stmt.setString(1, tableName);
                stmt.setString(2, tableName);
                stmt.setString(3, tableName);
                ResultSet rs = stmt.executeQuery();
                rs.next();
                
                StringBuilder output = new StringBuilder();
                output.append("è³‡æ–™è¡¨çµ±è¨ˆï¼š").append(tableName).append("\n");
                output.append("=".repeat(40)).append("\n\n");
                output.append("ç¸½ç­†æ•¸ï¼š").append(String.format("%,d", rowCount)).append("\n");
                output.append("ç¸½å¤§å°ï¼š").append(rs.getString("total_size")).append("\n");
                output.append("è³‡æ–™å¤§å°ï¼š").append(rs.getString("table_size")).append("\n");
                output.append("ç´¢å¼•å¤§å°ï¼š").append(rs.getString("index_size")).append("\n");
                
                return CallToolResult.text(output.toString());
            }
        }
    }
    
    public void start() throws Exception {
        System.err.println("Database MCP Server å•Ÿå‹•ä¸­...");
        System.err.println("è³‡æ–™åº«é€£æ¥æ± å·²åˆå§‹åŒ–");
        
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport);
    }
    
    public void close() {
        if (dataSource != null) {
            dataSource.close();
        }
    }
    
    public static void main(String[] args) throws Exception {
        DatabaseMcpServer server = new DatabaseMcpServer();
        Runtime.getRuntime().addShutdownHook(new Thread(server::close));
        server.start();
    }
}
```

#### 5.2.3 å®‰å…¨æ€§è€ƒé‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è³‡æ–™åº« Server å®‰å…¨æ¸…å–®                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  âœ“ åƒ…å…è¨± SELECT æŸ¥è©¢                                            â”‚
â”‚  âœ“ ç¦æ­¢å±éšªé—œéµå­—ï¼ˆDROPã€DELETEã€UPDATE ç­‰ï¼‰                       â”‚
â”‚  âœ“ ç¦æ­¢å¤šèªå¥æŸ¥è©¢                                                â”‚
â”‚  âœ“ æŸ¥è©¢çµæœæ•¸é‡é™åˆ¶                                              â”‚
â”‚  âœ“ æŸ¥è©¢è¶…æ™‚è¨­å®š                                                  â”‚
â”‚  âœ“ è³‡æ–™è¡¨åç¨±é©—è­‰                                                â”‚
â”‚  âœ“ ä½¿ç”¨é€£æ¥æ± ç®¡ç†                                                â”‚
â”‚  âœ“ æ•æ„Ÿè³‡è¨Šä¸è¼¸å‡ºåˆ°æ—¥èªŒ                                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 5.3 ç¯„ä¾‹ä¸‰ï¼šAPI æ•´åˆ MCP Server

#### 5.3.1 åŠŸèƒ½èªªæ˜

æ•´åˆ GitHub API æä¾›ï¼š
- æœå°‹å„²å­˜åº«
- å–å¾—å„²å­˜åº«è³‡è¨Š
- åˆ—å‡º Issues
- è®€å–æª”æ¡ˆå…§å®¹

#### 5.3.2 å®Œæ•´ç¨‹å¼ç¢¼

**pom.xml**ï¼ˆGitHub Serverï¼‰ï¼š
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example.mcp</groupId>
    <artifactId>github-mcp-server</artifactId>
    <version>1.0.0</version>
    
    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>io.modelcontextprotocol</groupId>
            <artifactId>mcp-server</artifactId>
            <version>1.0.0</version>
        </dependency>
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.10.1</version>
        </dependency>
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>4.12.0</version>
        </dependency>
    </dependencies>
</project>
```

**GitHubMcpServer.java**ï¼š
```java
package com.example.mcp.github;

import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerOptions;
import io.modelcontextprotocol.server.transport.StdioServerTransport;
import io.modelcontextprotocol.spec.*;

import com.google.gson.*;
import okhttp3.*;

import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.*;

/**
 * GitHub API æ•´åˆ MCP Server
 */
public class GitHubMcpServer {
    
    private final McpServer server;
    private final OkHttpClient httpClient;
    private final Gson gson;
    
    // GitHub API é…ç½®
    private static final String GITHUB_API_BASE = "https://api.github.com";
    private static final String GITHUB_TOKEN = System.getenv("GITHUB_TOKEN");
    
    // é€Ÿç‡é™åˆ¶è¿½è¹¤
    private volatile int rateLimitRemaining = 60;
    private volatile Instant rateLimitReset = null;
    
    public GitHubMcpServer() {
        this.httpClient = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build();
        this.gson = new GsonBuilder().create();
        
        // å»ºç«‹ Server
        McpServerOptions options = McpServerOptions.builder()
            .serverInfo(ServerInfo.builder()
                .name("github-server")
                .version("1.0.0")
                .build())
            .capabilities(ServerCapabilities.builder()
                .tools(ToolsCapability.builder().build())
                .build())
            .build();
        
        this.server = new McpServer(options);
        setupHandlers();
    }
    
    /**
     * GitHub API éŒ¯èª¤
     */
    public static class GitHubAPIException extends Exception {
        private final int status;
        
        public GitHubAPIException(int status, String message) {
            super("GitHub API Error (" + status + "): " + message);
            this.status = status;
        }
        
        public int getStatus() { return status; }
    }
    
    /**
     * ç™¼é€ GitHub API è«‹æ±‚
     */
    private JsonObject githubRequest(String method, String endpoint, Map<String, String> params) 
            throws IOException, GitHubAPIException {
        
        HttpUrl.Builder urlBuilder = HttpUrl.parse(GITHUB_API_BASE + endpoint).newBuilder();
        if (params != null) {
            params.forEach(urlBuilder::addQueryParameter);
        }
        
        Request.Builder requestBuilder = new Request.Builder()
            .url(urlBuilder.build())
            .header("Accept", "application/vnd.github.v3+json")
            .header("User-Agent", "MCP-GitHub-Server/1.0");
        
        if (GITHUB_TOKEN != null && !GITHUB_TOKEN.isEmpty()) {
            requestBuilder.header("Authorization", "token " + GITHUB_TOKEN);
        }
        
        if ("GET".equals(method)) {
            requestBuilder.get();
        }
        
        try (Response response = httpClient.newCall(requestBuilder.build()).execute()) {
            // æ›´æ–°é€Ÿç‡é™åˆ¶
            String remaining = response.header("X-RateLimit-Remaining");
            String reset = response.header("X-RateLimit-Reset");
            if (remaining != null) {
                rateLimitRemaining = Integer.parseInt(remaining);
            }
            if (reset != null) {
                rateLimitReset = Instant.ofEpochSecond(Long.parseLong(reset));
            }
            
            if (response.code() == 401) {
                throw new GitHubAPIException(401, "èªè­‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥ GITHUB_TOKEN");
            } else if (response.code() == 403) {
                throw new GitHubAPIException(403, "å­˜å–è¢«æ‹’çµ•æˆ–å·²é”é€Ÿç‡é™åˆ¶ï¼ˆå‰©é¤˜ï¼š" + rateLimitRemaining + "ï¼‰");
            } else if (response.code() == 404) {
                throw new GitHubAPIException(404, "æ‰¾ä¸åˆ°è³‡æº");
            } else if (response.code() >= 400) {
                throw new GitHubAPIException(response.code(), response.body().string());
            }
            
            String body = response.body().string();
            return JsonParser.parseString(body).getAsJsonObject();
        }
    }
    
    private JsonArray githubRequestArray(String method, String endpoint, Map<String, String> params) 
            throws IOException, GitHubAPIException {
        
        HttpUrl.Builder urlBuilder = HttpUrl.parse(GITHUB_API_BASE + endpoint).newBuilder();
        if (params != null) {
            params.forEach(urlBuilder::addQueryParameter);
        }
        
        Request.Builder requestBuilder = new Request.Builder()
            .url(urlBuilder.build())
            .header("Accept", "application/vnd.github.v3+json")
            .header("User-Agent", "MCP-GitHub-Server/1.0");
        
        if (GITHUB_TOKEN != null && !GITHUB_TOKEN.isEmpty()) {
            requestBuilder.header("Authorization", "token " + GITHUB_TOKEN);
        }
        
        try (Response response = httpClient.newCall(requestBuilder.build()).execute()) {
            if (response.code() >= 400) {
                throw new GitHubAPIException(response.code(), response.body().string());
            }
            return JsonParser.parseString(response.body().string()).getAsJsonArray();
        }
    }
    
    private void setupHandlers() {
        // å·¥å…·åˆ—è¡¨è™•ç†å™¨
        server.setToolListHandler(request -> CompletableFuture.supplyAsync(() ->
            ListToolsResult.builder()
                .tools(List.of(
                    Tool.builder()
                        .name("search_repositories")
                        .description("æœå°‹ GitHub å„²å­˜åº«")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "query", Map.of("type", "string", "description", "æœå°‹é—œéµå­—"),
                                "language", Map.of("type", "string", "description", "ç¨‹å¼èªè¨€éæ¿¾"),
                                "sort", Map.of("type", "string", "enum", List.of("stars", "forks", "updated"), "default", "stars"),
                                "limit", Map.of("type", "integer", "description", "çµæœæ•¸é‡", "default", 10)
                            ),
                            "required", List.of("query")
                        ))
                        .build(),
                    Tool.builder()
                        .name("get_repository")
                        .description("å–å¾—å„²å­˜åº«è©³ç´°è³‡è¨Š")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "owner", Map.of("type", "string", "description", "æ“æœ‰è€…åç¨±"),
                                "repo", Map.of("type", "string", "description", "å„²å­˜åº«åç¨±")
                            ),
                            "required", List.of("owner", "repo")
                        ))
                        .build(),
                    Tool.builder()
                        .name("list_issues")
                        .description("åˆ—å‡ºå„²å­˜åº«çš„ Issues")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "owner", Map.of("type", "string", "description", "æ“æœ‰è€…åç¨±"),
                                "repo", Map.of("type", "string", "description", "å„²å­˜åº«åç¨±"),
                                "state", Map.of("type", "string", "enum", List.of("open", "closed", "all"), "default", "open"),
                                "limit", Map.of("type", "integer", "default", 10)
                            ),
                            "required", List.of("owner", "repo")
                        ))
                        .build(),
                    Tool.builder()
                        .name("get_file_content")
                        .description("å–å¾—å„²å­˜åº«ä¸­çš„æª”æ¡ˆå…§å®¹")
                        .inputSchema(Map.of(
                            "type", "object",
                            "properties", Map.of(
                                "owner", Map.of("type", "string"),
                                "repo", Map.of("type", "string"),
                                "path", Map.of("type", "string", "description", "æª”æ¡ˆè·¯å¾‘"),
                                "ref", Map.of("type", "string", "description", "åˆ†æ”¯æˆ– commit", "default", "main")
                            ),
                            "required", List.of("owner", "repo", "path")
                        ))
                        .build(),
                    Tool.builder()
                        .name("get_rate_limit")
                        .description("å–å¾— GitHub API é€Ÿç‡é™åˆ¶ç‹€æ…‹")
                        .inputSchema(Map.of("type", "object", "properties", Map.of()))
                        .build()
                ))
                .build()
        ));
        
        // å·¥å…·å‘¼å«è™•ç†å™¨
        server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
            String name = request.getParams().getName();
            Map<String, Object> args = request.getParams().getArguments();
            
            try {
                return switch (name) {
                    case "search_repositories" -> handleSearchRepos(args);
                    case "get_repository" -> handleGetRepo(args);
                    case "list_issues" -> handleListIssues(args);
                    case "get_file_content" -> handleGetFile(args);
                    case "get_rate_limit" -> handleRateLimit();
                    default -> CallToolResult.error("æœªçŸ¥çš„å·¥å…·ï¼š" + name);
                };
            } catch (GitHubAPIException e) {
                return CallToolResult.error("GitHub API éŒ¯èª¤ï¼š" + e.getMessage());
            } catch (Exception e) {
                return CallToolResult.error("éŒ¯èª¤ï¼š" + e.getMessage());
            }
        }));
    }
    
    private CallToolResult handleSearchRepos(Map<String, Object> args) throws Exception {
        String query = (String) args.get("query");
        String language = (String) args.get("language");
        String sort = (String) args.getOrDefault("sort", "stars");
        int limit = Math.min(((Number) args.getOrDefault("limit", 10)).intValue(), 30);
        
        String searchQuery = query;
        if (language != null && !language.isEmpty()) {
            searchQuery += " language:" + language;
        }
        
        JsonObject data = githubRequest("GET", "/search/repositories", Map.of(
            "q", searchQuery,
            "sort", sort,
            "per_page", String.valueOf(limit)
        ));
        
        JsonArray repos = data.getAsJsonArray("items");
        
        if (repos == null || repos.isEmpty()) {
            return CallToolResult.text("æ‰¾ä¸åˆ°ç¬¦åˆæ¢ä»¶çš„å„²å­˜åº«");
        }
        
        StringBuilder output = new StringBuilder();
        output.append("æœå°‹çµæœï¼š'").append(query).append("'\n");
        output.append("=".repeat(50)).append("\n\n");
        
        for (JsonElement item : repos) {
            JsonObject repo = item.getAsJsonObject();
            output.append("### ").append(repo.get("full_name").getAsString()).append("\n");
            output.append("â­ ").append(String.format("%,d", repo.get("stargazers_count").getAsInt())).append(" | ");
            output.append("ğŸ´ ").append(String.format("%,d", repo.get("forks_count").getAsInt())).append(" | ");
            output.append("ğŸ“ ").append(repo.get("language").isJsonNull() ? "N/A" : repo.get("language").getAsString()).append("\n");
            output.append(repo.get("description").isJsonNull() ? "ç„¡æè¿°" : repo.get("description").getAsString()).append("\n");
            output.append("ğŸ”— ").append(repo.get("html_url").getAsString()).append("\n\n");
        }
        
        return CallToolResult.text(output.toString());
    }
    
    private CallToolResult handleGetRepo(Map<String, Object> args) throws Exception {
        String owner = (String) args.get("owner");
        String repo = (String) args.get("repo");
        
        JsonObject data = githubRequest("GET", "/repos/" + owner + "/" + repo, null);
        
        StringBuilder output = new StringBuilder();
        output.append("# ").append(data.get("full_name").getAsString()).append("\n\n");
        output.append("**æè¿°**ï¼š").append(data.get("description").isJsonNull() ? "ç„¡æè¿°" : data.get("description").getAsString()).append("\n\n");
        output.append("## çµ±è¨ˆ\n");
        output.append("- â­ Starsï¼š").append(String.format("%,d", data.get("stargazers_count").getAsInt())).append("\n");
        output.append("- ğŸ´ Forksï¼š").append(String.format("%,d", data.get("forks_count").getAsInt())).append("\n");
        output.append("- ğŸ‘ Watchersï¼š").append(String.format("%,d", data.get("watchers_count").getAsInt())).append("\n");
        output.append("- ğŸ“ Open Issuesï¼š").append(String.format("%,d", data.get("open_issues_count").getAsInt())).append("\n\n");
        output.append("## è³‡è¨Š\n");
        output.append("- ç¨‹å¼èªè¨€ï¼š").append(data.get("language").isJsonNull() ? "N/A" : data.get("language").getAsString()).append("\n");
        output.append("- é è¨­åˆ†æ”¯ï¼š").append(data.get("default_branch").getAsString()).append("\n");
        output.append("- å»ºç«‹æ™‚é–“ï¼š").append(data.get("created_at").getAsString().substring(0, 10)).append("\n");
        output.append("- æœ€å¾Œæ›´æ–°ï¼š").append(data.get("updated_at").getAsString().substring(0, 10)).append("\n");
        
        JsonElement license = data.get("license");
        output.append("- æˆæ¬Šï¼š").append(license.isJsonNull() ? "N/A" : license.getAsJsonObject().get("name").getAsString()).append("\n\n");
        output.append("ğŸ”— **é€£çµ**ï¼š").append(data.get("html_url").getAsString()).append("\n");
        
        return CallToolResult.text(output.toString());
    }
    
    private CallToolResult handleListIssues(Map<String, Object> args) throws Exception {
        String owner = (String) args.get("owner");
        String repo = (String) args.get("repo");
        String state = (String) args.getOrDefault("state", "open");
        int limit = Math.min(((Number) args.getOrDefault("limit", 10)).intValue(), 30);
        
        JsonArray data = githubRequestArray("GET", "/repos/" + owner + "/" + repo + "/issues", 
            Map.of("state", state, "per_page", String.valueOf(limit)));
        
        if (data.isEmpty()) {
            return CallToolResult.text("æ²’æœ‰ " + state + " ç‹€æ…‹çš„ Issues");
        }
        
        StringBuilder output = new StringBuilder();
        output.append("Issues (").append(state).append(") - ").append(owner).append("/").append(repo).append("\n");
        output.append("=".repeat(50)).append("\n\n");
        
        for (JsonElement item : data) {
            JsonObject issue = item.getAsJsonObject();
            
            // æ’é™¤ Pull Requests
            if (issue.has("pull_request")) continue;
            
            JsonArray labels = issue.getAsJsonArray("labels");
            String labelStr = labels.isEmpty() ? "ç„¡æ¨™ç±¤" : 
                labels.asList().stream()
                    .map(l -> l.getAsJsonObject().get("name").getAsString())
                    .reduce((a, b) -> a + ", " + b)
                    .orElse("ç„¡æ¨™ç±¤");
            
            output.append("### #").append(issue.get("number").getAsInt())
                  .append(" ").append(issue.get("title").getAsString()).append("\n");
            output.append("ç‹€æ…‹ï¼š").append(issue.get("state").getAsString())
                  .append(" | æ¨™ç±¤ï¼š").append(labelStr).append("\n");
            output.append("ä½œè€…ï¼š").append(issue.getAsJsonObject("user").get("login").getAsString())
                  .append(" | å»ºç«‹æ–¼ï¼š").append(issue.get("created_at").getAsString().substring(0, 10)).append("\n");
            output.append("ğŸ”— ").append(issue.get("html_url").getAsString()).append("\n\n");
        }
        
        return CallToolResult.text(output.toString());
    }
    
    private CallToolResult handleGetFile(Map<String, Object> args) throws Exception {
        String owner = (String) args.get("owner");
        String repo = (String) args.get("repo");
        String path = (String) args.get("path");
        String ref = (String) args.getOrDefault("ref", "main");
        
        JsonObject data = githubRequest("GET", 
            "/repos/" + owner + "/" + repo + "/contents/" + path,
            Map.of("ref", ref));
        
        if (!"file".equals(data.get("type").getAsString())) {
            return CallToolResult.error("æŒ‡å®šè·¯å¾‘ä¸æ˜¯æª”æ¡ˆ");
        }
        
        int size = data.get("size").getAsInt();
        if (size > 1024 * 1024) {
            return CallToolResult.error("æª”æ¡ˆéå¤§ï¼Œç„¡æ³•é¡¯ç¤º");
        }
        
        String content = new String(Base64.getDecoder().decode(
            data.get("content").getAsString().replaceAll("\\s", "")));
        
        StringBuilder output = new StringBuilder();
        output.append("æª”æ¡ˆï¼š").append(path).append(" (ref: ").append(ref).append(")\n");
        output.append("=".repeat(50)).append("\n\n");
        output.append("```\n").append(content).append("\n```");
        
        return CallToolResult.text(output.toString());
    }
    
    private CallToolResult handleRateLimit() throws Exception {
        JsonObject data = githubRequest("GET", "/rate_limit", null);
        
        JsonObject core = data.getAsJsonObject("resources").getAsJsonObject("core");
        JsonObject search = data.getAsJsonObject("resources").getAsJsonObject("search");
        
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
            .withZone(ZoneId.systemDefault());
        Instant resetTime = Instant.ofEpochSecond(core.get("reset").getAsLong());
        
        StringBuilder output = new StringBuilder();
        output.append("GitHub API é€Ÿç‡é™åˆ¶ç‹€æ…‹\n");
        output.append("=".repeat(40)).append("\n\n");
        output.append("## Core API\n");
        output.append("- å‰©é¤˜ï¼š").append(core.get("remaining").getAsInt())
              .append("/").append(core.get("limit").getAsInt()).append("\n");
        output.append("- é‡ç½®æ™‚é–“ï¼š").append(formatter.format(resetTime)).append("\n\n");
        output.append("## Search API\n");
        output.append("- å‰©é¤˜ï¼š").append(search.get("remaining").getAsInt())
              .append("/").append(search.get("limit").getAsInt()).append("\n");
        
        return CallToolResult.text(output.toString());
    }
    
    public void start() throws Exception {
        System.err.println("GitHub MCP Server å•Ÿå‹•ä¸­...");
        
        if (GITHUB_TOKEN == null || GITHUB_TOKEN.isEmpty()) {
            System.err.println("è­¦å‘Šï¼šæœªè¨­å®š GITHUB_TOKENï¼Œå°‡ä½¿ç”¨è¼ƒä½çš„é€Ÿç‡é™åˆ¶");
        }
        
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport);
    }
    
    public static void main(String[] args) throws Exception {
        GitHubMcpServer server = new GitHubMcpServer();
        server.start();
    }
}
```

#### 5.3.3 éŒ¯èª¤è™•ç†èˆ‡é‡è©¦æ©Ÿåˆ¶

```java
/**
 * å¢å¼·ç‰ˆ API è«‹æ±‚è™•ç†ï¼ˆå«é‡è©¦æ©Ÿåˆ¶ï¼‰
 * RetryableGitHubClient.java
 */
package com.example.mcp.github;

import java.util.concurrent.*;
import java.util.function.Supplier;

public class RetryableGitHubClient {
    
    private final int maxRetries;
    private final double backoffFactor;
    
    public RetryableGitHubClient(int maxRetries, double backoffFactor) {
        this.maxRetries = maxRetries;
        this.backoffFactor = backoffFactor;
    }
    
    /**
     * å¸¶é‡è©¦æ©Ÿåˆ¶çš„è«‹æ±‚åŸ·è¡Œ
     */
    public <T> T executeWithRetry(Supplier<T> action) throws Exception {
        Exception lastException = null;
        
        for (int attempt = 0; attempt < maxRetries; attempt++) {
            try {
                return action.get();
            } catch (GitHubMcpServer.GitHubAPIException e) {
                // ä¸é‡è©¦çš„éŒ¯èª¤
                if (e.getStatus() == 401 || e.getStatus() == 403 || e.getStatus() == 404) {
                    throw e;
                }
                lastException = e;
            } catch (Exception e) {
                lastException = e;
            }
            
            // è¨ˆç®—ç­‰å¾…æ™‚é–“ï¼ˆæŒ‡æ•¸é€€é¿ï¼‰
            long waitTime = (long) (backoffFactor * Math.pow(2, attempt) * 1000);
            try {
                Thread.sleep(waitTime);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
                throw new RuntimeException("é‡è©¦è¢«ä¸­æ–·", ie);
            }
        }
        
        throw new RuntimeException("é‡è©¦æ¬¡æ•¸å·²é”ä¸Šé™", lastException);
    }
    
    /**
     * éåŒæ­¥ç‰ˆæœ¬
     */
    public <T> CompletableFuture<T> executeWithRetryAsync(Supplier<T> action) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return executeWithRetry(action);
            } catch (Exception e) {
                throw new CompletionException(e);
            }
        });
    }
}
```

---

*ï¼ˆç¬¬äº”ç« å®Œçµï¼Œç¹¼çºŒç¬¬å…­ç« ï¼‰*

---

## ç¬¬å…­ç« ï¼šæœ€ä½³å¯¦è¸èˆ‡è¨­è¨ˆæ¨¡å¼

### 6.1 MCP Server è¨­è¨ˆåŸå‰‡

#### 6.1.1 å–®ä¸€è·è²¬åŸå‰‡

æ¯å€‹ MCP Server æ‡‰è©²å°ˆæ³¨æ–¼ä¸€å€‹é ˜åŸŸæˆ–åŠŸèƒ½é›†ï¼š

```
âœ… å¥½çš„è¨­è¨ˆï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Filesystem      â”‚  â”‚ Database        â”‚  â”‚ GitHub          â”‚
â”‚ Server          â”‚  â”‚ Server          â”‚  â”‚ Server          â”‚
â”‚                 â”‚  â”‚                 â”‚  â”‚                 â”‚
â”‚ - read_file     â”‚  â”‚ - query         â”‚  â”‚ - search_repos  â”‚
â”‚ - write_file    â”‚  â”‚ - list_tables   â”‚  â”‚ - get_issues    â”‚
â”‚ - list_dir      â”‚  â”‚ - describe      â”‚  â”‚ - get_commits   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ ä¸å¥½çš„è¨­è¨ˆï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Everything Server                        â”‚
â”‚                                                            â”‚
â”‚ - read_file, write_file, query_db, search_github,         â”‚
â”‚   send_email, parse_json, encrypt_data, ...               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 6.1.2 å·¥å…·å‘½åè¦ç¯„

| è¦ç¯„ | èªªæ˜ | å¥½çš„ç¯„ä¾‹ | ä¸å¥½çš„ç¯„ä¾‹ |
|------|------|---------|-----------|
| **å‹•è©é–‹é ­** | æ˜ç¢ºè¡¨é”å‹•ä½œ | `read_file`, `create_user` | `file`, `user` |
| **snake_case** | ä½¿ç”¨åº•ç·šåˆ†éš” | `list_directory` | `listDirectory` |
| **å…·é«”æè¿°** | é¿å…æ¨¡ç³Šåç¨± | `search_by_name` | `search` |
| **ä¸€è‡´æ€§** | åŒé¡å·¥å…·çµ±ä¸€å‰ç¶´ | `db_query`, `db_insert` | `query`, `insert_record` |

**å‘½åæ¨¡æ¿**ï¼š

```
{action}_{target}[_{qualifier}]

ç¯„ä¾‹ï¼š
- read_file          # å‹•ä½œ + ç›®æ¨™
- search_users_by_name  # å‹•ä½œ + ç›®æ¨™ + é™å®šè©
- list_active_orders   # å‹•ä½œ + ä¿®é£¾è© + ç›®æ¨™
```

#### 6.1.3 åƒæ•¸è¨­è¨ˆèˆ‡é©—è­‰

**å¥½çš„åƒæ•¸è¨­è¨ˆ**ï¼š

```java
Tool.builder()
    .name("search_records")
    .description("æœå°‹è³‡æ–™åº«è¨˜éŒ„")
    .inputSchema(Map.of(
        "type", "object",
        "properties", Map.of(
            // å¿…å¡«åƒæ•¸æ”¾å‰é¢
            "table", Map.of(
                "type", "string",
                "description", "è³‡æ–™è¡¨åç¨±",
                "pattern", "^[a-zA-Z_][a-zA-Z0-9_]*$"  // æ­£å‰‡é©—è­‰
            ),
            "query", Map.of(
                "type", "string",
                "description", "æœå°‹é—œéµå­—",
                "minLength", 1,
                "maxLength", 100
            ),
            // é¸å¡«åƒæ•¸æœ‰é è¨­å€¼
            "limit", Map.of(
                "type", "integer",
                "description", "çµæœæ•¸é‡é™åˆ¶ï¼ˆ1-100ï¼‰",
                "default", 20,
                "minimum", 1,
                "maximum", 100
            ),
            "offset", Map.of(
                "type", "integer",
                "description", "è·³éçš„è¨˜éŒ„æ•¸",
                "default", 0,
                "minimum", 0
            ),
            "sort_by", Map.of(
                "type", "string",
                "description", "æ’åºæ¬„ä½",
                "enum", List.of("created_at", "updated_at", "name")
            ),
            "sort_order", Map.of(
                "type", "string",
                "description", "æ’åºæ–¹å‘",
                "enum", List.of("asc", "desc"),
                "default", "desc"
            )
        ),
        "required", List.of("table", "query"),
        "additionalProperties", false  // ç¦æ­¢é¡å¤–åƒæ•¸
    ))
    .build()
```

**åƒæ•¸é©—è­‰å¯¦ä½œ**ï¼š

```java
import com.networknt.schema.*;
import com.fasterxml.jackson.databind.*;

/**
 * å·¥å…·åƒæ•¸é©—è­‰å™¨
 */
public class ArgumentValidator {
    
    private final JsonSchemaFactory schemaFactory;
    private final ObjectMapper objectMapper;
    
    public ArgumentValidator() {
        this.schemaFactory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);
        this.objectMapper = new ObjectMapper();
    }
    
    /**
     * é©—è­‰å·¥å…·åƒæ•¸
     */
    public ValidationResult validate(Map<String, Object> schema, Map<String, Object> arguments) {
        try {
            JsonSchema jsonSchema = schemaFactory.getSchema(
                objectMapper.writeValueAsString(schema)
            );
            
            JsonNode argumentsNode = objectMapper.valueToTree(arguments);
            Set<ValidationMessage> errors = jsonSchema.validate(argumentsNode);
            
            if (errors.isEmpty()) {
                return new ValidationResult(true, "");
            } else {
                String errorMsg = errors.stream()
                    .map(ValidationMessage::getMessage)
                    .reduce((a, b) -> a + "; " + b)
                    .orElse("é©—è­‰å¤±æ•—");
                return new ValidationResult(false, errorMsg);
            }
        } catch (Exception e) {
            return new ValidationResult(false, "Schema è™•ç†éŒ¯èª¤ï¼š" + e.getMessage());
        }
    }
    
    public record ValidationResult(boolean isValid, String error) {}
}

// åœ¨å·¥å…·è™•ç†å™¨ä¸­ä½¿ç”¨
server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
    String name = request.getParams().getName();
    Map<String, Object> arguments = request.getParams().getArguments();
    
    // å–å¾—å·¥å…·å®šç¾©
    Tool tool = findToolByName(name);
    if (tool == null) {
        return CallToolResult.error("æœªçŸ¥å·¥å…·ï¼š" + name);
    }
    
    // é©—è­‰åƒæ•¸
    ArgumentValidator validator = new ArgumentValidator();
    var result = validator.validate(tool.getInputSchema(), arguments);
    if (!result.isValid()) {
        return CallToolResult.error("åƒæ•¸é©—è­‰å¤±æ•—ï¼š" + result.error());
    }
    
    // è™•ç†å·¥å…·å‘¼å«...
    return handleToolCall(name, arguments);
}));
```

#### 6.1.4 éŒ¯èª¤è™•ç†æ¨™æº–

```java
/**
 * æ¨™æº–åŒ–éŒ¯èª¤è™•ç†æ¨¡å¼
 */
package com.example.mcp.error;

import io.modelcontextprotocol.spec.CallToolResult;
import java.util.*;
import java.util.function.Supplier;

/**
 * éŒ¯èª¤ä»£ç¢¼æšèˆ‰
 */
public enum ErrorCode {
    VALIDATION_ERROR("VALIDATION_ERROR"),
    NOT_FOUND("NOT_FOUND"),
    PERMISSION_DENIED("PERMISSION_DENIED"),
    RATE_LIMITED("RATE_LIMITED"),
    TIMEOUT("TIMEOUT"),
    INTERNAL_ERROR("INTERNAL_ERROR");
    
    private final String value;
    
    ErrorCode(String value) {
        this.value = value;
    }
    
    public String getValue() { return value; }
}

/**
 * å·¥å…·éŒ¯èª¤çµæ§‹
 */
public record ToolError(
    ErrorCode code,
    String message,
    Map<String, Object> details
) {
    public ToolError(ErrorCode code, String message) {
        this(code, message, null);
    }
    
    /**
     * è½‰æ›ç‚º CallToolResult
     */
    public CallToolResult toCallToolResult() {
        StringBuilder errorText = new StringBuilder();
        errorText.append("âŒ éŒ¯èª¤ [").append(code.getValue()).append("]\n");
        errorText.append("è¨Šæ¯ï¼š").append(message).append("\n");
        if (details != null && !details.isEmpty()) {
            errorText.append("è©³ç´°è³‡è¨Šï¼š").append(details).append("\n");
        }
        return CallToolResult.error(errorText.toString());
    }
}

/**
 * éŒ¯èª¤è™•ç†å·¥å…·é¡
 */
public class ToolErrorHandler {
    
    /**
     * åŒ…è£å·¥å…·åŸ·è¡Œï¼Œçµ±ä¸€è™•ç†éŒ¯èª¤
     */
    public static CallToolResult handleToolExecution(Supplier<CallToolResult> action) {
        try {
            return action.get();
        } catch (java.nio.file.NoSuchFileException e) {
            return new ToolError(ErrorCode.NOT_FOUND, e.getMessage()).toCallToolResult();
        } catch (java.nio.file.AccessDeniedException e) {
            return new ToolError(ErrorCode.PERMISSION_DENIED, e.getMessage()).toCallToolResult();
        } catch (java.util.concurrent.TimeoutException e) {
            return new ToolError(ErrorCode.TIMEOUT, "æ“ä½œè¶…æ™‚").toCallToolResult();
        } catch (Exception e) {
            return new ToolError(
                ErrorCode.INTERNAL_ERROR,
                "å…§éƒ¨éŒ¯èª¤",
                Map.of("exception", e.getMessage())
            ).toCallToolResult();
        }
    }
}

// ä½¿ç”¨ç¯„ä¾‹
server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> 
    ToolErrorHandler.handleToolExecution(() -> {
        String name = request.getParams().getName();
        return switch (name) {
            case "read_file" -> handleReadFile(request.getParams().getArguments());
            case "write_file" -> handleWriteFile(request.getParams().getArguments());
            default -> CallToolResult.error("æœªçŸ¥å·¥å…·ï¼š" + name);
        };
    })
));
```

---

### 6.2 æ•ˆèƒ½å„ªåŒ–

#### 6.2.1 é€£æ¥æ± ç®¡ç†

```java
/**
 * é€£æ¥æ± ç®¡ç†æœ€ä½³å¯¦è¸
 */
package com.example.mcp.pool;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.time.Duration;

/**
 * é€šç”¨é€£æ¥æ± ç®¡ç†å™¨ï¼ˆæŠ½è±¡é¡ï¼‰
 */
public abstract class ConnectionPool<T> implements AutoCloseable {
    
    private final int minSize;
    private final int maxSize;
    private final Duration timeout;
    
    private final BlockingQueue<T> pool;
    private final AtomicInteger currentSize;
    private final Object lock = new Object();
    private volatile boolean closed = false;
    
    protected ConnectionPool(int minSize, int maxSize, Duration timeout) {
        this.minSize = minSize;
        this.maxSize = maxSize;
        this.timeout = timeout;
        this.pool = new LinkedBlockingQueue<>(maxSize);
        this.currentSize = new AtomicInteger(0);
    }
    
    /**
     * åˆå§‹åŒ–é€£æ¥æ± 
     */
    public void initialize() throws Exception {
        for (int i = 0; i < minSize; i++) {
            T conn = createConnection();
            pool.put(conn);
            currentSize.incrementAndGet();
        }
    }
    
    /**
     * å»ºç«‹æ–°é€£æ¥ï¼ˆå­é¡å¯¦ä½œï¼‰
     */
    protected abstract T createConnection() throws Exception;
    
    /**
     * é©—è­‰é€£æ¥æ˜¯å¦æœ‰æ•ˆï¼ˆå­é¡å¯¦ä½œï¼‰
     */
    protected abstract boolean validateConnection(T conn);
    
    /**
     * é—œé–‰é€£æ¥ï¼ˆå­é¡å¯¦ä½œï¼‰
     */
    protected abstract void closeConnection(T conn);
    
    /**
     * å–å¾—é€£æ¥ï¼ˆtry-with-resources å‹å¥½ï¼‰
     */
    public PooledConnection<T> acquire() throws Exception {
        if (closed) {
            throw new IllegalStateException("é€£æ¥æ± å·²é—œé–‰");
        }
        
        T conn = null;
        
        // å˜—è©¦å¾æ± ä¸­å–å¾—é€£æ¥
        conn = pool.poll(timeout.toMillis(), TimeUnit.MILLISECONDS);
        
        if (conn == null) {
            // å¦‚æœæ²’æœ‰å¯ç”¨é€£æ¥ï¼Œå˜—è©¦å»ºç«‹æ–°çš„
            synchronized (lock) {
                if (currentSize.get() < maxSize) {
                    conn = createConnection();
                    currentSize.incrementAndGet();
                } else {
                    throw new TimeoutException("é€£æ¥æ± å·²æ»¿ï¼Œç„¡æ³•å–å¾—é€£æ¥");
                }
            }
        }
        
        // é©—è­‰é€£æ¥
        if (!validateConnection(conn)) {
            closeConnection(conn);
            currentSize.decrementAndGet();
            conn = createConnection();
            currentSize.incrementAndGet();
        }
        
        final T finalConn = conn;
        return new PooledConnection<>(finalConn, this::release);
    }
    
    /**
     * æ­¸é‚„é€£æ¥
     */
    private void release(T conn) {
        if (!closed && conn != null) {
            pool.offer(conn);
        }
    }
    
    @Override
    public void close() {
        closed = true;
        T conn;
        while ((conn = pool.poll()) != null) {
            closeConnection(conn);
            currentSize.decrementAndGet();
        }
    }
    
    /**
     * å¯é—œé–‰çš„é€£æ¥åŒ…è£å™¨
     */
    public static class PooledConnection<T> implements AutoCloseable {
        private final T connection;
        private final java.util.function.Consumer<T> releaser;
        private boolean released = false;
        
        PooledConnection(T connection, java.util.function.Consumer<T> releaser) {
            this.connection = connection;
            this.releaser = releaser;
        }
        
        public T get() { return connection; }
        
        @Override
        public void close() {
            if (!released) {
                released = true;
                releaser.accept(connection);
            }
        }
    }
}

/**
 * PostgreSQL é€£æ¥æ± å¯¦ä½œï¼ˆä½¿ç”¨ HikariCP æ›´ä½³ï¼‰
 */
public class PostgresPool extends ConnectionPool<java.sql.Connection> {
    
    private final String jdbcUrl;
    private final String username;
    private final String password;
    
    public PostgresPool(String jdbcUrl, String username, String password,
                        int minSize, int maxSize, Duration timeout) {
        super(minSize, maxSize, timeout);
        this.jdbcUrl = jdbcUrl;
        this.username = username;
        this.password = password;
    }
    
    @Override
    protected java.sql.Connection createConnection() throws Exception {
        return java.sql.DriverManager.getConnection(jdbcUrl, username, password);
    }
    
    @Override
    protected boolean validateConnection(java.sql.Connection conn) {
        try {
            return conn.isValid(5);
        } catch (Exception e) {
            return false;
        }
    }
    
    @Override
    protected void closeConnection(java.sql.Connection conn) {
        try {
            conn.close();
        } catch (Exception ignored) {}
    }
}
```

#### 6.2.2 å¿«å–ç­–ç•¥

```java
/**
 * å¿«å–ç­–ç•¥å¯¦ä½œ
 */
package com.example.mcp.cache;

import java.security.MessageDigest;
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Supplier;

/**
 * å¿«å–é …ç›®
 */
record CacheEntry<V>(V value, Instant expiresAt) {
    boolean isExpired() {
        return Instant.now().isAfter(expiresAt);
    }
}

/**
 * éåŒæ­¥å¿«å–
 */
public class AsyncCache<V> {
    
    private final Duration defaultTtl;
    private final int maxSize;
    private final ConcurrentHashMap<String, CacheEntry<V>> cache;
    private final ScheduledExecutorService cleanupExecutor;
    
    public AsyncCache(Duration defaultTtl, int maxSize) {
        this.defaultTtl = defaultTtl;
        this.maxSize = maxSize;
        this.cache = new ConcurrentHashMap<>();
        
        // å®šæœŸæ¸…ç†éæœŸé …ç›®
        this.cleanupExecutor = Executors.newSingleThreadScheduledExecutor();
        cleanupExecutor.scheduleAtFixedRate(
            this::cleanup, 
            1, 1, TimeUnit.MINUTES
        );
    }
    
    /**
     * ç”Ÿæˆå¿«å–éµ
     */
    public String makeKey(Object... parts) {
        try {
            String keyData = Arrays.toString(parts);
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] digest = md.digest(keyData.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte b : digest) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (Exception e) {
            return Arrays.toString(parts).hashCode() + "";
        }
    }
    
    /**
     * å–å¾—å¿«å–å€¼
     */
    public CompletableFuture<Optional<V>> get(String key) {
        return CompletableFuture.supplyAsync(() -> {
            CacheEntry<V> entry = cache.get(key);
            if (entry != null && !entry.isExpired()) {
                return Optional.of(entry.value());
            } else if (entry != null) {
                cache.remove(key);
            }
            return Optional.empty();
        });
    }
    
    /**
     * è¨­å®šå¿«å–å€¼
     */
    public CompletableFuture<Void> set(String key, V value, Duration ttl) {
        return CompletableFuture.runAsync(() -> {
            // æ¸…ç†éæœŸé …ç›®ï¼ˆå¦‚æœæ¥è¿‘ä¸Šé™ï¼‰
            if (cache.size() >= maxSize) {
                cleanup();
            }
            
            Instant expiresAt = Instant.now().plus(ttl != null ? ttl : defaultTtl);
            cache.put(key, new CacheEntry<>(value, expiresAt));
        });
    }
    
    public CompletableFuture<Void> set(String key, V value) {
        return set(key, value, null);
    }
    
    /**
     * æ¸…ç†éæœŸå¿«å–
     */
    private void cleanup() {
        Instant now = Instant.now();
        cache.entrySet().removeIf(entry -> entry.getValue().isExpired());
    }
    
    /**
     * é—œé–‰å¿«å–
     */
    public void close() {
        cleanupExecutor.shutdown();
        cache.clear();
    }
}

/**
 * å¸¶å¿«å–çš„å‡½æ•¸åŒ…è£å™¨
 */
public class CachedFunction<T> {
    
    private final AsyncCache<T> cache;
    private final Duration ttl;
    
    public CachedFunction(AsyncCache<T> cache, Duration ttl) {
        this.cache = cache;
        this.ttl = ttl;
    }
    
    /**
     * å¸¶å¿«å–åŸ·è¡Œå‡½æ•¸
     */
    public CompletableFuture<T> execute(
        Supplier<CompletableFuture<T>> function,
        Object... keyParts
    ) {
        String key = cache.makeKey(keyParts);
        
        return cache.get(key).thenCompose(cached -> {
            if (cached.isPresent()) {
                return CompletableFuture.completedFuture(cached.get());
            }
            
            return function.get().thenCompose(result -> 
                cache.set(key, result, ttl).thenApply(v -> result)
            );
        });
    }
}

// ä½¿ç”¨ç¯„ä¾‹
public class GitHubService {
    
    private final AsyncCache<Map<String, Object>> cache = 
        new AsyncCache<>(Duration.ofMinutes(5), 1000);
    private final CachedFunction<Map<String, Object>> cachedFunction = 
        new CachedFunction<>(cache, Duration.ofMinutes(1));
    
    /**
     * å–å¾—å„²å­˜åº«è³‡è¨Šï¼ˆå¸¶å¿«å–ï¼‰
     */
    public CompletableFuture<Map<String, Object>> getRepositoryInfo(String owner, String repo) {
        return cachedFunction.execute(
            () -> githubRequest("GET", "/repos/" + owner + "/" + repo),
            "getRepositoryInfo", owner, repo
        );
    }
}
```

#### 6.2.3 æ‰¹æ¬¡è™•ç†

```java
/**
 * æ‰¹æ¬¡è™•ç†æ¨¡å¼
 */
package com.example.mcp.batch;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.Function;
import java.util.stream.*;

public class BatchProcessor {
    
    /**
     * æ‰¹æ¬¡è™•ç†é …ç›®
     *
     * @param items è¦è™•ç†çš„é …ç›®åˆ—è¡¨
     * @param processor è™•ç†å‡½æ•¸
     * @param batchSize æ‰¹æ¬¡å¤§å°
     * @param delayBetweenBatches æ‰¹æ¬¡é–“å»¶é²
     * @return è™•ç†çµæœåˆ—è¡¨
     */
    public static <T, R> CompletableFuture<List<R>> batchProcess(
        List<T> items,
        Function<T, CompletableFuture<R>> processor,
        int batchSize,
        Duration delayBetweenBatches
    ) {
        if (items.isEmpty()) {
            return CompletableFuture.completedFuture(Collections.emptyList());
        }
        
        List<List<T>> batches = partition(items, batchSize);
        List<R> results = new CopyOnWriteArrayList<>();
        
        return processBatchesSequentially(batches, processor, delayBetweenBatches, results)
            .thenApply(v -> new ArrayList<>(results));
    }
    
    /**
     * åˆ†å‰²åˆ—è¡¨ç‚ºæ‰¹æ¬¡
     */
    private static <T> List<List<T>> partition(List<T> list, int size) {
        List<List<T>> partitions = new ArrayList<>();
        for (int i = 0; i < list.size(); i += size) {
            partitions.add(list.subList(i, Math.min(i + size, list.size())));
        }
        return partitions;
    }
    
    /**
     * é †åºè™•ç†æ‰¹æ¬¡
     */
    private static <T, R> CompletableFuture<Void> processBatchesSequentially(
        List<List<T>> batches,
        Function<T, CompletableFuture<R>> processor,
        Duration delay,
        List<R> results
    ) {
        CompletableFuture<Void> future = CompletableFuture.completedFuture(null);
        
        for (int i = 0; i < batches.size(); i++) {
            final List<T> batch = batches.get(i);
            final boolean isLastBatch = (i == batches.size() - 1);
            
            future = future.thenCompose(v -> {
                // ä¸¦è¡Œè™•ç†æ‰¹æ¬¡å…§çš„é …ç›®
                List<CompletableFuture<R>> futures = batch.stream()
                    .map(item -> processor.apply(item)
                        .exceptionally(e -> null))  // è™•ç†å–®é …éŒ¯èª¤
                    .collect(Collectors.toList());
                
                return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                    .thenRun(() -> {
                        futures.forEach(f -> {
                            try {
                                R result = f.get();
                                if (result != null) results.add(result);
                            } catch (Exception ignored) {}
                        });
                    });
            });
            
            // æ‰¹æ¬¡é–“å»¶é²ï¼ˆæœ€å¾Œä¸€æ‰¹ä¸å»¶é²ï¼‰
            if (!isLastBatch) {
                future = future.thenCompose(v -> 
                    CompletableFuture.runAsync(() -> {
                        try {
                            Thread.sleep(delay.toMillis());
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    })
                );
            }
        }
        
        return future;
    }
}

// ä½¿ç”¨ç¯„ä¾‹
public class FileProcessor {
    
    /**
     * æ‰¹æ¬¡è™•ç†æª”æ¡ˆ
     */
    public CompletableFuture<List<FileInfo>> processFiles(List<String> filePaths) {
        return BatchProcessor.batchProcess(
            filePaths,
            this::readAndAnalyze,
            10,                          // æ‰¹æ¬¡å¤§å°
            Duration.ofMillis(100)       // æ‰¹æ¬¡é–“å»¶é²
        );
    }
    
    private CompletableFuture<FileInfo> readAndAnalyze(String path) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                String content = java.nio.file.Files.readString(java.nio.file.Path.of(path));
                return new FileInfo(
                    path,
                    content.length(),
                    content.lines().count()
                );
            } catch (Exception e) {
                return null;
            }
        });
    }
    
    public record FileInfo(String path, long size, long lines) {}
}
```

---

### 6.3 å®‰å…¨æ€§è€ƒé‡

#### 6.3.1 èªè­‰èˆ‡æˆæ¬Š

```java
/**
 * èªè­‰æˆæ¬Šæ¨¡å¼
 */
package com.example.mcp.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;

import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.time.*;
import java.util.*;

/**
 * èªè­‰éŒ¯èª¤
 */
public class AuthError extends Exception {
    public AuthError(String message) {
        super(message);
    }
}

/**
 * JWT Token ç®¡ç†å™¨
 */
public class TokenManager {
    
    private final Key secretKey;
    private final Duration tokenExpiry;
    
    public TokenManager(String secret, Duration tokenExpiry) {
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
        this.tokenExpiry = tokenExpiry;
    }
    
    public TokenManager() {
        this(
            System.getenv().getOrDefault("MCP_SECRET_KEY", "change-me-in-production-with-at-least-32-chars"),
            Duration.ofHours(24)
        );
    }
    
    /**
     * ç”Ÿæˆ JWT Token
     */
    public String generateToken(String userId, List<String> permissions) {
        Instant now = Instant.now();
        
        return Jwts.builder()
            .setSubject(userId)
            .claim("permissions", permissions)
            .setIssuedAt(Date.from(now))
            .setExpiration(Date.from(now.plus(tokenExpiry)))
            .signWith(secretKey, SignatureAlgorithm.HS256)
            .compact();
    }
    
    /**
     * é©—è­‰ JWT Token
     */
    public TokenPayload verifyToken(String token) throws AuthError {
        try {
            Claims claims = Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();
            
            @SuppressWarnings("unchecked")
            List<String> permissions = claims.get("permissions", List.class);
            
            return new TokenPayload(
                claims.getSubject(),
                permissions != null ? permissions : List.of(),
                claims.getIssuedAt().toInstant(),
                claims.getExpiration().toInstant()
            );
        } catch (ExpiredJwtException e) {
            throw new AuthError("Token å·²éæœŸ");
        } catch (JwtException e) {
            throw new AuthError("ç„¡æ•ˆçš„ Token");
        }
    }
    
    public record TokenPayload(
        String userId,
        List<String> permissions,
        Instant issuedAt,
        Instant expiresAt
    ) {}
}

/**
 * æ¬Šé™æª¢æŸ¥å™¨
 */
public class PermissionChecker {
    
    private final TokenManager tokenManager;
    
    // å·¥å…·å±¤ç´šæ¬Šé™å°æ‡‰
    private static final Map<String, List<String>> TOOL_PERMISSIONS = Map.of(
        "read_file", List.of("file:read"),
        "write_file", List.of("file:write"),
        "delete_file", List.of("file:delete"),
        "query", List.of("db:read"),
        "execute", List.of("db:write")
    );
    
    public PermissionChecker(TokenManager tokenManager) {
        this.tokenManager = tokenManager;
    }
    
    /**
     * æª¢æŸ¥å·¥å…·æ¬Šé™
     */
    public void checkToolPermission(String toolName, String token) throws AuthError {
        if (token == null || token.isEmpty()) {
            throw new AuthError("éœ€è¦èªè­‰");
        }
        
        TokenManager.TokenPayload payload = tokenManager.verifyToken(token);
        List<String> requiredPermissions = TOOL_PERMISSIONS.getOrDefault(toolName, List.of());
        
        for (String perm : requiredPermissions) {
            if (!payload.permissions().contains(perm)) {
                throw new AuthError("ç¼ºå°‘æ¬Šé™ï¼š" + perm);
            }
        }
    }
}

// åœ¨å·¥å…·è™•ç†å™¨ä¸­ä½¿ç”¨
server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
    String name = request.getParams().getName();
    String authToken = getAuthTokenFromContext();  // å¾ context å–å¾—
    
    try {
        permissionChecker.checkToolPermission(name, authToken);
    } catch (AuthError e) {
        return CallToolResult.error("æ¬Šé™ä¸è¶³ï¼š" + e.getMessage());
    }
    
    // åŸ·è¡Œå·¥å…·...
    return handleToolCall(name, request.getParams().getArguments());
}));
```

#### 6.3.2 è¼¸å…¥é©—è­‰

```java
/**
 * è¼¸å…¥é©—è­‰æ¨¡å¼
 */
package com.example.mcp.security;

import java.nio.file.Path;
import java.util.List;
import java.util.regex.*;

/**
 * è¼¸å…¥é©—è­‰å™¨
 */
public class InputValidator {
    
    /**
     * æ¸…ç†å­—ä¸²
     */
    public static String sanitizeString(String value, int maxLength) {
        if (value == null) return "";
        
        // æˆªæ–·é•·åº¦
        String result = value.length() > maxLength ? value.substring(0, maxLength) : value;
        
        // HTML ç·¨ç¢¼
        return result
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#x27;");
    }
    
    public static String sanitizeString(String value) {
        return sanitizeString(value, 1000);
    }
    
    /**
     * é©—è­‰è·¯å¾‘å®‰å…¨æ€§
     */
    public static ValidationResult validatePath(String pathStr, List<String> allowedRoots) {
        try {
            Path resolved = Path.of(pathStr).toAbsolutePath().normalize();
            
            // æª¢æŸ¥è·¯å¾‘éæ­·
            for (String root : allowedRoots) {
                Path rootPath = Path.of(root).toAbsolutePath().normalize();
                if (resolved.startsWith(rootPath)) {
                    return new ValidationResult(true, resolved.toString());
                }
            }
            
            return new ValidationResult(false, "è·¯å¾‘ä¸åœ¨å…è¨±ç¯„åœå…§");
        } catch (Exception e) {
            return new ValidationResult(false, "ç„¡æ•ˆçš„è·¯å¾‘ï¼š" + e.getMessage());
        }
    }
    
    /**
     * é©—è­‰ SQL å®‰å…¨æ€§
     */
    public static ValidationResult validateSql(String query) {
        if (query == null || query.isBlank()) {
            return new ValidationResult(false, "æŸ¥è©¢ä¸èƒ½ç‚ºç©º");
        }
        
        // ç§»é™¤è¨»è§£
        String cleanQuery = query
            .replaceAll("--.*$", "")
            .replaceAll("/\\*.*?\\*/", "");
        String upperQuery = cleanQuery.toUpperCase().trim();
        
        // åƒ…å…è¨± SELECT
        if (!upperQuery.startsWith("SELECT")) {
            return new ValidationResult(false, "åƒ…å…è¨± SELECT æŸ¥è©¢");
        }
        
        // æª¢æŸ¥å±éšªé—œéµå­—
        List<String> dangerous = List.of("DROP", "DELETE", "TRUNCATE", "UPDATE", "INSERT", "ALTER");
        for (String kw : dangerous) {
            Pattern pattern = Pattern.compile("\\b" + kw + "\\b", Pattern.CASE_INSENSITIVE);
            if (pattern.matcher(upperQuery).find()) {
                return new ValidationResult(false, "ä¸å…è¨±çš„é—œéµå­—ï¼š" + kw);
            }
        }
        
        return new ValidationResult(true, "");
    }
    
    /**
     * é©—è­‰è­˜åˆ¥ç¬¦ï¼ˆè¡¨åã€æ¬„ä½åï¼‰
     */
    public static ValidationResult validateIdentifier(String name, int maxLength) {
        if (name == null || name.isEmpty()) {
            return new ValidationResult(false, "è­˜åˆ¥ç¬¦ä¸èƒ½ç‚ºç©º");
        }
        
        if (name.length() > maxLength) {
            return new ValidationResult(false, "è­˜åˆ¥ç¬¦éé•·ï¼ˆæœ€å¤§ " + maxLength + "ï¼‰");
        }
        
        if (!name.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
            return new ValidationResult(false, "è­˜åˆ¥ç¬¦åŒ…å«éæ³•å­—å…ƒ");
        }
        
        return new ValidationResult(true, "");
    }
    
    public static ValidationResult validateIdentifier(String name) {
        return validateIdentifier(name, 63);
    }
    
    public record ValidationResult(boolean isValid, String message) {}
}
```

#### 6.3.3 æ•æ„Ÿè³‡æ–™è™•ç†

```java
/**
 * æ•æ„Ÿè³‡æ–™è™•ç†
 */
package com.example.mcp.security;

import java.util.*;
import java.util.logging.*;
import java.util.regex.*;

/**
 * æ•æ„Ÿè³‡æ–™è™•ç†å™¨
 */
public class SensitiveDataHandler {
    
    // æ•æ„Ÿæ¬„ä½æ¨¡å¼
    private static final List<String> SENSITIVE_PATTERNS = List.of(
        "password", "secret", "token", "api_key", "apikey",
        "authorization", "credential", "private_key"
    );
    
    private static final Pattern SENSITIVE_REGEX = Pattern.compile(
        String.join("|", SENSITIVE_PATTERNS),
        Pattern.CASE_INSENSITIVE
    );
    
    /**
     * é®ç½©æ•æ„Ÿå€¼
     */
    public static String maskSensitiveValue(String value, int visibleChars) {
        if (value == null) return null;
        if (value.length() <= visibleChars) {
            return "*".repeat(value.length());
        }
        return value.substring(0, visibleChars) + "*".repeat(value.length() - visibleChars);
    }
    
    public static String maskSensitiveValue(String value) {
        return maskSensitiveValue(value, 4);
    }
    
    /**
     * æ¸…ç†è³‡æ–™ä»¥ä¾›æ—¥èªŒè¨˜éŒ„
     */
    @SuppressWarnings("unchecked")
    public static Object sanitizeForLogging(Object data, int depth) {
        if (depth > 10) {
            return "<max depth reached>";
        }
        
        if (data instanceof Map) {
            Map<String, Object> result = new LinkedHashMap<>();
            Map<String, Object> map = (Map<String, Object>) data;
            
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();
                
                if (SENSITIVE_REGEX.matcher(key).find()) {
                    result.put(key, maskSensitiveValue(String.valueOf(value)));
                } else {
                    result.put(key, sanitizeForLogging(value, depth + 1));
                }
            }
            return result;
        } else if (data instanceof List) {
            List<Object> result = new ArrayList<>();
            for (Object item : (List<?>) data) {
                result.add(sanitizeForLogging(item, depth + 1));
            }
            return result;
        } else if (data instanceof String) {
            String str = (String) data;
            // æª¢æŸ¥æ˜¯å¦åƒ Token
            if (str.length() > 20 && str.matches("^[A-Za-z0-9_\\-]+$")) {
                return maskSensitiveValue(str);
            }
            return str;
        }
        
        return data;
    }
    
    public static Object sanitizeForLogging(Object data) {
        return sanitizeForLogging(data, 0);
    }
}

/**
 * å®‰å…¨æ—¥èªŒé¡åˆ¥
 */
public class SecureLogger {
    
    private final Logger logger;
    
    public SecureLogger(String name) {
        this.logger = Logger.getLogger(name);
    }
    
    public void info(String message, Object data) {
        if (data != null) {
            data = SensitiveDataHandler.sanitizeForLogging(data);
        }
        logger.info(data != null ? message + " " + data : message);
    }
    
    public void info(String message) {
        info(message, null);
    }
    
    public void error(String message, Object data) {
        if (data != null) {
            data = SensitiveDataHandler.sanitizeForLogging(data);
        }
        logger.severe(data != null ? message + " " + data : message);
    }
    
    public void error(String message) {
        error(message, null);
    }
}
```

#### 6.3.4 é€Ÿç‡é™åˆ¶

```java
/**
 * é€Ÿç‡é™åˆ¶å¯¦ä½œ
 */
package com.example.mcp.security;

import java.time.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * æ»‘å‹•çª—å£é€Ÿç‡é™åˆ¶å™¨
 */
public class RateLimiter {
    
    private final int maxRequests;
    private final Duration windowDuration;
    private final ConcurrentHashMap<String, Deque<Instant>> requests;
    
    public RateLimiter(int maxRequests, Duration windowDuration) {
        this.maxRequests = maxRequests;
        this.windowDuration = windowDuration;
        this.requests = new ConcurrentHashMap<>();
    }
    
    public RateLimiter() {
        this(100, Duration.ofMinutes(1));
    }
    
    /**
     * æª¢æŸ¥è«‹æ±‚æ˜¯å¦å…è¨±
     */
    public synchronized RateLimitResult isAllowed(String key) {
        Instant now = Instant.now();
        Instant windowStart = now.minus(windowDuration);
        
        // å–å¾—æˆ–å»ºç«‹è«‹æ±‚ä½‡åˆ—
        Deque<Instant> keyRequests = requests.computeIfAbsent(key, k -> new ConcurrentLinkedDeque<>());
        
        // æ¸…ç†éæœŸè¨˜éŒ„
        while (!keyRequests.isEmpty() && keyRequests.peekFirst().isBefore(windowStart)) {
            keyRequests.pollFirst();
        }
        
        int currentCount = keyRequests.size();
        int remaining = Math.max(0, maxRequests - currentCount);
        Instant resetAt = now.plus(windowDuration);
        
        RateLimitInfo info = new RateLimitInfo(maxRequests, remaining, resetAt);
        
        if (currentCount >= maxRequests) {
            return new RateLimitResult(false, info);
        }
        
        keyRequests.addLast(now);
        return new RateLimitResult(true, new RateLimitInfo(maxRequests, remaining - 1, resetAt));
    }
    
    public record RateLimitInfo(int limit, int remaining, Instant resetAt) {}
    public record RateLimitResult(boolean allowed, RateLimitInfo info) {}
}

// åœ¨å·¥å…·è™•ç†å™¨ä¸­ä½¿ç”¨
public class RateLimitedToolHandler {
    
    private final RateLimiter rateLimiter = new RateLimiter(100, Duration.ofMinutes(1));
    
    public CompletableFuture<CallToolResult> handleToolCall(
        String toolName,
        Map<String, Object> arguments,
        String rateLimitKey
    ) {
        return CompletableFuture.supplyAsync(() -> {
            // æª¢æŸ¥é€Ÿç‡é™åˆ¶
            RateLimiter.RateLimitResult result = rateLimiter.isAllowed(rateLimitKey);
            
            if (!result.allowed()) {
                return CallToolResult.error(String.format(
                    "é€Ÿç‡é™åˆ¶ï¼šè«‹ç¨å¾Œå†è©¦%nå‰©é¤˜é…é¡ï¼š%d/%d",
                    result.info().remaining(),
                    result.info().limit()
                ));
            }
            
            // åŸ·è¡Œå·¥å…·...
            return executeToolInternal(toolName, arguments);
        });
    }
    
    private CallToolResult executeToolInternal(String name, Map<String, Object> args) {
        // å¯¦éš›å·¥å…·åŸ·è¡Œé‚è¼¯
        return CallToolResult.text("åŸ·è¡Œçµæœ");
    }
}
```

---

### 6.4 æ¸¬è©¦ç­–ç•¥

#### 6.4.1 å–®å…ƒæ¸¬è©¦

```java
/**
 * MCP Server å–®å…ƒæ¸¬è©¦ç¯„ä¾‹
 */
package com.example.mcp.test;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.io.TempDir;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * å·¥å…·æ¸¬è©¦
 */
class ToolsTest {
    
    @Test
    void testListTools() throws Exception {
        // å–å¾—å·¥å…·åˆ—è¡¨
        List<Tool> tools = server.listTools().get();
        
        assertFalse(tools.isEmpty());
        assertTrue(tools.stream().allMatch(t -> t.getName() != null));
        assertTrue(tools.stream().allMatch(t -> t.getDescription() != null));
        assertTrue(tools.stream().allMatch(t -> t.getInputSchema() != null));
    }
    
    @Test
    void testReadFileSuccess(@TempDir Path tempDir) throws Exception {
        // å»ºç«‹æ¸¬è©¦æª”æ¡ˆ
        Path testFile = tempDir.resolve("test.txt");
        Files.writeString(testFile, "Hello, World!");
        
        // æ¨¡æ“¬å…è¨±çš„è·¯å¾‘
        List<String> originalAllowed = ALLOWED_DIRECTORIES;
        try {
            ALLOWED_DIRECTORIES = List.of(tempDir.toString());
            
            CallToolResult result = handleReadFile(Map.of("path", testFile.toString())).get();
            
            assertTrue(result.isSuccess());
            assertEquals("Hello, World!", result.getText());
        } finally {
            ALLOWED_DIRECTORIES = originalAllowed;
        }
    }
    
    @Test
    void testReadFileNotFound() throws Exception {
        CallToolResult result = handleReadFile(Map.of("path", "/nonexistent/file.txt")).get();
        
        assertTrue(result.isError());
        assertTrue(result.getText().contains("ä¸å­˜åœ¨") || result.getText().contains("éŒ¯èª¤"));
    }
    
    @Test
    void testReadFilePermissionDenied(@TempDir Path tempDir) throws Exception {
        // è¨­å®šä¸å…è¨±çš„è·¯å¾‘
        List<String> originalAllowed = ALLOWED_DIRECTORIES;
        try {
            ALLOWED_DIRECTORIES = List.of("/other/path");
            
            Path testFile = tempDir.resolve("test.txt");
            Files.writeString(testFile, "content");
            
            CallToolResult result = handleReadFile(Map.of("path", testFile.toString())).get();
            
            assertTrue(result.isError());
            assertTrue(result.getText().contains("æ‹’çµ•") || result.getText().contains("éŒ¯èª¤"));
        } finally {
            ALLOWED_DIRECTORIES = originalAllowed;
        }
    }
    
    @Test
    void testQueryValidation() {
        // æœ‰æ•ˆæŸ¥è©¢
        var validResult = InputValidator.validateSql("SELECT * FROM users WHERE id = 1");
        assertTrue(validResult.isValid());
        
        // ç„¡æ•ˆæŸ¥è©¢ - DROP
        var dropResult = InputValidator.validateSql("DROP TABLE users");
        assertFalse(dropResult.isValid());
        assertTrue(dropResult.message().contains("DROP") || dropResult.message().contains("SELECT"));
        
        // ç„¡æ•ˆæŸ¥è©¢ - å¤šèªå¥
        var multiResult = InputValidator.validateSql("SELECT 1; DELETE FROM users");
        assertFalse(multiResult.isValid());
    }
}

/**
 * è¼¸å…¥é©—è­‰æ¸¬è©¦
 */
class InputValidationTest {
    
    @Test
    void testValidatePathSafe() {
        var result = InputValidator.validatePath(
            "/home/user/documents/file.txt",
            List.of("/home/user")
        );
        assertTrue(result.isValid());
    }
    
    @Test
    void testValidatePathTraversal() {
        // æ¸¬è©¦è·¯å¾‘éæ­·æ”»æ“Š
        var result = InputValidator.validatePath(
            "/home/user/../../../etc/passwd",
            List.of("/home/user")
        );
        assertFalse(result.isValid());
    }
    
    @Test
    void testValidateIdentifierValid() {
        // æ¸¬è©¦æœ‰æ•ˆè­˜åˆ¥ç¬¦
        var result = InputValidator.validateIdentifier("user_table");
        assertTrue(result.isValid());
    }
    
    @Test
    void testValidateIdentifierInvalid() {
        // æ¸¬è©¦ç„¡æ•ˆè­˜åˆ¥ç¬¦
        var result = InputValidator.validateIdentifier("user; DROP TABLE--");
        assertFalse(result.isValid());
    }
}
```

#### 6.4.2 æ•´åˆæ¸¬è©¦

```java
/**
 * MCP Server æ•´åˆæ¸¬è©¦
 */
package com.example.mcp.test;

import io.modelcontextprotocol.client.*;
import io.modelcontextprotocol.client.transport.StdioClientTransport;
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.*;
import java.util.concurrent.*;

class IntegrationTest {
    
    private McpClient client;
    
    @BeforeEach
    void setUp() throws Exception {
        // å»ºç«‹ MCP Client
        ProcessBuilder pb = new ProcessBuilder(
            "java", "-jar", "target/my-mcp-server-1.0.0.jar"
        );
        pb.environment().put("MCP_ALLOWED_DIRS", "/tmp");
        
        Process process = pb.start();
        StdioClientTransport transport = new StdioClientTransport(
            process.getInputStream(),
            process.getOutputStream()
        );
        
        client = new McpClient(McpClientOptions.builder()
            .clientInfo(ClientInfo.builder()
                .name("test-client")
                .version("1.0.0")
                .build())
            .build());
        
        client.connect(transport).get(10, TimeUnit.SECONDS);
    }
    
    @AfterEach
    void tearDown() {
        if (client != null) {
            client.close();
        }
    }
    
    @Test
    void testFullWorkflow() throws Exception {
        // æ¸¬è©¦å®Œæ•´å·¥ä½œæµç¨‹
        
        // 1. åˆ—å‡ºå·¥å…·
        ListToolsResult toolsResult = client.listTools().get(5, TimeUnit.SECONDS);
        assertFalse(toolsResult.getTools().isEmpty());
        
        // 2. å¯«å…¥æª”æ¡ˆ
        CallToolResult writeResult = client.callTool(
            "write_file",
            Map.of(
                "path", "/tmp/test_integration.txt",
                "content", "Integration test content"
            )
        ).get(5, TimeUnit.SECONDS);
        assertTrue(writeResult.getText().contains("æˆåŠŸ"));
        
        // 3. è®€å–æª”æ¡ˆ
        CallToolResult readResult = client.callTool(
            "read_file",
            Map.of("path", "/tmp/test_integration.txt")
        ).get(5, TimeUnit.SECONDS);
        assertTrue(readResult.getText().contains("Integration test content"));
        
        // 4. åˆªé™¤æª”æ¡ˆ
        CallToolResult deleteResult = client.callTool(
            "delete_file",
            Map.of(
                "path", "/tmp/test_integration.txt",
                "confirm", true
            )
        ).get(5, TimeUnit.SECONDS);
        assertTrue(deleteResult.getText().contains("æˆåŠŸ"));
    }
}
```

#### 6.4.3 ä½¿ç”¨ MCP Inspector é€²è¡Œæ¸¬è©¦

```bash
# å•Ÿå‹• Inspector ä¸¦é€£æ¥åˆ° Server
npx @modelcontextprotocol/inspector java -jar target/my-mcp-server-1.0.0.jar

# Inspector æœƒé–‹å•Ÿ Web UIï¼Œå¯ä»¥ï¼š
# 1. æŸ¥çœ‹æ‰€æœ‰å¯ç”¨å·¥å…·
# 2. æ‰‹å‹•åŸ·è¡Œå·¥å…·ä¸¦æŸ¥çœ‹çµæœ
# 3. æª¢è¦–åŸå§‹ JSON-RPC è¨Šæ¯
# 4. ç›£æ§ Server æ—¥èªŒ
```

#### 6.4.4 æ¨¡æ“¬èˆ‡ Mock

```java
/**
 * Mock æ¸¬è©¦ç¯„ä¾‹
 */
package com.example.mcp.test;

import org.junit.jupiter.api.*;
import org.mockito.*;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.*;
import java.util.concurrent.*;

class MockTest {
    
    @Mock
    private GitHubApiClient mockGitHubClient;
    
    @Mock
    private DatabaseConnectionPool mockDbPool;
    
    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Test
    void testGitHubApiWithMock() throws Exception {
        // æ¨¡æ“¬ GitHub API å›æ‡‰
        Map<String, Object> mockResponse = Map.of(
            "full_name", "test/repo",
            "description", "Test repository",
            "stargazers_count", 100
        );
        
        when(mockGitHubClient.request(eq("GET"), eq("/repos/test/repo"), any()))
            .thenReturn(CompletableFuture.completedFuture(mockResponse));
        
        // åŸ·è¡Œæ¸¬è©¦
        GitHubMcpServer server = new GitHubMcpServer(mockGitHubClient);
        CallToolResult result = server.handleGetRepo(Map.of(
            "owner", "test",
            "repo", "repo"
        ));
        
        assertTrue(result.getText().contains("test/repo"));
        assertTrue(result.getText().contains("100"));
        
        verify(mockGitHubClient).request(eq("GET"), eq("/repos/test/repo"), any());
    }
    
    @Test
    void testDatabaseWithMock() throws Exception {
        // æ¨¡æ“¬è³‡æ–™åº«æŸ¥è©¢çµæœ
        List<Map<String, Object>> mockRows = List.of(
            Map.of("id", 1, "name", "Alice"),
            Map.of("id", 2, "name", "Bob")
        );
        
        Connection mockConn = mock(Connection.class);
        PreparedStatement mockStmt = mock(PreparedStatement.class);
        ResultSet mockRs = mock(ResultSet.class);
        
        when(mockDbPool.getConnection()).thenReturn(mockConn);
        when(mockConn.prepareStatement(anyString())).thenReturn(mockStmt);
        when(mockStmt.executeQuery()).thenReturn(mockRs);
        
        // æ¨¡æ“¬ ResultSet è¿­ä»£
        when(mockRs.next()).thenReturn(true, true, false);
        when(mockRs.getObject("id")).thenReturn(1, 2);
        when(mockRs.getObject("name")).thenReturn("Alice", "Bob");
        
        // åŸ·è¡Œæ¸¬è©¦
        DatabaseMcpServer server = new DatabaseMcpServer(mockDbPool);
        CallToolResult result = server.handleQuery(Map.of(
            "sql", "SELECT * FROM users",
            "limit", 10
        ));
        
        assertTrue(result.getText().contains("Alice"));
        assertTrue(result.getText().contains("Bob"));
    }
    
    @Test
    void testRateLimiterMock() {
        // æ¸¬è©¦é€Ÿç‡é™åˆ¶å™¨
        RateLimiter rateLimiter = new RateLimiter(2, Duration.ofSeconds(1));
        
        // å‰å…©æ¬¡æ‡‰è©²å…è¨±
        assertTrue(rateLimiter.isAllowed("test-key").allowed());
        assertTrue(rateLimiter.isAllowed("test-key").allowed());
        
        // ç¬¬ä¸‰æ¬¡æ‡‰è©²è¢«é™åˆ¶
        assertFalse(rateLimiter.isAllowed("test-key").allowed());
    }
}
```

---

## ç¬¬ä¸ƒç« ï¼šé€²éšä¸»é¡Œ

### 7.1 Tasks å¯¦é©—æ€§åŠŸèƒ½

#### 7.1.1 Tasks æ¦‚è¿°

Tasks æ˜¯ MCP çš„å¯¦é©—æ€§åŠŸèƒ½ï¼Œç”¨æ–¼è™•ç†é•·æ™‚é–“é‹è¡Œçš„æ“ä½œï¼š

```mermaid
sequenceDiagram
    participant C as Client
    participant S as Server
    
    C->>S: tools/call (é•·æ™‚é–“æ“ä½œ)
    S->>C: å›æ‡‰ taskId
    
    Note over C: éåŒæ­¥ç­‰å¾…
    
    loop è¼ªè©¢ç‹€æ…‹
        C->>S: tasks/get (taskId)
        S->>C: ç‹€æ…‹: running/completed
    end
    
    C->>S: tasks/get (taskId)
    S->>C: æœ€çµ‚çµæœ
```

#### 7.1.2 å¯¦ä½œç¯„ä¾‹

```java
/**
 * Tasks å¯¦ä½œç¯„ä¾‹
 */
package com.example.mcp.tasks;

import java.time.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * ä»»å‹™ç‹€æ…‹æšèˆ‰
 */
public enum TaskStatus {
    PENDING("pending"),
    RUNNING("running"),
    COMPLETED("completed"),
    FAILED("failed"),
    CANCELLED("cancelled");
    
    private final String value;
    
    TaskStatus(String value) {
        this.value = value;
    }
    
    public String getValue() { return value; }
}

/**
 * ä»»å‹™å¯¦é«”
 */
public class Task {
    private final String id;
    private final String name;
    private volatile TaskStatus status;
    private volatile double progress;
    private volatile Object result;
    private volatile String error;
    private final Instant createdAt;
    private volatile Instant completedAt;
    
    public Task(String id, String name) {
        this.id = id;
        this.name = name;
        this.status = TaskStatus.PENDING;
        this.progress = 0.0;
        this.createdAt = Instant.now();
    }
    
    // Getters and setters
    public String getId() { return id; }
    public String getName() { return name; }
    public TaskStatus getStatus() { return status; }
    public void setStatus(TaskStatus status) { this.status = status; }
    public double getProgress() { return progress; }
    public void setProgress(double progress) { this.progress = progress; }
    public Object getResult() { return result; }
    public void setResult(Object result) { this.result = result; }
    public String getError() { return error; }
    public void setError(String error) { this.error = error; }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getCompletedAt() { return completedAt; }
    public void setCompletedAt(Instant completedAt) { this.completedAt = completedAt; }
}

/**
 * ä»»å‹™ç®¡ç†å™¨
 */
public class TaskManager {
    
    private final ConcurrentHashMap<String, Task> tasks = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, CompletableFuture<?>> runningTasks = new ConcurrentHashMap<>();
    private final ExecutorService executor = Executors.newCachedThreadPool();
    
    /**
     * å»ºç«‹æ–°ä»»å‹™
     */
    public Task createTask(String name) {
        String taskId = UUID.randomUUID().toString();
        Task task = new Task(taskId, name);
        tasks.put(taskId, task);
        return task;
    }
    
    /**
     * åŸ·è¡Œä»»å‹™
     */
    public <T> CompletableFuture<T> runTask(
        String taskId,
        Callable<T> callable,
        java.util.function.Consumer<Double> progressCallback
    ) {
        Task task = tasks.get(taskId);
        if (task == null) {
            throw new IllegalArgumentException("ä»»å‹™ä¸å­˜åœ¨ï¼š" + taskId);
        }
        
        task.setStatus(TaskStatus.RUNNING);
        
        CompletableFuture<T> future = CompletableFuture.supplyAsync(() -> {
            try {
                T result = callable.call();
                task.setResult(result);
                task.setStatus(TaskStatus.COMPLETED);
                return result;
            } catch (CancellationException e) {
                task.setStatus(TaskStatus.CANCELLED);
                throw e;
            } catch (Exception e) {
                task.setError(e.getMessage());
                task.setStatus(TaskStatus.FAILED);
                throw new CompletionException(e);
            } finally {
                task.setCompletedAt(Instant.now());
            }
        }, executor);
        
        runningTasks.put(taskId, future);
        return future;
    }
    
    /**
     * å–å¾—ä»»å‹™ç‹€æ…‹
     */
    public Optional<Task> getTask(String taskId) {
        return Optional.ofNullable(tasks.get(taskId));
    }
    
    /**
     * å–æ¶ˆä»»å‹™
     */
    public boolean cancelTask(String taskId) {
        CompletableFuture<?> future = runningTasks.get(taskId);
        if (future != null) {
            return future.cancel(true);
        }
        return false;
    }
    
    /**
     * æ›´æ–°é€²åº¦
     */
    public void updateProgress(String taskId, double progress) {
        Task task = tasks.get(taskId);
        if (task != null) {
            task.setProgress(progress);
        }
    }
    
    /**
     * é—œé–‰ç®¡ç†å™¨
     */
    public void shutdown() {
        executor.shutdown();
    }
}

// åœ¨ MCP Server ä¸­ä½¿ç”¨ä»»å‹™ç®¡ç†å™¨
public class TaskEnabledMcpServer {
    
    private final McpServer server;
    private final TaskManager taskManager = new TaskManager();
    
    public TaskEnabledMcpServer() {
        // åˆå§‹åŒ– server...
        this.server = createServer();
        setupHandlers();
    }
    
    private void setupHandlers() {
        server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
            String name = request.getParams().getName();
            Map<String, Object> args = request.getParams().getArguments();
            
            if ("long_running_analysis".equals(name)) {
                // å»ºç«‹ä»»å‹™
                Task task = taskManager.createTask("analysis");
                
                // èƒŒæ™¯åŸ·è¡Œ
                taskManager.runTask(task.getId(), () -> {
                    int totalSteps = 10;
                    for (int i = 0; i < totalSteps; i++) {
                        Thread.sleep(1000);  // æ¨¡æ“¬å·¥ä½œ
                        taskManager.updateProgress(task.getId(), (i + 1.0) / totalSteps);
                    }
                    return Map.of("result", "Analysis completed", "items_processed", 100);
                }, null);
                
                return CallToolResult.text("ä»»å‹™å·²å•Ÿå‹•ï¼Œä»»å‹™ IDï¼š" + task.getId());
                
            } else if ("get_task_status".equals(name)) {
                String taskId = (String) args.get("task_id");
                Optional<Task> taskOpt = taskManager.getTask(taskId);
                
                if (taskOpt.isEmpty()) {
                    return CallToolResult.text("ä»»å‹™ä¸å­˜åœ¨");
                }
                
                Task task = taskOpt.get();
                StringBuilder output = new StringBuilder();
                output.append("ä»»å‹™ç‹€æ…‹ï¼š").append(task.getId()).append("\n");
                output.append("ç‹€æ…‹ï¼š").append(task.getStatus().getValue()).append("\n");
                output.append("é€²åº¦ï¼š").append(String.format("%.1f%%", task.getProgress() * 100)).append("\n");
                
                if (task.getStatus() == TaskStatus.COMPLETED) {
                    output.append("çµæœï¼š").append(task.getResult()).append("\n");
                } else if (task.getStatus() == TaskStatus.FAILED) {
                    output.append("éŒ¯èª¤ï¼š").append(task.getError()).append("\n");
                }
                
                return CallToolResult.text(output.toString());
            }
            
            return CallToolResult.error("æœªçŸ¥å·¥å…·ï¼š" + name);
        }));
    }
}
```

---

### 7.2 è‡ªè¨‚å‚³è¼¸å±¤

#### 7.2.1 ä½•æ™‚éœ€è¦è‡ªè¨‚å‚³è¼¸å±¤

- WebSocket é€šè¨Š
- è‡ªè¨‚åŠ å¯†é€šé“
- ç‰¹æ®Šç¶²è·¯ç’°å¢ƒ
- æ•ˆèƒ½å„ªåŒ–éœ€æ±‚

#### 7.2.2 å¯¦ä½œæŒ‡å—

```java
/**
 * è‡ªè¨‚å‚³è¼¸å±¤ç¯„ä¾‹ï¼šWebSocket Transport
 */
package com.example.mcp.transport;

import com.google.gson.*;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;

import java.net.URI;
import java.util.*;
import java.util.concurrent.*;

/**
 * WebSocket å‚³è¼¸å±¤
 */
public class WebSocketTransport extends WebSocketClient {
    
    private final BlockingQueue<Map<String, Object>> messageQueue;
    private final Gson gson;
    
    public WebSocketTransport(URI serverUri) {
        super(serverUri);
        this.messageQueue = new LinkedBlockingQueue<>();
        this.gson = new Gson();
    }
    
    @Override
    public void onOpen(ServerHandshake handshake) {
        System.out.println("WebSocket é€£æ¥å·²å»ºç«‹");
    }
    
    @Override
    public void onMessage(String message) {
        try {
            @SuppressWarnings("unchecked")
            Map<String, Object> data = gson.fromJson(message, Map.class);
            messageQueue.put(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    @Override
    public void onClose(int code, String reason, boolean remote) {
        System.out.println("WebSocket é€£æ¥å·²é—œé–‰ï¼š" + reason);
    }
    
    @Override
    public void onError(Exception ex) {
        ex.printStackTrace();
    }
    
    /**
     * ç™¼é€è¨Šæ¯
     */
    public void sendMessage(Map<String, Object> message) {
        send(gson.toJson(message));
    }
    
    /**
     * æ¥æ”¶è¨Šæ¯
     */
    public Map<String, Object> receiveMessage() throws InterruptedException {
        return messageQueue.take();
    }
    
    /**
     * æ¥æ”¶è¨Šæ¯ï¼ˆå¸¶è¶…æ™‚ï¼‰
     */
    public Map<String, Object> receiveMessage(long timeout, TimeUnit unit) throws InterruptedException {
        return messageQueue.poll(timeout, unit);
    }
}

/**
 * ä½¿ç”¨ WebSocket çš„ MCP Client
 */
public class WebSocketMcpClient implements AutoCloseable {
    
    private final WebSocketTransport transport;
    private final AtomicInteger requestId;
    private final ConcurrentHashMap<Integer, CompletableFuture<Map<String, Object>>> pendingRequests;
    private final ExecutorService executor;
    
    public WebSocketMcpClient(String uri) throws Exception {
        this.transport = new WebSocketTransport(new URI(uri));
        this.requestId = new AtomicInteger(0);
        this.pendingRequests = new ConcurrentHashMap<>();
        this.executor = Executors.newSingleThreadExecutor();
    }
    
    /**
     * é€£æ¥åˆ°ä¼ºæœå™¨
     */
    public CompletableFuture<Void> connect() {
        return CompletableFuture.runAsync(() -> {
            try {
                transport.connectBlocking();
                startResponseHandler();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new CompletionException(e);
            }
        });
    }
    
    /**
     * å•Ÿå‹•å›æ‡‰è™•ç†å™¨
     */
    private void startResponseHandler() {
        executor.submit(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Map<String, Object> message = transport.receiveMessage();
                    handleMessage(message);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
    }
    
    /**
     * è™•ç†è¨Šæ¯
     */
    @SuppressWarnings("unchecked")
    private void handleMessage(Map<String, Object> message) {
        if (message.containsKey("id")) {
            // é€™æ˜¯å°è«‹æ±‚çš„å›æ‡‰
            int id = ((Number) message.get("id")).intValue();
            CompletableFuture<Map<String, Object>> future = pendingRequests.remove(id);
            if (future != null) {
                future.complete(message);
            }
        } else {
            // é€™æ˜¯é€šçŸ¥
            handleNotification(message);
        }
    }
    
    /**
     * è™•ç†é€šçŸ¥
     */
    private void handleNotification(Map<String, Object> notification) {
        System.out.println("æ”¶åˆ°é€šçŸ¥ï¼š" + notification);
    }
    
    /**
     * ç™¼é€è«‹æ±‚
     */
    public CompletableFuture<Map<String, Object>> request(String method, Map<String, Object> params) {
        int id = requestId.incrementAndGet();
        
        Map<String, Object> message = new LinkedHashMap<>();
        message.put("jsonrpc", "2.0");
        message.put("id", id);
        message.put("method", method);
        if (params != null) {
            message.put("params", params);
        }
        
        CompletableFuture<Map<String, Object>> future = new CompletableFuture<>();
        pendingRequests.put(id, future);
        
        transport.sendMessage(message);
        
        return future.thenApply(response -> {
            if (response.containsKey("error")) {
                @SuppressWarnings("unchecked")
                Map<String, Object> error = (Map<String, Object>) response.get("error");
                throw new CompletionException(new RuntimeException((String) error.get("message")));
            }
            return response.get("result");
        }).thenApply(result -> {
            @SuppressWarnings("unchecked")
            Map<String, Object> resultMap = (Map<String, Object>) result;
            return resultMap;
        });
    }
    
    @Override
    public void close() {
        executor.shutdown();
        transport.close();
    }
}
```

---

### 7.3 å¤šèªè¨€ SDK æ¯”è¼ƒ

| ç‰¹æ€§ | Java SDK | Python SDK | TypeScript SDK |
|------|---------|-----------|----------------|
| **æˆç†Ÿåº¦** | ç©©å®š | ç©©å®š | ç©©å®š |
| **éåŒæ­¥æ”¯æ´** | CompletableFuture | asyncio | Promise/async-await |
| **å‹åˆ¥ç³»çµ±** | å¼·å‹åˆ¥ | é¸ç”¨ï¼ˆtypingï¼‰ | å…§å»º |
| **å¥—ä»¶ç®¡ç†** | Maven/Gradle | pip/uv | npm/pnpm |
| **é©ç”¨å ´æ™¯** | ä¼æ¥­æ‡‰ç”¨ã€å¾®æœå‹™ | è³‡æ–™è™•ç†ã€ML | Web æ‡‰ç”¨ã€å‰ç«¯æ•´åˆ |

**Java ç‰¹é»**ï¼š
```java
// Handler è¨»å†Šé¢¨æ ¼
server.setToolListHandler(request -> CompletableFuture.supplyAsync(() -> {
    return ListToolsResult.builder()
        .tools(List.of(...))
        .build();
}));

server.setToolHandler(request -> CompletableFuture.supplyAsync(() -> {
    return handleToolCall(request.getParams().getName(), request.getParams().getArguments());
}));
```

**Python ç‰¹é»**ï¼š
```python
# è£é£¾å™¨é¢¨æ ¼çš„ Handler è¨»å†Š
@server.list_tools()
async def list_tools():
    ...

@server.call_tool()
async def call_tool(name, arguments):
    ...
```

**TypeScript ç‰¹é»**ï¼š
```typescript
// Schema é©—è­‰é¢¨æ ¼
server.setRequestHandler(ListToolsRequestSchema, async () => {
  ...
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  ...
});
```

---

### 7.4 åµéŒ¯èˆ‡ç›£æ§

#### 7.4.1 æ—¥èªŒè¨˜éŒ„æœ€ä½³å¯¦è¸

```java
/**
 * æ—¥èªŒè¨˜éŒ„æœ€ä½³å¯¦è¸
 */
package com.example.mcp.logging;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.PrintStream;
import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.logging.*;

/**
 * çµæ§‹åŒ–æ—¥èªŒæ ¼å¼å™¨
 */
public class StructuredFormatter extends Formatter {
    
    private final Gson gson = new GsonBuilder().create();
    
    @Override
    public String format(LogRecord record) {
        Map<String, Object> logData = new LinkedHashMap<>();
        logData.put("timestamp", Instant.now().toString());
        logData.put("level", record.getLevel().getName());
        logData.put("logger", record.getLoggerName());
        logData.put("message", record.getMessage());
        
        // æ·»åŠ é¡å¤–è³‡è¨Šï¼ˆé€é MDC æˆ–åƒæ•¸å‚³éï¼‰
        Object[] params = record.getParameters();
        if (params != null && params.length > 0) {
            if (params[0] instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> extra = (Map<String, Object>) params[0];
                logData.putAll(extra);
            }
        }
        
        return gson.toJson(logData) + System.lineSeparator();
    }
}

/**
 * MCP Server æ—¥èªŒå·¥å…·
 */
public class McpLogger {
    
    private static final Logger logger;
    
    static {
        // MCP Server æ—¥èªŒæ‡‰è©²è¼¸å‡ºåˆ° stderr
        logger = Logger.getLogger("mcp_server");
        logger.setUseParentHandlers(false);
        
        StreamHandler handler = new StreamHandler(System.err, new StructuredFormatter()) {
            @Override
            public synchronized void publish(LogRecord record) {
                super.publish(record);
                flush();
            }
        };
        handler.setLevel(Level.INFO);
        logger.addHandler(handler);
        logger.setLevel(Level.INFO);
    }
    
    public static Logger getLogger() {
        return logger;
    }
    
    /**
     * è¨˜éŒ„å·¥å…·å‘¼å«
     */
    public static void logToolCall(String toolName, double durationMs, boolean success) {
        Map<String, Object> extra = new LinkedHashMap<>();
        extra.put("tool_name", toolName);
        extra.put("duration_ms", durationMs);
        
        if (success) {
            logger.log(Level.INFO, "å·¥å…·å‘¼å«æˆåŠŸ", new Object[]{extra});
        } else {
            logger.log(Level.SEVERE, "å·¥å…·å‘¼å«å¤±æ•—", new Object[]{extra});
        }
    }
}
```

#### 7.4.2 æ•ˆèƒ½ç›£æ§

```java
/**
 * æ•ˆèƒ½ç›£æ§
 */
package com.example.mcp.monitoring;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

/**
 * æŒ‡æ¨™é»
 */
record MetricPoint(long timestamp, double value) {}

/**
 * æŒ‡æ¨™æ”¶é›†å™¨
 */
public class Metrics {
    
    private final int retentionSeconds;
    private final ConcurrentMap<String, AtomicLong> counters;
    private final ConcurrentMap<String, CopyOnWriteArrayList<MetricPoint>> timings;
    private final ConcurrentMap<String, AtomicReference<Double>> gauges;
    private final ScheduledExecutorService cleaner;
    
    public Metrics(int retentionSeconds) {
        this.retentionSeconds = retentionSeconds;
        this.counters = new ConcurrentHashMap<>();
        this.timings = new ConcurrentHashMap<>();
        this.gauges = new ConcurrentHashMap<>();
        
        // å®šæœŸæ¸…ç†èˆŠè³‡æ–™
        this.cleaner = Executors.newSingleThreadScheduledExecutor();
        this.cleaner.scheduleAtFixedRate(
            this::cleanupOldData, 
            60, 60, TimeUnit.SECONDS
        );
    }
    
    public Metrics() {
        this(3600);  // é è¨­ä¿ç•™ 1 å°æ™‚
    }
    
    /**
     * å¢åŠ è¨ˆæ•¸å™¨
     */
    public void increment(String name, long value) {
        counters.computeIfAbsent(name, k -> new AtomicLong(0)).addAndGet(value);
    }
    
    public void increment(String name) {
        increment(name, 1);
    }
    
    /**
     * è¨˜éŒ„æ™‚é–“
     */
    public void timing(String name, double durationMs) {
        timings.computeIfAbsent(name, k -> new CopyOnWriteArrayList<>())
            .add(new MetricPoint(System.currentTimeMillis(), durationMs));
    }
    
    /**
     * è¨­å®šé‡è¦
     */
    public void gauge(String name, double value) {
        gauges.computeIfAbsent(name, k -> new AtomicReference<>(0.0)).set(value);
    }
    
    /**
     * æ¸…ç†èˆŠè³‡æ–™
     */
    private void cleanupOldData() {
        long cutoff = System.currentTimeMillis() - (retentionSeconds * 1000L);
        
        timings.forEach((name, points) -> {
            points.removeIf(p -> p.timestamp() < cutoff);
        });
    }
    
    /**
     * å–å¾—çµ±è¨ˆè³‡è¨Š
     */
    public Map<String, Object> getStats(String name) {
        List<MetricPoint> points = timings.getOrDefault(name, new CopyOnWriteArrayList<>());
        
        if (points.isEmpty()) {
            return Map.of("count", 0);
        }
        
        List<Double> values = points.stream()
            .map(MetricPoint::value)
            .sorted()
            .collect(Collectors.toList());
        
        Map<String, Object> stats = new LinkedHashMap<>();
        stats.put("count", values.size());
        stats.put("min", values.get(0));
        stats.put("max", values.get(values.size() - 1));
        stats.put("avg", values.stream().mapToDouble(d -> d).average().orElse(0));
        
        if (values.size() >= 20) {
            int p95Index = (int) (values.size() * 0.95);
            stats.put("p95", values.get(p95Index));
        }
        
        return stats;
    }
    
    public void shutdown() {
        cleaner.shutdown();
    }
}

// å…¨åŸŸæŒ‡æ¨™æ”¶é›†å™¨
class MetricsHolder {
    static final Metrics INSTANCE = new Metrics();
}

/**
 * æ™‚é–“æ¸¬é‡åŒ…è£å™¨
 */
public class MeasuredExecutor {
    
    private final String metricName;
    private final Metrics metrics;
    
    public MeasuredExecutor(String metricName, Metrics metrics) {
        this.metricName = metricName;
        this.metrics = metrics;
    }
    
    public MeasuredExecutor(String metricName) {
        this(metricName, MetricsHolder.INSTANCE);
    }
    
    /**
     * æ¸¬é‡ä¸¦åŸ·è¡Œ
     */
    public <T> CompletableFuture<T> measureAsync(Supplier<CompletableFuture<T>> task) {
        long start = System.nanoTime();
        
        return task.get()
            .whenComplete((result, error) -> {
                double durationMs = (System.nanoTime() - start) / 1_000_000.0;
                metrics.timing(metricName + "_duration", durationMs);
                
                if (error != null) {
                    metrics.increment(metricName + "_error");
                } else {
                    metrics.increment(metricName + "_success");
                }
            });
    }
    
    /**
     * æ¸¬é‡åŒæ­¥æ“ä½œ
     */
    public <T> T measure(Supplier<T> task) {
        long start = System.nanoTime();
        
        try {
            T result = task.get();
            metrics.increment(metricName + "_success");
            return result;
        } catch (Exception e) {
            metrics.increment(metricName + "_error");
            throw e;
        } finally {
            double durationMs = (System.nanoTime() - start) / 1_000_000.0;
            metrics.timing(metricName + "_duration", durationMs);
        }
    }
}

// ä½¿ç”¨ç¯„ä¾‹
class ToolHandler {
    private final MeasuredExecutor readFileMetrics = new MeasuredExecutor("tool_read_file");
    
    public CompletableFuture<String> handleReadFile(Map<String, Object> args) {
        return readFileMetrics.measureAsync(() -> 
            CompletableFuture.supplyAsync(() -> {
                // å¯¦éš›è™•ç†é‚è¼¯
                return "file content";
            })
        );
    }
}
```

---

*ï¼ˆç¬¬ä¸ƒç« å®Œçµï¼Œç¹¼çºŒç¬¬å…«ç« ï¼‰*

---

## ç¬¬å…«ç« ï¼šç–‘é›£æ’è§£

### 8.1 å¸¸è¦‹éŒ¯èª¤èˆ‡è§£æ±ºæ–¹æ¡ˆ

#### 8.1.1 é€£æ¥å•é¡Œ

| éŒ¯èª¤è¨Šæ¯ | å¯èƒ½åŸå›  | è§£æ±ºæ–¹æ¡ˆ |
|---------|---------|---------|
| `Connection refused` | Server æœªå•Ÿå‹• | ç¢ºèª Server æ­£åœ¨é‹è¡Œ |
| `Timeout waiting for response` | Server è™•ç†éæ…¢ | å¢åŠ è¶…æ™‚æ™‚é–“æˆ–å„ªåŒ– Server |
| `Protocol version mismatch` | ç‰ˆæœ¬ä¸ç›¸å®¹ | æ›´æ–° SDK åˆ°ç›¸å®¹ç‰ˆæœ¬ |
| `Transport error` | STDIO ç®¡é“å•é¡Œ | æª¢æŸ¥ stdout/stderr ä½¿ç”¨ |

**STDIO é€£æ¥å•é¡Œè¨ºæ–·**ï¼š

```java
/**
 * STDIO é€£æ¥è¨ºæ–·å·¥å…·
 */
package com.example.mcp.diagnostic;

import java.io.*;
import java.util.logging.*;

public class StdioDiagnostic {
    
    // ç¢ºä¿æ—¥èªŒè¼¸å‡ºåˆ° stderrï¼Œä¸å¹²æ“¾ STDIO é€šè¨Š
    private static final Logger logger;
    
    static {
        logger = Logger.getLogger(StdioDiagnostic.class.getName());
        logger.setUseParentHandlers(false);
        
        ConsoleHandler handler = new ConsoleHandler() {
            @Override
            protected void setOutputStream(OutputStream out) throws SecurityException {
                super.setOutputStream(System.err);  // é‡è¦ï¼
            }
        };
        handler.setFormatter(new SimpleFormatter());
        logger.addHandler(handler);
        logger.setLevel(Level.ALL);
    }
    
    public static void diagnoseStdio() {
        // 1. æª¢æŸ¥ stdin æ˜¯å¦å¯è®€
        logger.info("æª¢æŸ¥ stdin...");
        if (System.console() != null) {
            logger.warning("stdin æ˜¯çµ‚ç«¯æ©Ÿï¼Œå¯èƒ½ä¸é©åˆ STDIO å‚³è¼¸");
        }
        
        // 2. æª¢æŸ¥ stdout æ˜¯å¦å¯å¯«
        logger.info("æª¢æŸ¥ stdout...");
        
        // 3. æ¸¬è©¦å¯«å…¥
        try {
            String testMessage = "{\"test\": \"message\"}\n";
            System.out.write(testMessage.getBytes());
            System.out.flush();
            logger.info("stdout å¯«å…¥æ¸¬è©¦æˆåŠŸ");
        } catch (IOException e) {
            logger.severe("stdout å¯«å…¥å¤±æ•—ï¼š" + e.getMessage());
        }
        
        // 4. æª¢æŸ¥ç’°å¢ƒè®Šæ•¸
        logger.info("JAVA_HOME: " + System.getenv("JAVA_HOME"));
        String path = System.getenv("PATH");
        logger.info("PATH: " + (path != null ? path.substring(0, Math.min(100, path.length())) + "..." : "not set"));
    }
    
    public static void main(String[] args) {
        diagnoseStdio();
    }
}
```

#### 8.1.2 å·¥å…·åŸ·è¡ŒéŒ¯èª¤

**éŒ¯èª¤æ¨¡å¼èˆ‡è™•ç†**ï¼š

```java
/**
 * éŒ¯èª¤æ¨¡å¼åˆ†æ
 */
package com.example.mcp.error;

import io.modelcontextprotocol.server.*;
import io.modelcontextprotocol.spec.McpSchema.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.Function;

/**
 * å·¥å…·éŒ¯èª¤è™•ç†
 */
public class ToolErrorHandling {
    
    /**
     * 1. åƒæ•¸éŒ¯èª¤è™•ç†
     */
    public static CallToolResult validateAndCallTool(
            String name, 
            Map<String, Object> arguments,
            Function<Map<String, Object>, CallToolResult> toolHandler) {
        
        try {
            // é©—è­‰åƒæ•¸
            if ("read_file".equals(name)) {
                Object path = arguments.get("path");
                
                if (path == null) {
                    return CallToolResult.error(
                        "éŒ¯èª¤ï¼šç¼ºå°‘å¿…è¦åƒæ•¸ 'path'\n" +
                        "è«‹ä½¿ç”¨ï¼šread_file(path='/path/to/file')"
                    );
                }
                
                // é¡å‹æª¢æŸ¥
                if (!(path instanceof String)) {
                    return CallToolResult.error(
                        String.format("éŒ¯èª¤ï¼šåƒæ•¸ 'path' é¡å‹éŒ¯èª¤%né æœŸï¼šStringï¼Œæ”¶åˆ°ï¼š%s",
                            path.getClass().getSimpleName())
                    );
                }
            }
            
            // å‘¼å«å·¥å…·
            return toolHandler.apply(arguments);
            
        } catch (IllegalArgumentException e) {
            return CallToolResult.error("åƒæ•¸éŒ¯èª¤ï¼š" + e.getMessage());
        } catch (ClassCastException e) {
            return CallToolResult.error("é¡å‹éŒ¯èª¤ï¼š" + e.getMessage());
        }
    }
    
    /**
     * 2. è³‡æºéŒ¯èª¤
     */
    public static class ResourceException extends RuntimeException {
        private final String resourceType;
        
        public ResourceException(String message, String resourceType) {
            super(message);
            this.resourceType = resourceType;
        }
        
        public String getResourceType() { return resourceType; }
    }
    
    /**
     * è³‡æºéŒ¯èª¤è™•ç†åŒ…è£å™¨
     */
    public static CallToolResult handleResourceErrors(
            java.util.function.Supplier<CallToolResult> operation) {
        
        try {
            return operation.get();
            
        } catch (java.nio.file.NoSuchFileException e) {
            return CallToolResult.error(
                String.format("âŒ æª”æ¡ˆæœªæ‰¾åˆ°ï¼š%s%nè«‹ç¢ºèªè·¯å¾‘æ˜¯å¦æ­£ç¢º", e.getFile())
            );
        } catch (java.nio.file.AccessDeniedException e) {
            return CallToolResult.error(
                String.format("âŒ æ¬Šé™è¢«æ‹’çµ•ï¼š%s%nè«‹æª¢æŸ¥æª”æ¡ˆæ¬Šé™æˆ–å…è¨±çš„ç›®éŒ„è¨­å®š", e.getFile())
            );
        } catch (java.net.ConnectException e) {
            return CallToolResult.error(
                String.format("âŒ é€£æ¥éŒ¯èª¤ï¼š%s%nè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥æˆ–æœå‹™ç‹€æ…‹", e.getMessage())
            );
        }
    }
}
```

#### 8.1.3 è¨˜æ†¶é«”èˆ‡æ•ˆèƒ½å•é¡Œ

```java
/**
 * æ•ˆèƒ½å•é¡Œè¨ºæ–·
 */
package com.example.mcp.diagnostic;

import java.lang.management.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Supplier;
import java.util.logging.*;

/**
 * è¨˜æ†¶é«”ç›£æ§å·¥å…·
 */
public class MemoryMonitor {
    
    private static final Logger logger = Logger.getLogger(MemoryMonitor.class.getName());
    private static final MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
    
    /**
     * å–å¾—è¨˜æ†¶é«”å¿«ç…§
     */
    public static void memorySnapshot() {
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        MemoryUsage nonHeapUsage = memoryBean.getNonHeapMemoryUsage();
        
        System.err.println("è¨˜æ†¶é«”ä½¿ç”¨ç‹€æ³ï¼š");
        System.err.printf("  Heap: ä½¿ç”¨ %d MB / æœ€å¤§ %d MB%n",
            heapUsage.getUsed() / (1024 * 1024),
            heapUsage.getMax() / (1024 * 1024));
        System.err.printf("  Non-Heap: ä½¿ç”¨ %d MB%n",
            nonHeapUsage.getUsed() / (1024 * 1024));
        
        // åŸ·è¡Œç·’è³‡è¨Š
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        System.err.printf("  åŸ·è¡Œç·’æ•¸ï¼š%d%n", threadBean.getThreadCount());
    }
}

/**
 * æ…¢æ“ä½œåµæ¸¬
 */
public class SlowOperationDetector {
    
    private static final Logger logger = Logger.getLogger(SlowOperationDetector.class.getName());
    private final double thresholdSeconds;
    
    public SlowOperationDetector(double thresholdSeconds) {
        this.thresholdSeconds = thresholdSeconds;
    }
    
    public SlowOperationDetector() {
        this(5.0);
    }
    
    /**
     * åµæ¸¬æ…¢æ“ä½œ
     */
    public <T> CompletableFuture<T> detectSlow(
            String operationName, 
            Supplier<CompletableFuture<T>> operation) {
        
        long start = System.nanoTime();
        
        return operation.get()
            .whenComplete((result, error) -> {
                double duration = (System.nanoTime() - start) / 1_000_000_000.0;
                if (duration > thresholdSeconds) {
                    logger.warning(String.format(
                        "æ…¢æ“ä½œåµæ¸¬ï¼š%s è€—æ™‚ %.2f ç§’",
                        operationName, duration));
                }
            });
    }
    
    /**
     * åŒæ­¥ç‰ˆæœ¬
     */
    public <T> T detectSlowSync(String operationName, Supplier<T> operation) {
        long start = System.nanoTime();
        
        try {
            return operation.get();
        } finally {
            double duration = (System.nanoTime() - start) / 1_000_000_000.0;
            if (duration > thresholdSeconds) {
                logger.warning(String.format(
                    "æ…¢æ“ä½œåµæ¸¬ï¼š%s è€—æ™‚ %.2f ç§’",
                    operationName, duration));
            }
        }
    }
}

/**
 * é€£æ¥æ± ç›£æ§
 */
public class PoolMonitor<T> {
    
    private final int maxSize;
    private final java.util.concurrent.BlockingQueue<T> pool;
    private final java.util.concurrent.atomic.AtomicInteger inUse;
    
    public PoolMonitor(BlockingQueue<T> pool, int maxSize) {
        this.pool = pool;
        this.maxSize = maxSize;
        this.inUse = new java.util.concurrent.atomic.AtomicInteger(0);
    }
    
    public Map<String, Object> getStats() {
        int available = pool.size();
        int used = inUse.get();
        
        Map<String, Object> stats = new LinkedHashMap<>();
        stats.put("available", available);
        stats.put("in_use", used);
        stats.put("max_size", maxSize);
        return stats;
    }
    
    public record HealthCheckResult(boolean healthy, String message) {}
    
    public HealthCheckResult checkHealth() {
        Map<String, Object> stats = getStats();
        
        int used = (int) stats.get("in_use");
        double usageRatio = (double) used / maxSize;
        
        if (usageRatio > 0.9) {
            return new HealthCheckResult(false, "é€£æ¥æ± ä½¿ç”¨ç‡éé«˜ (>90%)");
        }
        
        if ((int) stats.get("available") == 0) {
            return new HealthCheckResult(false, "æ²’æœ‰å¯ç”¨é€£æ¥");
        }
        
        return new HealthCheckResult(true, "æ­£å¸¸");
    }
}
```

---

### 8.2 é™¤éŒ¯æŠ€å·§

#### 8.2.1 MCP Inspector ä½¿ç”¨

```bash
# åŸºæœ¬ä½¿ç”¨
npx @modelcontextprotocol/inspector python -m my_server

# å¸¶ç’°å¢ƒè®Šæ•¸
npx @modelcontextprotocol/inspector \
    -e MCP_ALLOWED_DIRS=/path/to/allowed \
    -e DEBUG=true \
    python -m my_server

# é€£æ¥åˆ° HTTP Server
npx @modelcontextprotocol/inspector --url http://localhost:8080/mcp
```

**Inspector åŠŸèƒ½**ï¼š

1. **å·¥å…·æª¢è¦–**ï¼šæŸ¥çœ‹æ‰€æœ‰å¯ç”¨å·¥å…·åŠå…¶ Schema
2. **æ‰‹å‹•åŸ·è¡Œ**ï¼šç›´æ¥å‘¼å«å·¥å…·ä¸¦æŸ¥çœ‹çµæœ
3. **è¨Šæ¯ç›£æ§**ï¼šæª¢è¦–åŸå§‹ JSON-RPC è¨Šæ¯
4. **æ—¥èªŒæŸ¥çœ‹**ï¼šå³æ™‚æŸ¥çœ‹ Server æ—¥èªŒ

#### 8.2.2 æ—¥èªŒåˆ†æ

```java
/**
 * æ—¥èªŒåˆ†æå·¥å…·
 */
package com.example.mcp.diagnostic;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.*;

public class LogAnalyzer {
    
    private final Gson gson = new Gson();
    
    public record LogStats(
        int totalRequests,
        int errors,
        Map<String, Integer> toolCalls,
        List<Double> durations,
        Map<String, Integer> errorTypes
    ) {
        public double getErrorRate() {
            return totalRequests > 0 ? (double) errors / totalRequests * 100 : 0;
        }
        
        public Double getAverageDuration() {
            return durations.isEmpty() ? null : 
                durations.stream().mapToDouble(d -> d).average().orElse(0);
        }
    }
    
    /**
     * åˆ†æ MCP Server æ—¥èªŒ
     */
    public LogStats analyzeLogs(String logFile) throws IOException {
        int totalRequests = 0;
        int errors = 0;
        Map<String, Integer> toolCalls = new HashMap<>();
        List<Double> durations = new ArrayList<>();
        Map<String, Integer> errorTypes = new HashMap<>();
        
        try (BufferedReader reader = Files.newBufferedReader(Path.of(logFile))) {
            String line;
            while ((line = reader.readLine()) != null) {
                try {
                    Map<String, Object> entry = gson.fromJson(
                        line, 
                        new TypeToken<Map<String, Object>>(){}.getType()
                    );
                    
                    totalRequests++;
                    
                    if ("ERROR".equals(entry.get("level"))) {
                        errors++;
                        String errorType = (String) entry.getOrDefault("error_type", "unknown");
                        errorTypes.merge(errorType, 1, Integer::sum);
                    }
                    
                    if (entry.containsKey("tool_name")) {
                        String toolName = (String) entry.get("tool_name");
                        toolCalls.merge(toolName, 1, Integer::sum);
                    }
                    
                    if (entry.containsKey("duration_ms")) {
                        durations.add(((Number) entry.get("duration_ms")).doubleValue());
                    }
                    
                } catch (Exception e) {
                    // è·³éç„¡æ³•è§£æçš„è¡Œ
                }
            }
        }
        
        return new LogStats(totalRequests, errors, toolCalls, durations, errorTypes);
    }
    
    /**
     * åˆ—å°åˆ†æå ±å‘Š
     */
    public void printReport(LogStats stats) {
        System.out.println("=".repeat(50));
        System.out.println("MCP Server æ—¥èªŒåˆ†æå ±å‘Š");
        System.out.println("=".repeat(50));
        System.out.printf("ç¸½è«‹æ±‚æ•¸ï¼š%d%n", stats.totalRequests());
        System.out.printf("éŒ¯èª¤æ•¸ï¼š%d%n", stats.errors());
        System.out.printf("éŒ¯èª¤ç‡ï¼š%.2f%%%n", stats.getErrorRate());
        
        Double avgDuration = stats.getAverageDuration();
        System.out.printf("å¹³å‡å›æ‡‰æ™‚é–“ï¼š%s ms%n", 
            avgDuration != null ? String.format("%.2f", avgDuration) : "N/A");
        
        System.out.println("\nå·¥å…·å‘¼å«çµ±è¨ˆï¼š");
        stats.toolCalls().entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .forEach(e -> System.out.printf("  %s: %d%n", e.getKey(), e.getValue()));
        
        System.out.println("\néŒ¯èª¤é¡å‹åˆ†å¸ƒï¼š");
        stats.errorTypes().forEach((type, count) -> 
            System.out.printf("  %s: %d%n", type, count));
    }
    
    public static void main(String[] args) throws IOException {
        if (args.length < 1) {
            System.err.println("ç”¨æ³•ï¼šjava LogAnalyzer <log-file>");
            System.exit(1);
        }
        
        LogAnalyzer analyzer = new LogAnalyzer();
        LogStats stats = analyzer.analyzeLogs(args[0]);
        analyzer.printReport(stats);
    }
}
```

#### 8.2.3 ç¶²è·¯é™¤éŒ¯

```java
/**
 * ç¶²è·¯é™¤éŒ¯å·¥å…·
 */
package com.example.mcp.diagnostic;

import okhttp3.*;

import java.io.IOException;
import java.util.concurrent.TimeUnit;

public class NetworkDebugger {
    
    private final OkHttpClient client;
    
    public NetworkDebugger() {
        this.client = new OkHttpClient.Builder()
            .connectTimeout(5, TimeUnit.SECONDS)
            .readTimeout(5, TimeUnit.SECONDS)
            .build();
    }
    
    /**
     * é™¤éŒ¯ HTTP é€£æ¥
     */
    public void debugHttpConnection(String url) {
        System.out.println("æ¸¬è©¦é€£æ¥ï¼š" + url);
        
        try {
            // 1. åŸºæœ¬é€£æ¥æ¸¬è©¦
            Request request = new Request.Builder()
                .url(url)
                .get()
                .build();
            
            try (Response response = client.newCall(request).execute()) {
                System.out.println("âœ… é€£æ¥æˆåŠŸ");
                System.out.println("   ç‹€æ…‹ç¢¼ï¼š" + response.code());
                System.out.println("   Headersï¼š");
                response.headers().forEach(pair -> 
                    System.out.println("     " + pair.getFirst() + ": " + pair.getSecond()));
            }
            
            // 2. SSE ç«¯é»æ¸¬è©¦
            String sseUrl = url.contains("/mcp") ? 
                url.replace("/mcp", "/sse") : url + "/sse";
            
            try {
                Request sseRequest = new Request.Builder()
                    .url(sseUrl)
                    .get()
                    .build();
                
                try (Response sseResponse = client.newCall(sseRequest).execute()) {
                    System.out.println("âœ… SSE ç«¯é»å¯ç”¨");
                    System.out.println("   Content-Typeï¼š" + 
                        sseResponse.header("Content-Type"));
                }
            } catch (Exception e) {
                System.out.println("âš ï¸ SSE ç«¯é»ç„¡æ³•é€£æ¥");
            }
            
        } catch (java.net.ConnectException e) {
            System.out.println("âŒ é€£æ¥éŒ¯èª¤ï¼š" + e.getMessage());
        } catch (java.net.SocketTimeoutException e) {
            System.out.println("âŒ é€£æ¥è¶…æ™‚");
        } catch (Exception e) {
            System.out.println("âŒ æœªçŸ¥éŒ¯èª¤ï¼š" + e.getMessage());
        }
    }
    
    /**
     * è¿½è¹¤ HTTP è«‹æ±‚
     */
    public void traceRequest(String method, String url, RequestBody body) throws IOException {
        System.out.println("\n" + "=".repeat(50));
        System.out.println("è«‹æ±‚ï¼š" + method + " " + url);
        
        long start = System.currentTimeMillis();
        
        Request.Builder requestBuilder = new Request.Builder().url(url);
        
        switch (method.toUpperCase()) {
            case "GET" -> requestBuilder.get();
            case "POST" -> requestBuilder.post(body != null ? body : RequestBody.create("", null));
            case "PUT" -> requestBuilder.put(body != null ? body : RequestBody.create("", null));
            case "DELETE" -> requestBuilder.delete(body);
            default -> throw new IllegalArgumentException("ä¸æ”¯æ´çš„æ–¹æ³•ï¼š" + method);
        }
        
        try (Response response = client.newCall(requestBuilder.build()).execute()) {
            long duration = System.currentTimeMillis() - start;
            
            System.out.println("\nå›æ‡‰ï¼š");
            System.out.println("  ç‹€æ…‹ï¼š" + response.code());
            System.out.println("  è€—æ™‚ï¼š" + duration + " ms");
            System.out.println("  Headersï¼š");
            response.headers().forEach(pair -> 
                System.out.println("    " + pair.getFirst() + ": " + pair.getSecond()));
            
            ResponseBody responseBody = response.body();
            if (responseBody != null) {
                String bodyStr = responseBody.string();
                System.out.println("  Bodyï¼š" + 
                    (bodyStr.length() > 500 ? bodyStr.substring(0, 500) + "..." : bodyStr));
            }
        }
    }
    
    public static void main(String[] args) {
        if (args.length < 1) {
            System.err.println("ç”¨æ³•ï¼šjava NetworkDebugger <url>");
            System.exit(1);
        }
        
        NetworkDebugger debugger = new NetworkDebugger();
        debugger.debugHttpConnection(args[0]);
    }
}
```

---

### 8.3 éŒ¯èª¤è¨Šæ¯åƒè€ƒ

#### 8.3.1 JSON-RPC éŒ¯èª¤ç¢¼

| éŒ¯èª¤ç¢¼ | åç¨± | èªªæ˜ | è§£æ±ºæ–¹æ¡ˆ |
|-------|------|------|---------|
| -32700 | Parse error | JSON è§£æéŒ¯èª¤ | æª¢æŸ¥ JSON æ ¼å¼ |
| -32600 | Invalid Request | ç„¡æ•ˆçš„è«‹æ±‚ç‰©ä»¶ | æª¢æŸ¥ jsonrpc, method æ¬„ä½ |
| -32601 | Method not found | æ–¹æ³•ä¸å­˜åœ¨ | ç¢ºèªæ–¹æ³•åç¨±æ­£ç¢º |
| -32602 | Invalid params | åƒæ•¸éŒ¯èª¤ | æª¢æŸ¥åƒæ•¸æ ¼å¼å’Œé¡å‹ |
| -32603 | Internal error | å…§éƒ¨éŒ¯èª¤ | æª¢æŸ¥ Server æ—¥èªŒ |

#### 8.3.2 MCP ç‰¹å®šéŒ¯èª¤

```java
/**
 * MCP éŒ¯èª¤è™•ç†åƒè€ƒ
 */
package com.example.mcp.error;

import java.util.*;

/**
 * MCP éŒ¯èª¤å®šç¾©
 */
public class McpErrors {
    
    public record ErrorDefinition(
        int code,
        String message,
        String solution
    ) {}
    
    // è³‡æºç›¸é—œéŒ¯èª¤
    public static final Map<String, ErrorDefinition> RESOURCE_ERRORS = Map.of(
        "resource_not_found", new ErrorDefinition(
            -32001,
            "æ‰¾ä¸åˆ°æŒ‡å®šçš„è³‡æº",
            "ç¢ºèªè³‡æº URI æ­£ç¢ºä¸”è³‡æºå­˜åœ¨"
        ),
        "resource_access_denied", new ErrorDefinition(
            -32002,
            "è³‡æºå­˜å–è¢«æ‹’çµ•",
            "æª¢æŸ¥æ¬Šé™è¨­å®šå’Œå…è¨±çš„è·¯å¾‘"
        ),
        "resource_read_error", new ErrorDefinition(
            -32003,
            "è³‡æºè®€å–éŒ¯èª¤",
            "æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å¯è®€å–ã€ç·¨ç¢¼æ˜¯å¦æ­£ç¢º"
        )
    );
    
    // å·¥å…·ç›¸é—œéŒ¯èª¤
    public static final Map<String, ErrorDefinition> TOOL_ERRORS = Map.of(
        "tool_not_found", new ErrorDefinition(
            -32010,
            "æ‰¾ä¸åˆ°æŒ‡å®šçš„å·¥å…·",
            "ä½¿ç”¨ tools/list ç¢ºèªå¯ç”¨å·¥å…·"
        ),
        "tool_execution_error", new ErrorDefinition(
            -32011,
            "å·¥å…·åŸ·è¡ŒéŒ¯èª¤",
            "æª¢æŸ¥åƒæ•¸å’Œ Server æ—¥èªŒ"
        ),
        "tool_timeout", new ErrorDefinition(
            -32012,
            "å·¥å…·åŸ·è¡Œè¶…æ™‚",
            "å¢åŠ è¶…æ™‚æ™‚é–“æˆ–å„ªåŒ–æ“ä½œ"
        )
    );
    
    // é€£æ¥ç›¸é—œéŒ¯èª¤
    public static final Map<String, ErrorDefinition> CONNECTION_ERRORS = Map.of(
        "session_expired", new ErrorDefinition(
            -32020,
            "Session å·²éæœŸ",
            "é‡æ–°åˆå§‹åŒ–é€£æ¥"
        ),
        "rate_limited", new ErrorDefinition(
            -32021,
            "è«‹æ±‚éæ–¼é »ç¹",
            "æ¸›å°‘è«‹æ±‚é »ç‡æˆ–ç­‰å¾…é…é¡é‡ç½®"
        )
    );
    
    /**
     * æ ¹æ“šéŒ¯èª¤ç¢¼å–å¾—éŒ¯èª¤å®šç¾©
     */
    public static Optional<ErrorDefinition> getByCode(int code) {
        return java.util.stream.Stream.of(RESOURCE_ERRORS, TOOL_ERRORS, CONNECTION_ERRORS)
            .flatMap(map -> map.values().stream())
            .filter(e -> e.code() == code)
            .findFirst();
    }
    
    /**
     * æ ¹æ“šåç¨±å–å¾—éŒ¯èª¤å®šç¾©
     */
    public static Optional<ErrorDefinition> getByName(String name) {
        return java.util.stream.Stream.of(RESOURCE_ERRORS, TOOL_ERRORS, CONNECTION_ERRORS)
            .filter(map -> map.containsKey(name))
            .map(map -> map.get(name))
            .findFirst();
    }
}
```

---

---

## ç¬¬ä¹ç« ï¼šå¯¦éš›æ¡ˆä¾‹ç ”ç©¶

### 9.1 æ¡ˆä¾‹ä¸€ï¼šä¼æ¥­çŸ¥è­˜åº« MCP Server

#### 9.1.1 éœ€æ±‚èƒŒæ™¯

- **å ´æ™¯**ï¼šä¼æ¥­å…§éƒ¨æœ‰å¤§é‡æ–‡ä»¶ã€Wikiã€FAQ è³‡æ–™
- **ç›®æ¨™**ï¼šè®“ AI åŠ©æ‰‹èƒ½æœå°‹å’Œå¼•ç”¨å…§éƒ¨çŸ¥è­˜
- **æŒ‘æˆ°**ï¼šè³‡æ–™åˆ†æ•£ã€æ¬Šé™æ§åˆ¶ã€å³æ™‚æ›´æ–°

#### 9.1.2 æ¶æ§‹è¨­è¨ˆ

```mermaid
graph TB
    subgraph "AI å±¤"
        Claude[Claude/AI åŠ©æ‰‹]
    end
    
    subgraph "MCP å±¤"
        KBServer[Knowledge Base<br/>MCP Server]
    end
    
    subgraph "è³‡æ–™å±¤"
        ES[(Elasticsearch)]
        Wiki[(Confluence)]
        SharePoint[(SharePoint)]
    end
    
    subgraph "èªè­‰å±¤"
        LDAP[LDAP/AD]
        OAuth[OAuth 2.0]
    end
    
    Claude --> KBServer
    KBServer --> ES
    KBServer --> Wiki
    KBServer --> SharePoint
    KBServer --> LDAP
    KBServer --> OAuth
```

#### 9.1.3 æ ¸å¿ƒå¯¦ä½œ

```java
/**
 * ä¼æ¥­çŸ¥è­˜åº« MCP Server
 */
package com.example.mcp.kb;

import co.elastic.clients.elasticsearch.ElasticsearchAsyncClient;
import co.elastic.clients.elasticsearch._types.query_dsl.*;
import co.elastic.clients.elasticsearch.core.*;
import co.elastic.clients.elasticsearch.core.search.*;
import co.elastic.clients.json.jackson.JacksonJsonpMapper;
import co.elastic.clients.transport.rest_client.RestClientTransport;
import io.modelcontextprotocol.server.*;
import io.modelcontextprotocol.spec.McpSchema.*;
import org.apache.http.HttpHost;
import org.elasticsearch.client.RestClient;

import java.util.*;
import java.util.concurrent.*;

public class KnowledgeBaseMcpServer {
    
    // é…ç½®
    private static final String ES_HOST = "elasticsearch";
    private static final int ES_PORT = 9200;
    private static final String WIKI_URL = "http://confluence.internal";
    
    private final McpServer server;
    private final ElasticsearchAsyncClient esClient;
    
    public KnowledgeBaseMcpServer() {
        this.server = McpServer.builder()
            .name("knowledge-base")
            .version("1.0.0")
            .build();
        
        // åˆå§‹åŒ– Elasticsearch å®¢æˆ¶ç«¯
        RestClient restClient = RestClient.builder(
            new HttpHost(ES_HOST, ES_PORT)
        ).build();
        
        this.esClient = new ElasticsearchAsyncClient(
            new RestClientTransport(restClient, new JacksonJsonpMapper())
        );
        
        setupHandlers();
    }
    
    private void setupHandlers() {
        // å·¥å…·åˆ—è¡¨
        server.setToolListHandler(request -> CompletableFuture.supplyAsync(() -> {
            List<Tool> tools = List.of(
                Tool.builder()
                    .name("search_knowledge")
                    .description("æœå°‹ä¼æ¥­çŸ¥è­˜åº«ï¼ŒåŒ…å«æ–‡ä»¶ã€Wikiã€FAQ")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "query", Map.of(
                                "type", "string",
                                "description", "æœå°‹é—œéµå­—æˆ–å•é¡Œ"
                            ),
                            "sources", Map.of(
                                "type", "array",
                                "items", Map.of(
                                    "type", "string",
                                    "enum", List.of("documents", "wiki", "faq", "all")
                                ),
                                "default", List.of("all"),
                                "description", "æœå°‹ä¾†æº"
                            ),
                            "department", Map.of(
                                "type", "string",
                                "description", "é™åˆ¶ç‰¹å®šéƒ¨é–€çš„æ–‡ä»¶"
                            ),
                            "date_from", Map.of(
                                "type", "string",
                                "format", "date",
                                "description", "èµ·å§‹æ—¥æœŸéæ¿¾"
                            ),
                            "max_results", Map.of(
                                "type", "integer",
                                "default", 10,
                                "maximum", 50
                            )
                        ),
                        "required", List.of("query")
                    ))
                    .build(),
                    
                Tool.builder()
                    .name("get_document")
                    .description("å–å¾—ç‰¹å®šæ–‡ä»¶çš„å®Œæ•´å…§å®¹")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "doc_id", Map.of(
                                "type", "string",
                                "description", "æ–‡ä»¶ ID"
                            ),
                            "include_metadata", Map.of(
                                "type", "boolean",
                                "default", true
                            )
                        ),
                        "required", List.of("doc_id")
                    ))
                    .build(),
                    
                Tool.builder()
                    .name("ask_faq")
                    .description("å¾ FAQ ä¸­æ‰¾å°‹æœ€ç›¸é—œçš„å•ç­”")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "question", Map.of(
                                "type", "string",
                                "description", "ç”¨æˆ¶å•é¡Œ"
                            ),
                            "category", Map.of(
                                "type", "string",
                                "enum", List.of("hr", "it", "finance", "general")
                            )
                        ),
                        "required", List.of("question")
                    ))
                    .build()
            );
            
            return ListToolsResult.builder().tools(tools).build();
        }));
        
        // å·¥å…·å‘¼å«è™•ç†
        server.setToolHandler(request -> {
            String name = request.getParams().getName();
            Map<String, Object> args = request.getParams().getArguments();
            
            return switch (name) {
                case "search_knowledge" -> searchKnowledge(args);
                case "get_document" -> getDocument(args);
                case "ask_faq" -> askFaq(args);
                default -> CompletableFuture.completedFuture(
                    CallToolResult.error("æœªçŸ¥å·¥å…·ï¼š" + name)
                );
            };
        });
    }
    
    /**
     * æœå°‹çŸ¥è­˜åº«
     */
    private CompletableFuture<CallToolResult> searchKnowledge(Map<String, Object> args) {
        String query = (String) args.get("query");
        @SuppressWarnings("unchecked")
        List<String> sources = (List<String>) args.getOrDefault("sources", List.of("all"));
        String department = (String) args.get("department");
        String dateFrom = (String) args.get("date_from");
        int maxResults = ((Number) args.getOrDefault("max_results", 10)).intValue();
        
        // æ§‹å»ºæŸ¥è©¢
        List<Query> mustQueries = new ArrayList<>();
        mustQueries.add(MultiMatchQuery.of(mm -> mm
            .query(query)
            .fields("title^3", "content", "tags^2")
            .type(TextQueryType.BestFields)
            .fuzziness("AUTO")
        )._toQuery());
        
        List<Query> filterQueries = new ArrayList<>();
        
        if (!sources.contains("all")) {
            filterQueries.add(TermsQuery.of(t -> t
                .field("source")
                .terms(TermsQueryField.of(tf -> tf
                    .value(sources.stream().map(FieldValue::of).toList())
                ))
            )._toQuery());
        }
        
        if (department != null) {
            filterQueries.add(TermQuery.of(t -> t
                .field("department")
                .value(department)
            )._toQuery());
        }
        
        if (dateFrom != null) {
            filterQueries.add(RangeQuery.of(r -> r
                .field("updated_at")
                .gte(co.elastic.clients.json.JsonData.of(dateFrom))
            )._toQuery());
        }
        
        BoolQuery boolQuery = BoolQuery.of(b -> b
            .must(mustQueries)
            .filter(filterQueries)
        );
        
        return esClient.search(s -> s
            .index("knowledge_base")
            .query(boolQuery._toQuery())
            .size(maxResults)
            .highlight(h -> h
                .fields("content", hf -> hf.fragmentSize(200))
            ),
            Map.class
        ).thenApply(response -> {
            List<Hit<Map>> hits = response.hits().hits();
            
            if (hits.isEmpty()) {
                return CallToolResult.text("æœªæ‰¾åˆ°èˆ‡ã€Œ" + query + "ã€ç›¸é—œçš„å…§å®¹");
            }
            
            StringBuilder output = new StringBuilder();
            output.append("## æœå°‹çµæœï¼šã€Œ").append(query).append("ã€\n\n");
            output.append("æ‰¾åˆ° ").append(response.hits().total().value())
                  .append(" ç­†ç›¸é—œæ–‡ä»¶\n\n");
            
            int i = 1;
            for (Hit<Map> hit : hits) {
                @SuppressWarnings("unchecked")
                Map<String, Object> source = hit.source();
                
                output.append("### ").append(i++).append(". ")
                      .append(source.get("title")).append("\n");
                output.append("- **ä¾†æº**ï¼š").append(source.get("source")).append("\n");
                output.append("- **éƒ¨é–€**ï¼š")
                      .append(source.getOrDefault("department", "N/A")).append("\n");
                output.append("- **æ›´æ–°æ—¥æœŸ**ï¼š").append(source.get("updated_at")).append("\n");
                output.append("- **æ–‡ä»¶ ID**ï¼š`").append(hit.id()).append("`\n");
                
                Map<String, List<String>> highlight = hit.highlight();
                if (highlight != null && highlight.containsKey("content")) {
                    output.append("- **æ‘˜è¦**ï¼š...")
                          .append(highlight.get("content").get(0)).append("...\n");
                }
                
                output.append("\n");
            }
            
            return CallToolResult.text(output.toString());
        }).exceptionally(e -> CallToolResult.error("æœå°‹å¤±æ•—ï¼š" + e.getMessage()));
    }
    
    /**
     * å–å¾—æ–‡ä»¶å…§å®¹
     */
    private CompletableFuture<CallToolResult> getDocument(Map<String, Object> args) {
        String docId = (String) args.get("doc_id");
        boolean includeMetadata = (Boolean) args.getOrDefault("include_metadata", true);
        
        return esClient.get(g -> g
            .index("knowledge_base")
            .id(docId),
            Map.class
        ).thenApply(response -> {
            if (!response.found()) {
                return CallToolResult.text("ç„¡æ³•å–å¾—æ–‡ä»¶ " + docId + "ï¼šæ–‡ä»¶ä¸å­˜åœ¨");
            }
            
            @SuppressWarnings("unchecked")
            Map<String, Object> source = response.source();
            
            StringBuilder output = new StringBuilder();
            output.append("# ").append(source.get("title")).append("\n\n");
            
            if (includeMetadata) {
                output.append("## æ–‡ä»¶è³‡è¨Š\n");
                output.append("- **ä½œè€…**ï¼š")
                      .append(source.getOrDefault("author", "N/A")).append("\n");
                output.append("- **å»ºç«‹æ—¥æœŸ**ï¼š")
                      .append(source.getOrDefault("created_at", "N/A")).append("\n");
                output.append("- **æ›´æ–°æ—¥æœŸ**ï¼š")
                      .append(source.getOrDefault("updated_at", "N/A")).append("\n");
                
                @SuppressWarnings("unchecked")
                List<String> tags = (List<String>) source.getOrDefault("tags", List.of());
                output.append("- **æ¨™ç±¤**ï¼š").append(String.join(", ", tags)).append("\n\n");
            }
            
            output.append("## å…§å®¹\n\n");
            output.append(source.getOrDefault("content", "ï¼ˆç„¡å…§å®¹ï¼‰"));
            
            return CallToolResult.text(output.toString());
        }).exceptionally(e -> CallToolResult.error("ç„¡æ³•å–å¾—æ–‡ä»¶ " + docId + "ï¼š" + e.getMessage()));
    }
    
    /**
     * FAQ å•ç­”
     */
    private CompletableFuture<CallToolResult> askFaq(Map<String, Object> args) {
        String question = (String) args.get("question");
        String category = (String) args.get("category");
        
        List<Query> mustQueries = List.of(
            MultiMatchQuery.of(mm -> mm
                .query(question)
                .fields("question^2", "answer")
                .type(TextQueryType.BestFields)
            )._toQuery()
        );
        
        List<Query> filterQueries = new ArrayList<>();
        filterQueries.add(TermQuery.of(t -> t.field("type").value("faq"))._toQuery());
        
        if (category != null) {
            filterQueries.add(TermQuery.of(t -> t
                .field("category")
                .value(category)
            )._toQuery());
        }
        
        return esClient.search(s -> s
            .index("knowledge_base")
            .query(q -> q.bool(b -> b
                .must(mustQueries)
                .filter(filterQueries)
            ))
            .size(5),
            Map.class
        ).thenApply(response -> {
            List<Hit<Map>> hits = response.hits().hits();
            
            if (hits.isEmpty()) {
                return CallToolResult.text("FAQ ä¸­æ²’æœ‰æ‰¾åˆ°èˆ‡ã€Œ" + question + "ã€ç›¸é—œçš„å•ç­”");
            }
            
            // å–æœ€ç›¸é—œçš„ç­”æ¡ˆ
            Hit<Map> bestHit = hits.get(0);
            @SuppressWarnings("unchecked")
            Map<String, Object> bestMatch = bestHit.source();
            double score = bestHit.score();
            
            StringBuilder output = new StringBuilder();
            output.append("## FAQ å›ç­”\n\n");
            output.append("**å•é¡Œ**ï¼š").append(bestMatch.get("question")).append("\n\n");
            output.append("**ç­”æ¡ˆ**ï¼š").append(bestMatch.get("answer")).append("\n\n");
            output.append("**åˆ†é¡**ï¼š")
                  .append(bestMatch.getOrDefault("category", "general")).append("\n");
            output.append("**ç›¸é—œåº¦**ï¼š").append(String.format("%.2f", score)).append("\n\n");
            
            if (hits.size() > 1) {
                output.append("### å…¶ä»–ç›¸é—œå•é¡Œ\n");
                for (int i = 1; i < Math.min(4, hits.size()); i++) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> otherSource = hits.get(i).source();
                    output.append("- ").append(otherSource.get("question")).append("\n");
                }
            }
            
            return CallToolResult.text(output.toString());
        }).exceptionally(e -> CallToolResult.error("FAQ æŸ¥è©¢å¤±æ•—ï¼š" + e.getMessage()));
    }
}
```

---

### 9.2 æ¡ˆä¾‹äºŒï¼šDevOps æ•´åˆ MCP Server

#### 9.2.1 éœ€æ±‚èƒŒæ™¯

- **å ´æ™¯**ï¼šé–‹ç™¼åœ˜éšŠéœ€è¦ AI å”åŠ©ç®¡ç† CI/CDã€ç›£æ§ã€éƒ¨ç½²
- **ç›®æ¨™**ï¼šé€éå°è©±å¼ä»‹é¢æ“ä½œ DevOps å·¥å…·éˆ
- **æ•´åˆå·¥å…·**ï¼šJenkinsã€Kubernetesã€Prometheusã€GitLab

#### 9.2.2 æ¶æ§‹è¨­è¨ˆ

```mermaid
graph LR
    subgraph "AI åŠ©æ‰‹"
        Claude[Claude]
    end
    
    subgraph "DevOps MCP"
        DevServer[DevOps Server]
        
        subgraph "å·¥å…·é›†"
            CI[CI/CD å·¥å…·]
            K8s[K8s å·¥å…·]
            Monitor[ç›£æ§å·¥å…·]
        end
    end
    
    subgraph "åŸºç¤è¨­æ–½"
        Jenkins[Jenkins]
        Kubernetes[Kubernetes]
        Prometheus[Prometheus]
        GitLab[GitLab]
    end
    
    Claude --> DevServer
    DevServer --> CI
    DevServer --> K8s
    DevServer --> Monitor
    
    CI --> Jenkins
    CI --> GitLab
    K8s --> Kubernetes
    Monitor --> Prometheus
```

#### 9.2.3 æ ¸å¿ƒå·¥å…·

```java
/**
 * DevOps MCP Server
 */
package com.example.mcp.devops;

import io.kubernetes.client.openapi.*;
import io.kubernetes.client.openapi.apis.*;
import io.kubernetes.client.openapi.models.*;
import io.kubernetes.client.util.Config;
import io.modelcontextprotocol.server.*;
import io.modelcontextprotocol.spec.McpSchema.*;
import okhttp3.*;

import java.io.IOException;
import java.time.*;
import java.util.*;
import java.util.concurrent.*;

public class DevOpsMcpServer {
    
    // é…ç½®
    private static final String JENKINS_URL = "http://jenkins.internal";
    private static final String PROMETHEUS_URL = "http://prometheus.internal:9090";
    
    private final McpServer server;
    private final CoreV1Api k8sCoreApi;
    private final AppsV1Api k8sAppsApi;
    private final OkHttpClient httpClient;
    
    public DevOpsMcpServer() throws IOException {
        this.server = McpServer.builder()
            .name("devops")
            .version("1.0.0")
            .build();
        
        // è¼‰å…¥ K8s é…ç½®
        ApiClient k8sClient;
        try {
            k8sClient = Config.fromCluster();
        } catch (Exception e) {
            k8sClient = Config.defaultClient();
        }
        Configuration.setDefaultApiClient(k8sClient);
        
        this.k8sCoreApi = new CoreV1Api();
        this.k8sAppsApi = new AppsV1Api();
        this.httpClient = new OkHttpClient();
        
        setupHandlers();
    }
    
    private void setupHandlers() {
        // å·¥å…·åˆ—è¡¨
        server.setToolListHandler(request -> CompletableFuture.supplyAsync(() -> {
            List<Tool> tools = List.of(
                // CI/CD å·¥å…·
                Tool.builder()
                    .name("trigger_pipeline")
                    .description("è§¸ç™¼ CI/CD Pipeline")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "project", Map.of("type", "string", "description", "å°ˆæ¡ˆåç¨±"),
                            "branch", Map.of("type", "string", "default", "main"),
                            "parameters", Map.of("type", "object", "description", "Pipeline åƒæ•¸")
                        ),
                        "required", List.of("project")
                    ))
                    .build(),
                    
                Tool.builder()
                    .name("get_pipeline_status")
                    .description("å–å¾— Pipeline åŸ·è¡Œç‹€æ…‹")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "project", Map.of("type", "string"),
                            "build_number", Map.of("type", "integer")
                        ),
                        "required", List.of("project")
                    ))
                    .build(),
                    
                // Kubernetes å·¥å…·
                Tool.builder()
                    .name("list_pods")
                    .description("åˆ—å‡º Kubernetes Pods")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "namespace", Map.of("type", "string", "default", "default"),
                            "label_selector", Map.of("type", "string"),
                            "status", Map.of(
                                "type", "string",
                                "enum", List.of("all", "running", "pending", "failed")
                            )
                        )
                    ))
                    .build(),
                    
                Tool.builder()
                    .name("scale_deployment")
                    .description("èª¿æ•´ Deployment å‰¯æœ¬æ•¸")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "name", Map.of("type", "string", "description", "Deployment åç¨±"),
                            "namespace", Map.of("type", "string", "default", "default"),
                            "replicas", Map.of("type", "integer", "minimum", 0, "maximum", 50)
                        ),
                        "required", List.of("name", "replicas")
                    ))
                    .build(),
                    
                Tool.builder()
                    .name("get_pod_logs")
                    .description("å–å¾— Pod æ—¥èªŒ")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "pod_name", Map.of("type", "string"),
                            "namespace", Map.of("type", "string", "default", "default"),
                            "container", Map.of("type", "string"),
                            "tail_lines", Map.of("type", "integer", "default", 100)
                        ),
                        "required", List.of("pod_name")
                    ))
                    .build(),
                    
                // ç›£æ§å·¥å…·
                Tool.builder()
                    .name("query_metrics")
                    .description("æŸ¥è©¢ Prometheus æŒ‡æ¨™")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "query", Map.of("type", "string", "description", "PromQL æŸ¥è©¢"),
                            "time_range", Map.of(
                                "type", "string",
                                "enum", List.of("5m", "15m", "1h", "6h", "24h"),
                                "default", "15m"
                            )
                        ),
                        "required", List.of("query")
                    ))
                    .build(),
                    
                Tool.builder()
                    .name("get_service_health")
                    .description("å–å¾—æœå‹™å¥åº·ç‹€æ…‹æ‘˜è¦")
                    .inputSchema(Map.of(
                        "type", "object",
                        "properties", Map.of(
                            "service", Map.of("type", "string"),
                            "namespace", Map.of("type", "string", "default", "default")
                        ),
                        "required", List.of("service")
                    ))
                    .build()
            );
            
            return ListToolsResult.builder().tools(tools).build();
        }));
        
        // å·¥å…·å‘¼å«è™•ç†
        server.setToolHandler(request -> {
            String name = request.getParams().getName();
            Map<String, Object> args = request.getParams().getArguments();
            
            return switch (name) {
                case "trigger_pipeline" -> triggerPipeline(args);
                case "get_pipeline_status" -> getPipelineStatus(args);
                case "list_pods" -> listPods(args);
                case "scale_deployment" -> scaleDeployment(args);
                case "get_pod_logs" -> getPodLogs(args);
                case "query_metrics" -> queryMetrics(args);
                case "get_service_health" -> getServiceHealth(args);
                default -> CompletableFuture.completedFuture(
                    CallToolResult.error("æœªçŸ¥å·¥å…·ï¼š" + name)
                );
            };
        });
    }
    
    // ===== å·¥å…·å¯¦ä½œ =====
    
    /**
     * è§¸ç™¼ Pipeline
     */
    private CompletableFuture<CallToolResult> triggerPipeline(Map<String, Object> args) {
        return CompletableFuture.supplyAsync(() -> {
            String project = (String) args.get("project");
            String branch = (String) args.getOrDefault("branch", "main");
            @SuppressWarnings("unchecked")
            Map<String, String> parameters = (Map<String, String>) args.getOrDefault("parameters", Map.of());
            
            HttpUrl.Builder urlBuilder = HttpUrl.parse(JENKINS_URL + "/job/" + project + "/buildWithParameters")
                .newBuilder()
                .addQueryParameter("BRANCH", branch);
            
            parameters.forEach(urlBuilder::addQueryParameter);
            
            Request request = new Request.Builder()
                .url(urlBuilder.build())
                .post(RequestBody.create("", null))
                .build();
            
            try (Response response = httpClient.newCall(request).execute()) {
                if (response.code() == 201) {
                    String location = response.header("Location", "");
                    return CallToolResult.text(String.format(
                        "âœ… Pipeline å·²è§¸ç™¼%nå°ˆæ¡ˆï¼š%s%nåˆ†æ”¯ï¼š%s%nè¿½è¹¤ï¼š%s",
                        project, branch, location
                    ));
                } else {
                    return CallToolResult.error("âŒ è§¸ç™¼å¤±æ•—ï¼š" + response.code());
                }
            } catch (IOException e) {
                return CallToolResult.error("âŒ è§¸ç™¼å¤±æ•—ï¼š" + e.getMessage());
            }
        });
    }
    
    /**
     * å–å¾— Pipeline ç‹€æ…‹
     */
    private CompletableFuture<CallToolResult> getPipelineStatus(Map<String, Object> args) {
        // å¯¦ä½œé¡ä¼¼ï¼Œçœç•¥è©³ç´°ç¨‹å¼ç¢¼
        return CompletableFuture.completedFuture(CallToolResult.text("Pipeline ç‹€æ…‹æŸ¥è©¢"));
    }
    
    /**
     * åˆ—å‡º Pods
     */
    private CompletableFuture<CallToolResult> listPods(Map<String, Object> args) {
        return CompletableFuture.supplyAsync(() -> {
            String namespace = (String) args.getOrDefault("namespace", "default");
            String labelSelector = (String) args.get("label_selector");
            String statusFilter = (String) args.getOrDefault("status", "all");
            
            try {
                V1PodList podList = k8sCoreApi.listNamespacedPod(
                    namespace, null, null, null, null,
                    labelSelector, null, null, null, null, null
                );
                
                StringBuilder output = new StringBuilder();
                output.append("## Pods in ").append(namespace).append("\n\n");
                output.append("| Name | Status | Restarts | Age |\n");
                output.append("|------|--------|----------|-----|\n");
                
                for (V1Pod pod : podList.getItems()) {
                    String status = pod.getStatus().getPhase();
                    
                    // éæ¿¾ç‹€æ…‹
                    if (!"all".equals(statusFilter)) {
                        if ("running".equals(statusFilter) && !"Running".equals(status)) continue;
                        if ("pending".equals(statusFilter) && !"Pending".equals(status)) continue;
                        if ("failed".equals(statusFilter) && 
                            !"Failed".equals(status) && !"Error".equals(status)) continue;
                    }
                    
                    // è¨ˆç®—é‡å•Ÿæ¬¡æ•¸
                    int restarts = 0;
                    if (pod.getStatus().getContainerStatuses() != null) {
                        restarts = pod.getStatus().getContainerStatuses().stream()
                            .mapToInt(V1ContainerStatus::getRestartCount)
                            .sum();
                    }
                    
                    // è¨ˆç®—å¹´é½¡
                    OffsetDateTime creationTime = pod.getMetadata().getCreationTimestamp();
                    Duration age = Duration.between(creationTime.toInstant(), Instant.now());
                    String ageStr = age.toDays() > 0 ? 
                        age.toDays() + "d" : age.toHours() + "h";
                    
                    output.append(String.format("| %s | %s | %d | %s |%n",
                        pod.getMetadata().getName(), status, restarts, ageStr));
                }
                
                return CallToolResult.text(output.toString());
                
            } catch (ApiException e) {
                return CallToolResult.error("âŒ åˆ—å‡º Pods å¤±æ•—ï¼š" + e.getMessage());
            }
        });
    }
    
    /**
     * èª¿æ•´ Deployment å‰¯æœ¬
     */
    private CompletableFuture<CallToolResult> scaleDeployment(Map<String, Object> args) {
        return CompletableFuture.supplyAsync(() -> {
            String name = (String) args.get("name");
            String namespace = (String) args.getOrDefault("namespace", "default");
            int replicas = ((Number) args.get("replicas")).intValue();
            
            try {
                // å–å¾—ç•¶å‰ç‹€æ…‹
                V1Deployment deployment = k8sAppsApi.readNamespacedDeployment(
                    name, namespace, null
                );
                int current = deployment.getSpec().getReplicas();
                
                // æ›´æ–°å‰¯æœ¬æ•¸
                deployment.getSpec().setReplicas(replicas);
                k8sAppsApi.replaceNamespacedDeployment(name, namespace, deployment, null, null, null, null);
                
                return CallToolResult.text(String.format(
                    "âœ… Deployment %s å·²èª¿æ•´%nå‰¯æœ¬æ•¸ï¼š%d â†’ %d",
                    name, current, replicas
                ));
                
            } catch (ApiException e) {
                return CallToolResult.error("âŒ èª¿æ•´å¤±æ•—ï¼š" + e.getMessage());
            }
        });
    }
    
    /**
     * å–å¾— Pod æ—¥èªŒ
     */
    private CompletableFuture<CallToolResult> getPodLogs(Map<String, Object> args) {
        return CompletableFuture.supplyAsync(() -> {
            String podName = (String) args.get("pod_name");
            String namespace = (String) args.getOrDefault("namespace", "default");
            String container = (String) args.get("container");
            int tailLines = ((Number) args.getOrDefault("tail_lines", 100)).intValue();
            
            try {
                String logs = k8sCoreApi.readNamespacedPodLog(
                    podName, namespace, container, null, null, null, null,
                    null, null, tailLines, null
                );
                
                return CallToolResult.text("## Pod æ—¥èªŒï¼š" + podName + "\n\n```\n" + logs + "\n```");
                
            } catch (ApiException e) {
                return CallToolResult.error("âŒ å–å¾—æ—¥èªŒå¤±æ•—ï¼š" + e.getMessage());
            }
        });
    }
    
    /**
     * æŸ¥è©¢ Prometheus æŒ‡æ¨™
     */
    private CompletableFuture<CallToolResult> queryMetrics(Map<String, Object> args) {
        return CompletableFuture.supplyAsync(() -> {
            String query = (String) args.get("query");
            String timeRange = (String) args.getOrDefault("time_range", "15m");
            
            HttpUrl url = HttpUrl.parse(PROMETHEUS_URL + "/api/v1/query_range")
                .newBuilder()
                .addQueryParameter("query", query)
                .addQueryParameter("start", "now()-" + timeRange)
                .addQueryParameter("end", "now()")
                .addQueryParameter("step", "60s")
                .build();
            
            Request request = new Request.Builder().url(url).get().build();
            
            try (Response response = httpClient.newCall(request).execute()) {
                // è§£æ Prometheus å›æ‡‰ä¸¦æ ¼å¼åŒ–è¼¸å‡º
                String body = response.body().string();
                
                StringBuilder output = new StringBuilder();
                output.append("## æŒ‡æ¨™æŸ¥è©¢çµæœ\n\n");
                output.append("æŸ¥è©¢ï¼š`").append(query).append("`\n");
                output.append("æ™‚é–“ç¯„åœï¼š").append(timeRange).append("\n\n");
                output.append("å›æ‡‰ï¼š").append(body.substring(0, Math.min(500, body.length())));
                
                return CallToolResult.text(output.toString());
                
            } catch (IOException e) {
                return CallToolResult.error("æŸ¥è©¢å¤±æ•—ï¼š" + e.getMessage());
            }
        });
    }
    
    /**
     * å–å¾—æœå‹™å¥åº·ç‹€æ…‹
     */
    private CompletableFuture<CallToolResult> getServiceHealth(Map<String, Object> args) {
        return CompletableFuture.supplyAsync(() -> {
            String service = (String) args.get("service");
            String namespace = (String) args.getOrDefault("namespace", "default");
            
            StringBuilder output = new StringBuilder();
            output.append("## æœå‹™å¥åº·ç‹€æ…‹ï¼š").append(service).append("\n\n");
            
            try {
                // 1. æª¢æŸ¥ Pods ç‹€æ…‹
                V1PodList pods = k8sCoreApi.listNamespacedPod(
                    namespace, null, null, null, null,
                    "app=" + service, null, null, null, null, null
                );
                
                long running = pods.getItems().stream()
                    .filter(p -> "Running".equals(p.getStatus().getPhase()))
                    .count();
                int total = pods.getItems().size();
                
                output.append("### Pods\n");
                output.append("- é‹è¡Œä¸­ï¼š").append(running).append("/").append(total).append("\n");
                output.append("- ç‹€æ…‹ï¼š").append(running == total ? "âœ… å¥åº·" : "âš ï¸ ç•°å¸¸").append("\n\n");
                
                // 2. æŸ¥è©¢éŒ¯èª¤ç‡ï¼ˆé€é Prometheusï¼‰
                String errorQuery = String.format(
                    "sum(rate(http_requests_total{service=\"%s\",status=~\"5..\"}[5m]))",
                    service
                );
                
                HttpUrl url = HttpUrl.parse(PROMETHEUS_URL + "/api/v1/query")
                    .newBuilder()
                    .addQueryParameter("query", errorQuery)
                    .build();
                
                Request request = new Request.Builder().url(url).get().build();
                
                try (Response response = httpClient.newCall(request).execute()) {
                    if (response.isSuccessful()) {
                        output.append("### éŒ¯èª¤ç‡\n");
                        output.append("- æŸ¥è©¢å·²åŸ·è¡Œï¼ˆè©³è¦‹ Prometheusï¼‰\n\n");
                    }
                } catch (Exception e) {
                    // å¿½ç•¥ Prometheus éŒ¯èª¤
                }
                
                return CallToolResult.text(output.toString());
                
            } catch (ApiException e) {
                return CallToolResult.error("âŒ å–å¾—å¥åº·ç‹€æ…‹å¤±æ•—ï¼š" + e.getMessage());
            }
        });
    }
}
```

---

*ï¼ˆç¬¬ä¹ç« å®Œçµï¼Œç¹¼çºŒç¬¬åç« ï¼‰*

---

## ç¬¬åç« ï¼šè³‡æºèˆ‡åƒè€ƒ

### 10.1 å®˜æ–¹è³‡æº

#### 10.1.1 æ ¸å¿ƒæ–‡ä»¶

| è³‡æº | URL | èªªæ˜ |
|------|-----|------|
| **MCP è¦æ ¼æ›¸** | [spec.modelcontextprotocol.io](https://spec.modelcontextprotocol.io) | å®Œæ•´å”è­°è¦æ ¼ |
| **å®˜æ–¹æ–‡ä»¶** | [modelcontextprotocol.io/docs](https://modelcontextprotocol.io/docs) | å…¥é–€æ•™å­¸èˆ‡æŒ‡å— |
| **GitHub çµ„ç¹”** | [github.com/modelcontextprotocol](https://github.com/modelcontextprotocol) | æ‰€æœ‰å®˜æ–¹å°ˆæ¡ˆ |
| **Anthropic MCP ä»‹ç´¹** | [anthropic.com/news/model-context-protocol](https://anthropic.com/news/model-context-protocol) | å®˜æ–¹å…¬å‘Šèˆ‡èªªæ˜ |

#### 10.1.2 SDK èˆ‡å·¥å…·

| å°ˆæ¡ˆ | èªè¨€ | èªªæ˜ |
|------|------|------|
| **mcp** | Python | å®˜æ–¹ Python SDK |
| **@modelcontextprotocol/sdk** | TypeScript | å®˜æ–¹ TypeScript SDK |
| **mcp-inspector** | TypeScript | äº’å‹•å¼é™¤éŒ¯å·¥å…· |
| **mcp-cli** | TypeScript | å‘½ä»¤åˆ—æ¸¬è©¦å·¥å…· |

**å®‰è£æŒ‡ä»¤**ï¼š

```bash
# Python SDK
pip install mcp
# æˆ–ä½¿ç”¨ uv
uv add mcp

# TypeScript SDK
npm install @modelcontextprotocol/sdk

# Inspector
npx @modelcontextprotocol/inspector <server-command>
```

#### 10.1.3 å®˜æ–¹ç¯„ä¾‹ Server

| Server | åŠŸèƒ½ | ä¾†æº |
|--------|------|------|
| **filesystem** | æª”æ¡ˆç³»çµ±æ“ä½œ | å®˜æ–¹ç¯„ä¾‹ |
| **memory** | çŸ¥è­˜åœ–è­œè¨˜æ†¶ | å®˜æ–¹ç¯„ä¾‹ |
| **puppeteer** | ç€è¦½å™¨è‡ªå‹•åŒ– | å®˜æ–¹ç¯„ä¾‹ |
| **brave-search** | ç¶²è·¯æœå°‹ | å®˜æ–¹ç¯„ä¾‹ |
| **github** | GitHub æ•´åˆ | å®˜æ–¹ç¯„ä¾‹ |
| **gitlab** | GitLab æ•´åˆ | å®˜æ–¹ç¯„ä¾‹ |
| **google-maps** | Google Maps API | å®˜æ–¹ç¯„ä¾‹ |
| **slack** | Slack æ•´åˆ | å®˜æ–¹ç¯„ä¾‹ |
| **postgres** | PostgreSQL è³‡æ–™åº« | å®˜æ–¹ç¯„ä¾‹ |
| **sqlite** | SQLite è³‡æ–™åº« | å®˜æ–¹ç¯„ä¾‹ |

---

### 10.2 ç¤¾ç¾¤è³‡æº

#### 10.2.1 ç¬¬ä¸‰æ–¹ Server é›†åˆ

| è³‡æº | èªªæ˜ |
|------|------|
| **Awesome MCP Servers** | ç¤¾ç¾¤ç¶­è­·çš„ MCP Server åˆ—è¡¨ |
| **MCP Hub** | MCP Server é›†ä¸­å€‰åº« |

#### 10.2.2 å­¸ç¿’è³‡æº

| é¡å‹ | è³‡æº |
|------|------|
| **æ•™å­¸æ–‡ç« ** | - Anthropic å®˜æ–¹ Blog<br>- Dev.to MCP æ¨™ç±¤<br>- Medium MCP æ–‡ç«  |
| **å½±ç‰‡æ•™å­¸** | - YouTube MCP ç³»åˆ—<br>- Anthropic å®˜æ–¹ç›´æ’­ |
| **ç¤¾ç¾¤è¨è«–** | - Discord: MCP Community<br>- Reddit: r/mcp |

---

### 10.3 é–‹ç™¼ç’°å¢ƒå»ºè­°

#### 10.3.1 VS Code æ“´å……å¥—ä»¶

| æ“´å……å¥—ä»¶ | ç”¨é€” |
|----------|------|
| **Python** | Python é–‹ç™¼æ”¯æ´ |
| **Pylance** | Python å‹åˆ¥æª¢æŸ¥ |
| **Ruff** | Python Linter |
| **REST Client** | HTTP è«‹æ±‚æ¸¬è©¦ |
| **YAML** | YAML æ ¼å¼æ”¯æ´ |
| **JSON Schema Store** | JSON Schema é©—è­‰ |

#### 10.3.2 æ¨è–¦å°ˆæ¡ˆçµæ§‹

```
my-mcp-server/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main/
â”‚       â”œâ”€â”€ java/
â”‚       â”‚   â””â”€â”€ com/
â”‚       â”‚       â””â”€â”€ example/
â”‚       â”‚           â””â”€â”€ mcp/
â”‚       â”‚               â”œâ”€â”€ McpServerApp.java       # Server ä¸»ç¨‹å¼
â”‚       â”‚               â”œâ”€â”€ tools/                  # å·¥å…·å¯¦ä½œ
â”‚       â”‚               â”‚   â”œâ”€â”€ FileTools.java
â”‚       â”‚               â”‚   â””â”€â”€ ApiTools.java
â”‚       â”‚               â”œâ”€â”€ resources/              # è³‡æºå¯¦ä½œ
â”‚       â”‚               â”‚   â””â”€â”€ DataResources.java
â”‚       â”‚               â””â”€â”€ util/                   # å·¥å…·å‡½æ•¸
â”‚       â”‚                   â”œâ”€â”€ ValidationUtils.java
â”‚       â”‚                   â””â”€â”€ CacheUtils.java
â”‚       â””â”€â”€ resources/
â”‚           â””â”€â”€ log4j2.xml
â”œâ”€â”€ src/
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/
â”‚           â””â”€â”€ com/
â”‚               â””â”€â”€ example/
â”‚                   â””â”€â”€ mcp/
â”‚                       â”œâ”€â”€ tools/
â”‚                       â”‚   â””â”€â”€ FileToolsTest.java
â”‚                       â””â”€â”€ resources/
â”‚                           â””â”€â”€ DataResourcesTest.java
â”œâ”€â”€ pom.xml
â”œâ”€â”€ README.md
â””â”€â”€ .env.example
```

#### 10.3.3 pom.xml ç¯„æœ¬

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-mcp-server</artifactId>
    <version>0.1.0</version>
    <packaging>jar</packaging>

    <name>My MCP Server</name>
    <description>My MCP Server Implementation</description>

    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- MCP SDK -->
        <dependency>
            <groupId>io.modelcontextprotocol</groupId>
            <artifactId>mcp-sdk</artifactId>
            <version>1.1.0</version>
        </dependency>

        <!-- JSON è™•ç† -->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>2.10.1</version>
        </dependency>

        <!-- HTTP å®¢æˆ¶ç«¯ -->
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>4.12.0</version>
        </dependency>

        <!-- æ—¥èªŒ -->
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.22.1</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-slf4j2-impl</artifactId>
            <version>2.22.1</version>
        </dependency>

        <!-- æ¸¬è©¦ -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>5.8.0</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.12.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.3.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>com.example.mcp.McpServerApp</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.1</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>com.example.mcp.McpServerApp</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

---

### 10.4 ç‰ˆæœ¬ç›¸å®¹æ€§

#### 10.4.1 MCP å”è­°ç‰ˆæœ¬

| ç‰ˆæœ¬ | æ—¥æœŸ | é‡å¤§è®Šæ›´ |
|------|------|---------|
| **2025-11-25** | 2025-11 | æ–°å¢ Elicitationã€Tasks ç­‰å¯¦é©—æ€§åŠŸèƒ½ |
| **2024-11-05** | 2024-11 | åˆå§‹ç©©å®šç‰ˆæœ¬ |

#### 10.4.2 SDK ç‰ˆæœ¬å°ç…§

| Python SDK | TypeScript SDK | å”è­°ç‰ˆæœ¬ |
|------------|----------------|---------|
| 1.1.x | 1.1.x | 2025-11-25 |
| 1.0.x | 1.0.x | 2024-11-05 |

#### 10.4.3 Client æ”¯æ´ç‹€æ…‹

| Client | æ”¯æ´åŠŸèƒ½ | å‚™è¨» |
|--------|---------|------|
| **Claude Desktop** | Tools, Resources, Prompts, Sampling | å®Œæ•´æ”¯æ´ |
| **Claude Code** | Tools, Resources | VS Code æ•´åˆ |
| **è‡ªè¨‚ Client** | ä¾å¯¦ä½œè€Œå®š | å¯ä½¿ç”¨ SDK |

---

### 10.5 å¿«é€Ÿåƒè€ƒ

#### 10.5.1 JSON-RPC æ–¹æ³•åˆ—è¡¨

| æ–¹æ³• | æ–¹å‘ | èªªæ˜ |
|------|------|------|
| `initialize` | Câ†’S | åˆå§‹åŒ–é€£æ¥ |
| `initialized` | Câ†’S | ç¢ºèªåˆå§‹åŒ–å®Œæˆï¼ˆé€šçŸ¥ï¼‰ |
| `tools/list` | Câ†’S | åˆ—å‡ºå·¥å…· |
| `tools/call` | Câ†’S | å‘¼å«å·¥å…· |
| `resources/list` | Câ†’S | åˆ—å‡ºè³‡æº |
| `resources/read` | Câ†’S | è®€å–è³‡æº |
| `resources/subscribe` | Câ†’S | è¨‚é–±è³‡æºè®Šæ›´ |
| `prompts/list` | Câ†’S | åˆ—å‡ºæç¤ºè© |
| `prompts/get` | Câ†’S | å–å¾—æç¤ºè© |
| `sampling/createMessage` | Sâ†’C | è«‹æ±‚ AI ç”Ÿæˆ |
| `logging/setLevel` | Câ†’S | è¨­å®šæ—¥èªŒç­‰ç´š |
| `notifications/tools/list_changed` | Sâ†’C | å·¥å…·åˆ—è¡¨è®Šæ›´é€šçŸ¥ |
| `notifications/resources/list_changed` | Sâ†’C | è³‡æºåˆ—è¡¨è®Šæ›´é€šçŸ¥ |
| `notifications/resources/updated` | Sâ†’C | è³‡æºæ›´æ–°é€šçŸ¥ |

#### 10.5.2 å¸¸ç”¨ç¨‹å¼ç¢¼ç‰‡æ®µ

**å¿«é€Ÿå»ºç«‹ Server**ï¼š

```java
package com.example.mcp;

import io.modelcontextprotocol.server.*;
import io.modelcontextprotocol.server.transport.*;
import io.modelcontextprotocol.spec.McpSchema.*;

import java.util.*;
import java.util.concurrent.*;

public class McpServerApp {
    
    public static void main(String[] args) {
        McpServer server = McpServer.builder()
            .name("my-server")
            .version("1.0.0")
            .build();
        
        // å·¥å…·åˆ—è¡¨
        server.setToolListHandler(request -> 
            CompletableFuture.completedFuture(
                ListToolsResult.builder()
                    .tools(List.of(/* å·¥å…·å®šç¾© */))
                    .build()
            )
        );
        
        // å·¥å…·å‘¼å«
        server.setToolHandler(request -> 
            CompletableFuture.supplyAsync(() -> {
                String name = request.getParams().getName();
                Map<String, Object> args = request.getParams().getArguments();
                // è™•ç†å·¥å…·å‘¼å«
                return CallToolResult.text("çµæœ");
            })
        );
        
        // ä½¿ç”¨ STDIO å‚³è¼¸å•Ÿå‹•
        StdioServerTransport transport = new StdioServerTransport();
        server.connect(transport).join();
    }
}
```

**Claude Desktop é…ç½®**ï¼š

```json
{
  "mcpServers": {
    "my-server": {
      "command": "java",
      "args": ["-jar", "/path/to/my-mcp-server.jar"],
      "env": {
        "MY_VAR": "value"
      }
    }
  }
}
```

---

## é™„éŒ„ï¼šæª¢æŸ¥æ¸…å–®ï¼ˆChecklistï¼‰

### A. Server é–‹ç™¼æª¢æŸ¥æ¸…å–®

#### A.1 åŸºæœ¬åŠŸèƒ½

- [ ] Server å¯ä»¥æˆåŠŸå•Ÿå‹•
- [ ] å¯ä»¥é€é STDIO é€£æ¥
- [ ] `initialize` æ­£ç¢ºå›æ‡‰ Server èƒ½åŠ›
- [ ] `tools/list` å›å‚³æ‰€æœ‰å·¥å…·å®šç¾©
- [ ] æ‰€æœ‰å·¥å…·æœ‰å®Œæ•´çš„ `inputSchema`
- [ ] å·¥å…·æè¿°æ¸…æ¥šæ˜ç¢º
- [ ] `tools/call` æ­£ç¢ºè™•ç†æ‰€æœ‰å·¥å…·

#### A.2 è³‡æºèˆ‡æç¤ºè©ï¼ˆå¦‚é©ç”¨ï¼‰

- [ ] `resources/list` å›å‚³è³‡æºæ¸…å–®
- [ ] `resources/read` æ­£ç¢ºè®€å–è³‡æº
- [ ] è³‡æº URI æ ¼å¼æ­£ç¢º
- [ ] `prompts/list` å›å‚³æç¤ºè©æ¸…å–®
- [ ] `prompts/get` æ­£ç¢ºå›å‚³æç¤ºè©å…§å®¹

#### A.3 éŒ¯èª¤è™•ç†

- [ ] è™•ç†ç„¡æ•ˆåƒæ•¸ä¸¦å›å‚³æœ‰æ„ç¾©çš„éŒ¯èª¤
- [ ] è™•ç†è³‡æºä¸å­˜åœ¨çš„æƒ…æ³
- [ ] è™•ç†æ¬Šé™è¢«æ‹’çµ•çš„æƒ…æ³
- [ ] è™•ç†ç¶²è·¯éŒ¯èª¤å’Œè¶…æ™‚
- [ ] ä¸æœƒå› ç‚ºå–®ä¸€å·¥å…·éŒ¯èª¤è€Œå´©æ½°

#### A.4 å®‰å…¨æ€§

- [ ] å¯¦ä½œè¼¸å…¥é©—è­‰
- [ ] è·¯å¾‘æ“ä½œé˜²æ­¢ç›®éŒ„éæ­·
- [ ] SQL æ“ä½œä½¿ç”¨åƒæ•¸åŒ–æŸ¥è©¢
- [ ] æ•æ„Ÿè³‡è¨Šä¸æœƒè¨˜éŒ„åœ¨æ—¥èªŒ
- [ ] API é‡‘é‘°å¾ç’°å¢ƒè®Šæ•¸è®€å–
- [ ] å¯¦ä½œé©ç•¶çš„èªè­‰æ©Ÿåˆ¶ï¼ˆå¦‚é©ç”¨ï¼‰
- [ ] å¯¦ä½œé€Ÿç‡é™åˆ¶ï¼ˆå¦‚é©ç”¨ï¼‰

#### A.5 æ•ˆèƒ½

- [ ] é•·æ™‚é–“æ“ä½œæœ‰è¶…æ™‚è¨­å®š
- [ ] è³‡æºé‡ç”¨ï¼ˆé€£æ¥æ± ç­‰ï¼‰
- [ ] é©ç•¶çš„å¿«å–ç­–ç•¥
- [ ] æ‰¹æ¬¡è™•ç†å¤§é‡è³‡æ–™

---

### B. éƒ¨ç½²æª¢æŸ¥æ¸…å–®

#### B.1 ç’°å¢ƒæº–å‚™

- [ ] Python 3.10+ æˆ– Node.js 18+ å·²å®‰è£
- [ ] æ‰€æœ‰ä¾è³´å¥—ä»¶å·²å®‰è£
- [ ] ç’°å¢ƒè®Šæ•¸å·²æ­£ç¢ºè¨­å®š
- [ ] å¿…è¦çš„èªè­‰è³‡è¨Šå·²é…ç½®
- [ ] æ—¥èªŒç›®éŒ„å­˜åœ¨ä¸”å¯å¯«å…¥

#### B.2 é…ç½®é©—è­‰

- [ ] Claude Desktop/Client é…ç½®æ­£ç¢º
- [ ] Server è·¯å¾‘æŒ‡å‘æ­£ç¢º
- [ ] ç’°å¢ƒè®Šæ•¸å‚³éæ­£ç¢º
- [ ] å…è¨±çš„ç›®éŒ„/è³‡æºå·²é…ç½®

#### B.3 é€£æ¥æ¸¬è©¦

- [ ] ä½¿ç”¨ MCP Inspector æ¸¬è©¦é€£æ¥
- [ ] æ‰€æœ‰å·¥å…·å¯ä»¥æ‰‹å‹•å‘¼å«
- [ ] è³‡æºå¯ä»¥æ­£ç¢ºè®€å–
- [ ] éŒ¯èª¤æƒ…æ³æœ‰é©ç•¶å›æ‡‰

#### B.4 ç›£æ§è¨­å®š

- [ ] æ—¥èªŒè¼¸å‡ºåˆ° stderr
- [ ] æ—¥èªŒç­‰ç´šå¯é…ç½®
- [ ] æ•ˆèƒ½æŒ‡æ¨™æ”¶é›†ï¼ˆå¦‚é©ç”¨ï¼‰
- [ ] éŒ¯èª¤è¿½è¹¤è¨­å®šï¼ˆå¦‚é©ç”¨ï¼‰

---

### C. ç¨‹å¼ç¢¼å¯©æŸ¥æª¢æŸ¥æ¸…å–®

#### C.1 ç¨‹å¼ç¢¼å“è³ª

- [ ] éµå¾ª PEP 8 / ESLint è¦ç¯„
- [ ] å‡½æ•¸æœ‰é©ç•¶çš„å‹åˆ¥æ¨™è¨»
- [ ] æœ‰å®Œæ•´çš„ docstring / JSDoc
- [ ] æ²’æœ‰ç¡¬ç·¨ç¢¼çš„æ•æ„Ÿè³‡è¨Š
- [ ] æ²’æœ‰æœªä½¿ç”¨çš„ç¨‹å¼ç¢¼
- [ ] ç•°å¸¸è™•ç†é©ç•¶

#### C.2 æ¸¬è©¦æ¶µè“‹

- [ ] æ¯å€‹å·¥å…·æœ‰å–®å…ƒæ¸¬è©¦
- [ ] éŒ¯èª¤æƒ…æ³æœ‰æ¸¬è©¦
- [ ] æ•´åˆæ¸¬è©¦é€šé
- [ ] æ¸¬è©¦æ¶µè“‹ç‡ > 80%

#### C.3 æ–‡ä»¶å®Œæ•´

- [ ] README èªªæ˜å¦‚ä½•å®‰è£å’Œä½¿ç”¨
- [ ] æœ‰ API æ–‡ä»¶æˆ–å·¥å…·èªªæ˜
- [ ] æœ‰é…ç½®ç¯„ä¾‹
- [ ] æœ‰å¸¸è¦‹å•é¡Œèªªæ˜

---

### D. æ•…éšœæ’é™¤æª¢æŸ¥æ¸…å–®

#### D.1 Server ç„¡æ³•å•Ÿå‹•

- [ ] æª¢æŸ¥ Python/Node.js ç‰ˆæœ¬
- [ ] æª¢æŸ¥ä¾è³´å¥—ä»¶æ˜¯å¦å®‰è£
- [ ] æª¢æŸ¥ç’°å¢ƒè®Šæ•¸æ˜¯å¦è¨­å®š
- [ ] æª¢æŸ¥ç¨‹å¼ç¢¼æ˜¯å¦æœ‰èªæ³•éŒ¯èª¤
- [ ] æŸ¥çœ‹ stderr è¼¸å‡º

#### D.2 Client ç„¡æ³•é€£æ¥

- [ ] ç¢ºèª Server æ­£åœ¨é‹è¡Œ
- [ ] æª¢æŸ¥ Client é…ç½®è·¯å¾‘
- [ ] ç¢ºèªä½¿ç”¨æ­£ç¢ºçš„å‚³è¼¸æ–¹å¼
- [ ] æª¢æŸ¥é˜²ç«ç‰†è¨­å®šï¼ˆHTTP æ¨¡å¼ï¼‰
- [ ] ä½¿ç”¨ Inspector æ¸¬è©¦

#### D.3 å·¥å…·åŸ·è¡Œå¤±æ•—

- [ ] æª¢æŸ¥åƒæ•¸æ ¼å¼æ˜¯å¦æ­£ç¢º
- [ ] ç¢ºèªè³‡æº/æª”æ¡ˆå­˜åœ¨
- [ ] æª¢æŸ¥æ¬Šé™è¨­å®š
- [ ] æŸ¥çœ‹ Server æ—¥èªŒ
- [ ] ä½¿ç”¨ Inspector æ‰‹å‹•æ¸¬è©¦

#### D.4 æ•ˆèƒ½å•é¡Œ

- [ ] æª¢æŸ¥æ˜¯å¦æœ‰ N+1 æŸ¥è©¢
- [ ] ç¢ºèªé€£æ¥æ± æ­£å¸¸é‹ä½œ
- [ ] æª¢æŸ¥å¿«å–æ˜¯å¦ç”Ÿæ•ˆ
- [ ] ç›£æ§è¨˜æ†¶é«”ä½¿ç”¨
- [ ] æª¢æŸ¥æ˜¯å¦æœ‰è³‡æºæ´©æ¼

---

## çµèª

Model Context Protocol (MCP) ä»£è¡¨äº† AI æ‡‰ç”¨æ•´åˆçš„æ–°å…¸ç¯„ã€‚é€éæ¨™æº–åŒ–çš„å”è­°ï¼Œé–‹ç™¼è€…å¯ä»¥è¼•é¬†åœ°è®“ AI åŠ©æ‰‹èˆ‡å„ç¨®è³‡æ–™ä¾†æºå’Œå·¥å…·é€²è¡Œäº’å‹•ï¼ŒåŒæ™‚ä¿æŒå®‰å…¨æ€§å’Œå¯æ§æ€§ã€‚

æœ¬æ•™å­¸æ‰‹å†Šæ¶µè“‹äº† MCP çš„æ ¸å¿ƒæ¦‚å¿µã€æŠ€è¡“æ¶æ§‹ã€å¯¦ä½œæŒ‡å—ã€æœ€ä½³å¯¦è¸ä»¥åŠå¯¦éš›æ¡ˆä¾‹ã€‚å¸Œæœ›é€™ä»½è³‡æºèƒ½å¹«åŠ©æ‚¨ï¼š

1. **ç†è§£ MCP çš„åƒ¹å€¼** â€” èªè­˜åˆ°ç‚ºä½•éœ€è¦æ¨™æº–åŒ–çš„ AI æ•´åˆå”è­°
2. **æŒæ¡æŠ€è¡“ç´°ç¯€** â€” æ·±å…¥äº†è§£å‚³è¼¸å±¤ã€JSON-RPCã€æ ¸å¿ƒåŸèª
3. **å¿«é€Ÿä¸Šæ‰‹é–‹ç™¼** â€” é€éç¯„ä¾‹ç¨‹å¼ç¢¼å»ºç«‹è‡ªå·±çš„ MCP Server
4. **éµå¾ªæœ€ä½³å¯¦è¸** â€” å»ºç«‹å®‰å…¨ã€é«˜æ•ˆã€å¯ç¶­è­·çš„è§£æ±ºæ–¹æ¡ˆ
5. **è§£æ±ºå¯¦éš›å•é¡Œ** â€” é€éæ¡ˆä¾‹ç ”ç©¶å­¸ç¿’å¯¦å‹™æ‡‰ç”¨

éš¨è‘— MCP ç”Ÿæ…‹ç³»çµ±çš„æŒçºŒç™¼å±•ï¼Œæˆ‘å€‘æœŸå¾…çœ‹åˆ°æ›´å¤šå‰µæ–°çš„æ‡‰ç”¨å ´æ™¯ã€‚æ­¡è¿åŠ å…¥ MCP ç¤¾ç¾¤ï¼Œä¸€èµ·æ¨å‹• AI å·¥å…·æ•´åˆçš„æœªä¾†ï¼

---

**æ–‡ä»¶ç‰ˆæœ¬**ï¼š1.0  
**æœ€å¾Œæ›´æ–°**ï¼š2026 å¹´  
**å”è­°ç‰ˆæœ¬**ï¼š2026-1-9 

---

*ï¼ˆæ•™å­¸æ‰‹å†Šå®Œçµï¼‰*

